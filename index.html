<!DOCTYPE html>
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Tiny Wu</title>
    
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <style>

      body {
        -webkit-font-smoothing: antialiased;
        font: 16px helvetica, arial, freesans, clean, sans-serif;
        line-height: 1.4em;
        border: none;
        line-height: 1.5;
        margin: 0 ;
        padding: 0;
        text-align: left;
        overflow: hidden;
        text-shadow:0 0px, 1px 1px #000000;
      }

      @media screen {
        #wrapper {
          padding: 9px;
          background: #f8f8f8;
          border: 1px solid #e9e9e9;
        }
      }
      h1 {
        font-size: 280%;
        margin: 0;
        padding: 0.25em 0 0.92em;
        border-top: none;
        -webkit-transform-origin: 100% 100% 50%;
        -moz-transform-origin: 100% 100% 50%;
        -ms-transform-origin: 100% 100% 50%;
        -o-transform-origin: 100% 100% 50%;
        transform-origin: 100% 100% 50%;
        -webkit-transition: all 400ms ease-in-out;
        -moz-transition: all 400ms ease-in-out;
        -o-transition: all 400ms ease-in-out;
        transition: all 400ms ease-in-out;
      }
      h1.active {
        -webkit-transform: rotate(-5deg);
        -moz-transform: rotate(-5deg);
        -ms-transform: rotate(-5deg);
        -o-transform: rotate(-5deg);
        transform: rotate(-5deg);
        text-shadow: 1px 1px 0px white, 2px 2px 0px #bada55, 3px 3px 0px #bada55, 4px 4px 0px #bada55, 5px 5px 0px #97ba28;
      }
      @media only screen and (min-width: 640px) {
        h1 {
          padding-bottom: 0;
          font-size: 425%;
        }
        h1.active {
          text-shadow: 1px 1px 0px white, 2px 2px 0px #bada55, 3px 3px 0px #bada55, 4px 4px 0px #bada55, 5px 5px 0px #bada55, 6px 6px 0px #bada55, 7px 7px 0px #97ba28;
        }
      }
      @media only screen and (min-width: 900px) {
        h1 {
          float: left;
          width: 57%;
        }
      }

      h2 {
        font-size: 200%;
        margin-top: 1.5em;
      }

      h3 {
        font-size: 150%;
        margin-top: 1.5em;
        border-top: 4px solid rgba(0, 0, 0, 0.07);
        padding-top: 0.5em;
      }

      p {
        margin: 1em 0;
        line-height: 1.5em;
      }

      pre, code {
        font: 12px "Bitstream Vera Sans Mono", "Courier", monospace;
      }

      pre {
        -webkit-box-shadow: rgba(0, 0, 0, 0.066) 0px 1px 2px 0px inset;
        background-color: #eeeeee;
        border: #dddddd 1px solid;
        color: #444444;
        display: block;
        margin: 12px 0;
        overflow: auto;
        padding: 5px;
        white-space: pre;
        max-width: 100%;
        overflow: auto;
      }


      a {
        border-bottom: 1px solid transparent;
        color: #EE113D;
        text-decoration: none;
        -webkit-transition: background-color 500ms, border-bottom-color 500ms, color 500ms;
        -moz-transition: background-color 500ms, border-bottom-color 500ms, color 500ms;
        -o-transition: background-color 500ms, border-bottom-color 500ms, color 500ms;
        transition: background-color 500ms, border-bottom-color 500ms, color 500ms;
      }
      a:hover {
        background-color: #dceca9;
        border-bottom-color: #bada55;
        color: #647b1b;
      }
      a code {
        color: #bada55;
        text-decoration: none;
      }

      table td {
        border-bottom: 1px solid #dddddd;
        padding: 0.2em 1em;
      }


    </style>

  </head>
  <body style="cursor: default;">

    <link rel="stylesheet" href="./GLSL Sandbox_files/codemirror.css">
    <link rel="stylesheet" href="./GLSL Sandbox_files/default.css">

    <script src="./GLSL Sandbox_files/lzma.js"></script>
    <script src="./GLSL Sandbox_files/jquery.js"></script>
    <script src="./GLSL Sandbox_files/helpers.js"></script>
    <script src="./GLSL Sandbox_files/codemirror.js"></script>
    <script src="./GLSL Sandbox_files/glsl.js"></script>

    <script id="sea" type="x-shader/x-fragment">
                  //大海
                  #ifdef GL_ES
                  precision mediump float;
                  #endif

                  uniform float time;
                  vec2 mouse = vec2(20, 0);
                  uniform vec2 resolution;

                  // "Seascape" by Alexander Alekseev aka TDM - 2014
                  // License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.

                  const int NUM_STEPS = 16;
                  const float PI    = 3.1415;
                  const float EPSILON = 1e-3;
                  float EPSILON_NRM = 0.;

                  // sea
                  const int ITER_GEOMETRY = 3;
                  const int ITER_FRAGMENT = 5;
                  const float SEA_HEIGHT = 0.6;
                  const float SEA_CHOPPY = 5.0;
                  const float SEA_SPEED = 1.0;
                  const float SEA_FREQ = 0.16;
                  const vec3 SEA_BASE = vec3(0.1,0.19,0.22);
                  const vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6);
                  float SEA_TIME = 0.;
                  mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);

                  // math
                  mat3 fromEuler(vec3 ang) {
                    vec2 a1 = vec2(sin(ang.x),cos(ang.x));
                      vec2 a2 = vec2(sin(ang.y),cos(ang.y));
                      vec2 a3 = vec2(sin(ang.z),cos(ang.z));
                      mat3 m;
                      m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);
                    m[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);
                    m[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);
                    return m;
                  }
                  float hash( vec2 p ) {
                    float h = dot(p,vec2(127.1,311.7)); 
                      return fract(sin(h)*43758.5453123);
                  }
                  float noise( in vec2 p ) {
                      vec2 i = floor( p );
                      vec2 f = fract( p );  
                    vec2 u = f*f*(3.0-2.0*f);
                      return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), 
                                       hash( i + vec2(1.0,0.0) ), u.x),
                                  mix( hash( i + vec2(0.0,1.0) ), 
                                       hash( i + vec2(1.0,1.0) ), u.x), u.y);
                  }

                  // lighting
                  float diffuse(vec3 n,vec3 l,float p) {
                      return pow(dot(n,l) * 0.4 + 0.6,p);
                  }
                  float specular(vec3 n,vec3 l,vec3 e,float s) {    
                      float nrm = (s + 8.0) / (3.1415 * 8.0);
                      return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;
                  }

                  // sky
                  vec3 getSkyColor(vec3 e) {
                      e.y = max(e.y,0.0);
                      vec3 ret;
                      ret.x = pow(1.0-e.y,2.0);
                      ret.y = 1.0-e.y;
                      ret.z = 0.6+(1.0-e.y)*0.4;
                      return ret;
                  }

                  // sea
                  float sea_octave(vec2 uv, float choppy) {
                      uv += noise(uv);        
                      vec2 wv = 1.0-abs(sin(uv));
                      vec2 swv = abs(cos(uv));    
                      wv = mix(wv,swv,wv);
                      return pow(1.0-pow(wv.x * wv.y,0.65),choppy);
                  }

                  float map(vec3 p) {
                      float freq = SEA_FREQ;
                      float amp = SEA_HEIGHT;
                      float choppy = SEA_CHOPPY;
                      vec2 uv = p.xz; uv.x *= 0.75;
                      
                      float d, h = 0.0;    
                      for(int i = 0; i < ITER_GEOMETRY; i++) {        
                        d = sea_octave((uv+SEA_TIME)*freq,choppy);
                        d += sea_octave((uv-SEA_TIME)*freq,choppy);
                          h += d * amp;        
                        uv *= octave_m; freq *= 1.9; amp *= 0.22;
                          choppy = mix(choppy,1.0,0.2);
                      }
                      return p.y - h;
                  }

                  float map_detailed(vec3 p) {
                      float freq = SEA_FREQ;
                      float amp = SEA_HEIGHT;
                      float choppy = SEA_CHOPPY;
                      vec2 uv = p.xz; uv.x *= 0.75;
                      
                      float d, h = 0.0;    
                      for(int i = 0; i < ITER_FRAGMENT; i++) {        
                        d = sea_octave((uv+SEA_TIME)*freq,choppy);
                        d += sea_octave((uv-SEA_TIME)*freq,choppy);
                          h += d * amp;        
                        uv *= octave_m; freq *= 1.9; amp *= 0.22;
                          choppy = mix(choppy,1.0,0.2);
                      }
                      return p.y - h;
                  }

                  vec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  
                      float fresnel = 1.0 - max(dot(n,-eye),0.0);
                      fresnel = pow(fresnel,3.0) * 0.65;
                          
                      vec3 reflected = getSkyColor(reflect(eye,n));    
                      vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; 
                      
                      vec3 color = mix(refracted,reflected,fresnel);
                      
                      float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);
                      color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;
                      
                      color += vec3(specular(n,l,eye,60.0));
                      
                      return color;
                  }

                  // tracing
                  vec3 getNormal(vec3 p, float eps) {
                      vec3 n;
                      n.y = map_detailed(p);    
                      n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;
                      n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;
                      n.y = eps;
                      return normalize(n);
                  }

                  float heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  
                      float tm = 0.0;
                      float tx = 1000.0;    
                      float hx = map(ori + dir * tx);
                      if(hx > 0.0) return tx;   
                      float hm = map(ori + dir * tm);    
                      float tmid = 0.0;
                      for(int i = 0; i < NUM_STEPS; i++) {
                          tmid = mix(tm,tx, hm/(hm-hx));                   
                          p = ori + dir * tmid;                   
                        float hmid = map(p);
                      if(hmid < 0.0) {
                            tx = tmid;
                              hx = hmid;
                          } else {
                              tm = tmid;
                              hm = hmid;
                          }
                      }
                      return tmid;
                  }

                  // main
                  void main( void ) {
                    EPSILON_NRM = 0.1 / resolution.x;
                    SEA_TIME = time * SEA_SPEED;
                    
                    vec2 uv = gl_FragCoord.xy / resolution.xy;
                      uv = uv * 2.0 - 1.0;
                      uv.x *= resolution.x / resolution.y;    
                      float time = time * 0.3 + mouse.x*0.01;
                    
                    mouse = vec2(time * 0.1, 0);
                          
                      // ray
                      vec3 ang = vec3(3);    
                      vec3 ori = vec3(mouse.x*100.0,3.5,5.0);
                      vec3 dir = normalize(vec3(uv.xy,-2.0));
                    dir.z += length(uv) * 0.15;
                      dir = normalize(dir) * fromEuler(ang);
                      
                      // tracing
                      vec3 p;
                      heightMapTracing(ori,dir,p);
                      vec3 dist = p - ori;
                      vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);
                      vec3 light = normalize(vec3(0.0,1.0,0.8)); 
                               
                      // color
                      vec3 color = mix(
                          getSkyColor(dir),
                          getSeaColor(p,n,light,dir,dist),
                        pow(smoothstep(0.0,-0.05,dir.y),0.3));
                          
                      // post
                    gl_FragColor = vec4(pow(color,vec3(0.75)), 1.0);
                  }

    </script>

    <script id="vertigo" type="x-shader/x-fragment">
                  // 眩晕
                    #ifdef GL_ES
                    precision mediump float;
                    #endif
                    //nuclear throne tunnel
                    //2017.01.29 tigrou dot ind at gmail dot com
                    #extension GL_OES_standard_derivatives : enable

                    uniform float time;
                    uniform vec2 mouse;
                    uniform vec2 resolution;

                    vec4 pattern(vec2 pos, float ang) 
                    {
                            pos = vec2(pos.x * cos(ang) - pos.y * sin(ang), pos.y * cos(ang) + pos.x * sin(ang)); 
                      
                      //if(length(pos) < 0.2)
                      if(abs(pos.x) < 0.2 && abs(pos.y) < 0.2)
                         return vec4(0.0, 0.0, 0.0, 0.0);
                      else if((abs(pos.x) - abs(pos.y)) > 0.0)
                         return vec4(0.59, 0.45, 0.05, 1.0);
                      else
                         return vec4(0.27, 0.07, 0.39, 1.0);      
                    }

                    void main( void ) 
                    {
                      vec2 pos = ( gl_FragCoord.xy / resolution.xy ) - vec2(0.5, 0.5);
                      vec4 color = vec4(0.0);
                      
                      for(float i = 0.01 ; i < 1.0 ; i += 0.005)
                      {
                        float o = 1.0 - i;
                        vec2 offset = vec2(o*cos(o*2.0+time)*0.5, o*sin(o*2.0+time)*0.5);
                        vec4 res = pattern(pos/vec2(i*i*2.7)+offset, i*10.0+time);
                        if(res.a > 0.5)
                             color = res*i*2.7;
                      }

                      gl_FragColor = color;
                    }
                    </script>

    <script id="bunge bedstraw herb" type="x-shader/x-fragment">     
    
                  //四叶草
                    #ifdef GL_ES
                    precision mediump float;
                    #endif

                    #extension GL_OES_standard_derivatives : enable

                    uniform float time;
                    uniform vec2 mouse;
                    uniform vec2 resolution;

                    float leafs = 4.0;
                    //from tutorial created by iq
                    vec3 computeColor(vec2 p) {
                        float ratio = resolution.x / resolution.y;
                        p.y = p.y / ratio;
                        p /= 0.4;
                        p -= vec2(0.5*ratio, 1.1 / ratio);
                        float r = sqrt(dot(p, p));
                        float a = atan(p.y, p.x) + time * 0.2;
                        float s = 0.5 + 0.5 * sin(leafs * a);
                        float t = 0.15 + 0.35*pow(s, 0.3);
                        t += 0.1 * pow(0.5 + 0.5 * cos(leafs * 2.0 * a), 0.5);
                        float h = r / t;
                        float f = 0.0;
                        if (h < 1.0) {
                            f = 1.0;
                        } else {
                            f = 0.3;
                            h = 2.0;
                        }
                        
                        return mix(vec3(1.0), vec3(0.5 * h, 0.5 + 0.5 * h, 0.0), f);
                    }

                    void main( void )
                    {
                        vec2 uv = vec2(gl_FragCoord.x / resolution.x, gl_FragCoord.y  / resolution.y);
                        vec3 res = computeColor(uv);
                        gl_FragColor = vec4(res.rgb,2.0);
                    }



</script>
<script id="balls" type="x-shader/x-fragment">
// created by Eric 
// stolen straight from https://www.shadertoy.com/view/lsX3DH
#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

#define MOTIONBLUR
#define DEPTHOFFIELD

#define CUBEMAPSIZE 256

#define SAMPLES 8
#define PATHDEPTH 4
#define TARGETFPS 60.

#define FOCUSDISTANCE 17.
#define FOCUSBLUR 0.25

#define RAYCASTSTEPS 20
#define RAYCASTSTEPSRECURSIVE 2

#define EPSILON 0.001
#define MAXDISTANCE 180.
#define GRIDSIZE 8.
#define GRIDSIZESMALL 5.9
#define MAXHEIGHT 10.
#define SPEED 0.5


float ttime;

//
// math functions
//

float hash( const float n ) {
  return fract(sin(n)*43758.54554213);
}
vec2 hash2( const float n ) {
  return fract(sin(vec2(n,n+1.))*vec2(43758.5453123));
}
vec2 hash2( const vec2 n ) {
  return fract(sin(vec2( n.x*n.y, n.x+n.y))*vec2(25.1459123,312.3490423));
}
vec3 hash3( const vec2 n ) {
  return fract(sin(vec3(n.x, n.y, n+2.0))*vec3(36.5453123,43.1459123,11234.3490423));
}
//
// intersection functions
//

float intersectPlane( const vec3 ro, const vec3 rd, const float height) { 
  if (rd.y==0.0) return 500.; 
  float d = -(ro.y - height)/rd.y;
  if( d > 0. ) {
    return d;
  }
  return 500.;
}

float intersectUnitSphere ( const vec3 ro, const vec3 rd, const vec3 sph ) {
  vec3  ds = ro - sph;
  float bs = dot( rd, ds );
  float cs = dot( ds, ds ) - 1.0;
  float ts = bs*bs - cs;

  if( ts > 0.0 ) {
    ts = -bs - sqrt( ts );
    if( ts > 0. ) {
      return ts;
    }
  }
  return 500.;
}

//
// Scene
//

void getSphereOffset( const vec2 grid, out vec2 center ) {
  center = (hash2( grid+vec2(43.12,1.23) ) - vec2(0.5) )*(GRIDSIZESMALL);
}
void getMovingSpherePosition( const vec2 grid, const vec2 sphereOffset, out vec3 center ) {
  // falling?
  float s = 0.1+hash( grid.x*1.23114+5.342+74.324231*grid.y );
  float t = 14.*s + time/s;
  
  float y =  s * MAXHEIGHT * abs( cos( t ) );
  vec2 offset = grid + sphereOffset;
  
  center = vec3( offset.x, y, offset.y ) + 0.5*vec3( GRIDSIZE, 2., GRIDSIZE );
}
void getSpherePosition( const vec2 grid, const vec2 sphereOffset, out vec3 center ) {
  vec2 offset = grid + sphereOffset;
  center = vec3( offset.x, 0., offset.y ) + 0.5*vec3( GRIDSIZE, 2., GRIDSIZE );
}
vec3 getSphereColor( const vec2 grid ) {
  return 0.8*normalize( hash3( grid+vec2(43.12*grid.y,12.23*grid.x) ) );
}

vec3 sundir = normalize( vec3(-1.0,0.8,0.2) );

vec3 getBackgroundColor( const vec3 ro, const vec3 rd ) { 
  return vec3( 0.8, 0.9, 1.0 ) * (1.8 * (rd.y+0.5) );
}

// code duplication because the for-loop requires a const
vec3 traceRec( const vec3 ro, const vec3 rd, out vec3 intersection, out vec3 normal, out float dist, out int material) {
  dist = MAXDISTANCE;
  float distcheck;
  
  vec3 sphereCenter, col;

  material = 0; 
  col = getBackgroundColor(ro, rd);
  
  if( (distcheck = intersectPlane( ro,  rd, 0.)) < MAXDISTANCE ) {
    dist = distcheck;
    material = 1;
    normal = vec3( 0., 1., 0. );
    col = vec3( 0.5 );
  }
  
  // trace grid
  vec3 pos = floor(ro/GRIDSIZE)*GRIDSIZE;
  vec3 ri = 1.0/rd;
  vec3 rs = sign(rd) * GRIDSIZE;
  vec3 dis = (pos-ro + 0.5  * GRIDSIZE + rs*0.5) * ri;
  vec3 mm = vec3(0.0);
  vec2 offset;
  
  for( int i=0; i<RAYCASTSTEPSRECURSIVE; i++ ) {
    if( material != 2 ) {   
      getSphereOffset( pos.xz, offset );      
      
      getMovingSpherePosition( pos.xz, -offset, sphereCenter );     
      if( (distcheck = intersectUnitSphere( ro, rd, sphereCenter )) < dist ) {
        dist = distcheck;
        normal = normalize((ro+rd*dist)-sphereCenter);
        col = getSphereColor(pos.xz);
        material = 2;
      }
      
      getSpherePosition( pos.xz, offset, sphereCenter );
      if( (distcheck = intersectUnitSphere( ro, rd, sphereCenter )) < dist ) {
        dist = distcheck;
        normal = normalize((ro+rd*dist)-sphereCenter);
        col = getSphereColor(pos.xz+vec2(1.,2.));
        material = 2;
      }
      
      mm = step(dis.xyz, dis.zyx);
      dis += mm * rs * ri;
      pos += mm * rs; 
    }
  }
  
  intersection = ro+rd*dist;
  
  return col;
}


vec3 trace(const vec3 ro, const vec3 rd, out vec3 intersection, out vec3 normal, out float dist, out int material) {
  dist = MAXDISTANCE;
  float distcheck;
  
  vec3 sphereCenter, col, normalcheck;
  
  material = 0;
  col = getBackgroundColor(ro, rd);
  
  if( (distcheck = intersectPlane( ro,  rd, 0.)) < MAXDISTANCE ) {
    dist = distcheck;
    material = 1;
    normal = vec3( 0., 1., 0. );
    col = vec3( 0.5 );
  } 
  
  // trace grid
  vec3 pos = floor(ro/GRIDSIZE)*GRIDSIZE;
  vec3 ri = 1.0/rd;
  vec3 rs = sign(rd) * GRIDSIZE;
  vec3 dis = (pos-ro + 0.5  * GRIDSIZE + rs*0.5) * ri;
  vec3 mm = vec3(0.0);
  vec2 offset;
    
  for( int i=0; i<RAYCASTSTEPS; i++ ) {
    if( material != 2 &&  distance( ro.xz, pos.xz ) < dist+GRIDSIZE ) {
      getSphereOffset( pos.xz, offset );
      
      getMovingSpherePosition( pos.xz, -offset, sphereCenter );     
      if( (distcheck = intersectUnitSphere( ro, rd, sphereCenter )) < dist ) {
        dist = distcheck;
        normal = normalize((ro+rd*dist)-sphereCenter);
        col = getSphereColor(pos.xz);
        material = 2;
      }
      
      getSpherePosition( pos.xz, offset, sphereCenter );
      if( (distcheck = intersectUnitSphere( ro, rd, sphereCenter )) < dist ) {
        dist = distcheck;
        normal = normalize((ro+rd*dist)-sphereCenter);
        col = getSphereColor(pos.xz+vec2(1.,2.));
        material = 2;
      }   
      mm = step(dis.xyz, dis.zyx);
      dis += mm * rs * ri;
      pos += mm * rs;   
    }
  }
  
  intersection = ro+rd*dist;
  
  return col;
}

vec2 rv2;

vec3 cosWeightedRandomHemisphereDirection2( const vec3 n ) {
  vec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );
  vec3  vv = normalize( cross( uu, n ) );
  
  float ra = sqrt(rv2.y);
  float rx = ra*cos(6.2831*rv2.x); 
  float ry = ra*sin(6.2831*rv2.x);
  float rz = sqrt( 1.0-rv2.y );
  vec3  rr = vec3( rx*uu + ry*vv + rz*n );

    return normalize( rr );
}


void main(void) {
  //vec2 q = gl_FragCoord.xy/iResolution.xy;
  vec2 q = ( gl_FragCoord.xy / resolution.xy );
  vec2 p = -1.0+2.0*q;
  p.x *= resolution.x/resolution.y;
  
  vec3 col = vec3( 0. );
  
  // raytrace
  int material;
  vec3 normal, intersection;
  float dist;
  float seed = time+(p.x+resolution.x*p.y)*1.51269341231;
  
  for( int j=0; j<SAMPLES; j++ ) {
    float fj = float(j);
    
#ifdef MOTIONBLUR
    ttime = time + fj/(float(SAMPLES)*TARGETFPS);
#endif
    
    rv2 = hash2( 24.4316544311*fj+ttime+seed );
    
    vec2 pt = p+rv2/(0.5*resolution.xy);
        
    // camera 
    vec3 ro = vec3( cos( 0.232*time) * 10., 6.+3.*cos(0.3*time), GRIDSIZE*(time/SPEED) );
    vec3 ta = ro + vec3( -sin( 0.232*ttime) * 10., -2.0+cos(0.23*ttime), 10.0 );
    
    float roll = -0.15*sin(0.5*time);
    
    // camera tx
    vec3 cw = normalize( ta-ro );
    vec3 cp = vec3( sin(roll), cos(roll),0.0 );
    vec3 cu = normalize( cross(cw,cp) );
    vec3 cv = normalize( cross(cu,cw) );
  
#ifdef DEPTHOFFIELD
    // create ray with depth of field
    const float fov = 3.0;
    
        vec3 er = normalize( vec3( pt.xy, fov ) );
        vec3 rd = er.x*cu + er.y*cv + er.z*cw;

        vec3 go = FOCUSBLUR*vec3( (rv2-vec2(0.5))*2., 0.0 );
        vec3 gd = normalize( er*FOCUSDISTANCE - go );
    
        ro += go.x*cu + go.y*cv;
        rd += gd.x*cu + gd.y*cv;
    rd = normalize(rd);
#else
    vec3 rd = normalize( pt.x*cu + pt.y*cv + 1.5*cw );    
#endif      
    vec3 colsample = vec3( 1. );
    
    // first hit
    rv2 = hash2( (rv2.x*2.4543263+rv2.y)*(time+1.) );
    colsample *= trace(ro, rd, intersection, normal, dist, material);

    // bounces
    for( int i=0; i<(PATHDEPTH-1); i++ ) {
      if( material != 0 ) {
        rd = cosWeightedRandomHemisphereDirection2( normal );
        ro = intersection + EPSILON*rd;
            
        rv2 = hash2( (rv2.x*2.4543263+rv2.y)*(time+1.)+(float(i+1)*.23) );
            
        colsample *= traceRec(ro, rd, intersection, normal, dist, material);
      }
    } 
    if( material == 0 ) {     
      col += colsample; 
    }
  }
  col  /= float(SAMPLES);
  
  col = pow( col, vec3(0.7) );  
  col = clamp(col, 0.0, 1.0);
  // contrast 
 //   col = clamp( col*0.7 + 0.3*col*col*(3.0-2.0*col), 0., 1.); 
     
  // vigneting
  col *= 0.25+0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );
  
  gl_FragColor = vec4( col,1.0);
}
</script>
<script id="paint" type="x-shader/x-fragment">
#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 resolution;
uniform float time;
uniform vec2 mouse;

const int   complexity      = 48;    // More points of color.
const float mouse_factor    = 32.0;  // Makes it more/less jumpy.
const float mouse_offset    = 15.0;   // Drives complexity in the amount of curls/cuves.  Zero is a single whirlpool.
const float fluid_speed     = 64.0;  // Drives speed, higher number will make it slower.
const float color_intensity = 0.45;

const float Pi = 3.14159;

void main()
{
  vec2 p=(2.0*gl_FragCoord.xy-resolution)/max(resolution.x,resolution.y);
  for(int i=1;i<complexity;i++)
  {
    vec2 newp=p;
    newp.x+=0.6/float(i)*sin(float(i)*p.y+time/fluid_speed+0.3*float(i))+mouse.y/mouse_factor+mouse_offset;
    newp.y+=0.6/float(i)*sin(float(i)*p.x+time/fluid_speed+0.3*float(i+10))-mouse.x/mouse_factor+mouse_offset;
    p=newp;
  }
  vec3 col=vec3(color_intensity*sin(3.0*p.x)+color_intensity,color_intensity*sin(3.0*p.y)+color_intensity,color_intensity*sin(p.x+p.y)+color_intensity);
  gl_FragColor=vec4(col, 1.0);
}
</script>
<script id="building" type="x-shader/x-fragment">
//building off paulo falcao's raymarch framework -alice
//--added random building size -h3r3 ;)
#ifdef GL_ES
precision highp float;
#endif

uniform vec2 resolution;
uniform float time;
uniform vec2 mouse;
//Simple raymarching sandbox with camera

//Raymarching Distance Fields
//About http://www.iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm
//Also known as Sphere Tracing
//Original seen here: http://twitter.com/#!/paulofalcao/statuses/134807547860353024

//Declare functions
vec2 ObjUnion(in vec2 d1,in vec2 d2);
vec2 obj_floor(in vec3 p);
vec3 color_checkers(in vec3 p);
vec2 obj_roundBox(in vec3 p);
vec2 obj_sdBox( vec3 p, vec3 b );
vec3 color_white(in vec3 p);
vec2 distanceField(in vec3 p);
vec2 obj_infiniteBuildingsShort(in vec3 p);
vec2 obj_simpleBuilding (vec3 p, vec3 b );
vec4 applyFog (in vec4 currColor, in vec3 ray);
float maxcomp(in vec3 p );
vec2 obj_infiniteBuildingsTall(in vec3 p);
vec2 obj_infiniteBuildings(in vec3 p);
float sdCross( in vec3 p );


#define EPS 0.01
#define INF 100000.0

#define PHONG_SHADING 0
#define RAYMARCH_SHADING 1
#define TEST_SHADING 2

#define SPINNING_CAMERA 0
#define MOUSE_CAMERA 1
#define PAN_CAMERA 2
#define STILL_CAMERA 3
#define AUTOPAN_CAMERA 4

// mode selection
const int SHADING_MODE = PHONG_SHADING; 
const int CAMERA_MODE = MOUSE_CAMERA; 
vec3 E;

// some simple colors
const vec3 COLOR_GREY = vec3(0.5,0.5,0.5);
const vec3 COLOR_DARKGREY = vec3(0.74, 0.72, 0.71);
const vec3 COLOR_WHITE = vec3(1.0,1.0,1.0);

//============================== UTILS ====================================//
vec2 distanceField(in vec3 p){
  return ObjUnion(obj_floor(p),obj_infiniteBuildings(p)); // infinite boxes
  
  //vec2 test = ObjUnion(obj_infiniteBuildingsShort(p),obj_infiniteBuildingsTall(p)); //multiple mod patterns
  //return ObjUnion(obj_floor(p),test);
}

vec2 ObjUnion(in vec2 d1,in vec2 d2){
  if (d1.x<d2.x)
  return d1;
  else
  return d2;
}

// http://www.ozone3d.net/blogs/lab/20110427/glsl-random-generator/
float rand(vec2 n)
{
  return 0.5 + 0.5 *
  fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);
}

// from IQ
float maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}



// =============================== OBJECTS =======================================//
// CREDIT: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm //

//FLOOR (color is determined by y-component, ie 0.0)
vec2 obj_floor(in vec3 p){
  return vec2(p.y+2.0,0);
}

// ROUNDBOX (try other objects )
//(color is determined by y-component, ie 1.0)
vec2 obj_roundBox(in vec3 p){
  return vec2(length(max(abs(p)-vec3(1,1,1),0.0))-0.25,1);
}

// SIGNED BOX
vec2 obj_sdBox( vec3 p, vec3 b ){
  vec3  di = abs(p) - b;
  float mc = maxcomp(di);
  return vec2(min(mc,length(max(di,0.0))), 1);
}

// INFINITE BUILDINGS SHORT
vec2 obj_infiniteBuildingsShort(in vec3 p){
  vec3 c = vec3(10,10,10); // how close cubes are to each other
  vec3 f = vec3(7,10,7);
  
  vec3 q = p;
  //repetition in x and z direction
  q.x = mod(p.x,c.x)-0.5*c.x;
  q.x = mod(q.x,f.x)-0.5*f.x;
  
  q.z = mod(p.z,c.z)-0.5*c.z;
  q.z = mod(q.z,f.z)-0.5*f.z;
  
  //building height
  vec3 b = vec3(1.0, 3.0, 1.0);
  return obj_sdBox(q,b);  
}

// INFINITE BUILDINGS TALL
vec2 obj_infiniteBuildingsTall(in vec3 p){
  vec3 c = vec3(11,10,11); // how close cubes are to each other
  
  vec3 q = p;
  //repetition in x and z direction
  q.x = mod(p.x,c.x)-0.8*c.x; 
  q.z = mod(p.z,c.z)-0.5*c.z;
  
  //building height
  vec3 b = vec3(1.0, 8.0, 1.0);
  return obj_sdBox(q,b);
}

// INFINITE BUILDINGS RANDOM (CREDIT: H3R3)
vec2 obj_infiniteBuildings(in vec3 p){
  
  vec3 c = vec3(5,5,5); // how close cubes are to each other
  
  vec3 q = p;
  //repetition in x and z direction
  q.x = mod(p.x,c.x)-0.5*c.x;
  q.z = mod(p.z,c.z)-0.5*c.z;
  
  vec2 pos = vec2(ceil(p.x/c.x), ceil(p.z/c.z));
  
  float height = rand(pos)*5.0;//* 10.0 - 4.0;
  float width1 = rand(pos + 100.0) + 0.5;
  float width2 = rand(pos + 1500.0) + 0.5;
  
  //building height
  //vec3 k = vec3(1,height,1);
  vec3 k = vec3(max(0.0, width1), max(0.0, height), max(0.0, width2));
  return obj_simpleBuilding(q,k); 
}


// SIMPLE BUILDING (white)
vec2 obj_simpleBuilding (vec3 p, vec3 b ){
  float body = obj_sdBox(p,b).x;
  
  vec3 q = p;
  vec3 c = vec3(0.5); //0.5

  q = mod(p,c)-0.5*c;
  
  float cr = sdCross(q*3.0)/3.0;
  body = max( body, -cr );
  
  float top = obj_sdBox(p-vec3(0,b.y,0),vec3(1.0, b.y/25.0, 1.0)).x;
  float inside = obj_sdBox(p,vec3(b.x*0.9, b.y, b.z*0.9)).x;
  body = min(inside,min(body,top));
  
  return vec2(body,1);
}

// SD_CROSS (modified from IQ's original)
float sdCross( in vec3 p ){
  const float w = 0.4;
  float da = obj_sdBox(p.xyz,vec3(INF,w,w)).x;
  float db = obj_sdBox(p.yzx,vec3(w,INF,w)).x;
  float dc = obj_sdBox(p.zxy,vec3(w,w,INF)).x;
  return min(da,db);
}


// ============COLORS============= //
// Checkerboard Color
vec3 color_checkers(in vec3 p){
  if (fract(p.x*.5)>.5)
  if (fract(p.z*.5)>.5)
  return COLOR_GREY;
  else
  return vec3(1,1,1);
  else
  if (fract(p.z*.5)>.5)
  return vec3(1,1,1);
  else
  return COLOR_GREY;
}

// ==================== RAY MARCH =============================//
void main(void){
  //Camera animation
  vec3 U=vec3(0,1,0);//Camera Up Vector
  vec3 viewDest=vec3(0,0,0); //Change camere view vector here
  //vec3 E; //moved to global space
  if (CAMERA_MODE == SPINNING_CAMERA)
  E=vec3(-sin(time/10.0)*10.0,5,cos(time/10.0)*10.0); //spinning scene
  else if(CAMERA_MODE == MOUSE_CAMERA){
    float spin = mouse.x * 8.0; //time * 0.1 + mouse.x * 8.0;
    E=vec3(-sin(spin)*10.0, 10.0 * mouse.y, cos(spin)*10.0);//Change camera path position here
  }
  else if(CAMERA_MODE == PAN_CAMERA){
    E=vec3(-sin(1.0)*10.0,7,cos(1.0)*10.0);
    vec3 moveCamDir = normalize(vec3(E.x,0.0,E.y));
    float mouse_val = mouse.y-0.5;
    E+=moveCamDir*time*(mouse_val>0.0?mouse_val:0.0);
  }
  else if(CAMERA_MODE == STILL_CAMERA){
    E=vec3(-sin(1.0)*10.0,7,cos(1.0)*10.0);//Change camera path position here
  }
  else if (CAMERA_MODE == AUTOPAN_CAMERA){
    E=vec3(-sin(1.0)*10.0,7,cos(1.0)*10.0);
    vec3 moveCamDir = normalize(vec3(E.x,0.0,E.y));
    E+=moveCamDir*time;
  }
  
  
  //Camera setup
  vec3 C=normalize(viewDest-E);
  vec3 A=cross(C, U);
  vec3 B=cross(A, C);
  vec3 M=(E+C);

  vec2 vPos=2.0*gl_FragCoord.xy/resolution.xy - 1.0; // = (2*Sx-1) where Sx = x in screen space (between 0 and 1)
  vec3 P=M + vPos.x*A*resolution.x/resolution.y + vPos.y*B; //normalize resolution in either x or y direction (ie resolution.x/resolution.y)
  vec3 rayDir=normalize(P-E); //normalized direction vector from Eye to point on screen
  
  //Colors
  const vec4 skyColor = vec4(0.7, 0.8, 1.0, 1.0);
  const vec4 sunColor = vec4 (1.0, 0.9, 0.7, 1.0);
  
  //Raymarching
  const vec3 e=vec3(0.1,0,0);
  const float MAX_DEPTH=170.0; //Max depth use 500
  const int MAX_STEPS = 100; // max number of steps use 150
  const float MIN_DIST = 0.01;

  vec2 dist=vec2(0.0,0.0);
  float totalDist=0.0;
  vec3 c,p,n; //c=color (used in PHONG and RAYMARCH modes), p=ray position, n=normal at any point on the surface

  int steps = 0;
  for(int i=0;i<MAX_STEPS;i++){
    steps++;
    totalDist+=dist.x;
    p=E+rayDir*totalDist; // p = eye + total_t*rayDir
    dist=distanceField(p);
    if (abs(dist.x)<MIN_DIST) break; // break when p gets sufficiently close to object or exceeds max dist
  }

  vec4 finalColor = skyColor;
  
  if (totalDist<MAX_DEPTH){
    // check which color to use via the y-component
    if (dist.y==0.0) // floor color
    c=color_checkers(p);
    else if(dist.y==1.0) // building color
    c=COLOR_WHITE;
    
    if(SHADING_MODE==PHONG_SHADING){
      // compute normal at this point on the surface using a gradient vector
      n=normalize(
      vec3(
      dist.x-distanceField(p-e.xyy).x,
      dist.x-distanceField(p-e.yxy).x,
      dist.x-distanceField(p-e.yyx).x));
      
      //e.xyy is equal to (0.001,0.0,0.0) 
      //e.yxy is equal to (0.0,0.001,0.0)
      //e.xxy is equal to (0.0,0.0,0.001)

      //simple phong LightPosition=CameraPosition    
      float b=dot(n,normalize(E-p));
      finalColor=vec4((b*c+pow(b,8.0))*(1.0-totalDist*.01),1.0);
    }
    else if (SHADING_MODE==RAYMARCH_SHADING){
      //Shading based on raymarched distance
      float v = 1.0-float(steps)/float(MAX_STEPS);
      float R=v*c.r, G=v*c.g, B=v*c.b;
      finalColor=vec4(R,G,B,1.0);
    }
    else if (SHADING_MODE==TEST_SHADING){
      vec3 sunDir = vec3(normalize(viewDest-E)); //sun comes from the camera
      
      vec3 N = normalize(vec3(
      distanceField(p).x-distanceField(p-e.xyy).x,
      distanceField(p).x-distanceField(p-e.yxy).x,
      distanceField(p).x-distanceField(p-e.yyx).x)); //normal at point
      
      vec3 L = sunDir;
      vec3 V = normalize(E-p);
      
      // color info is stored in y component
      if (dist.y==0.0) // floor color
        finalColor=vec4(color_checkers(p),1.0);
      if(dist.y==1.0) // building color
        finalColor=vec4(COLOR_GREY,1.0);
      
      //calculate lighting: diffuse + sunlight
      float diffuseTerm = clamp(dot(V,N), 0.0, 1.0);
      finalColor = mix(finalColor, sunColor, diffuseTerm);      
      
    }
  }
  //apply fog
  vec3 r = p-E;
  finalColor = applyFog(finalColor, r);
  gl_FragColor = finalColor;
}


// Fog (credit: http://www.mazapan.se/news/2010/07/15/gpu-ray-marching-with-distance-fields/)
vec4 applyFog (in vec4 currColor, in vec3 ray){
  float rayLength = length(ray);
  vec3 nRay = ray/rayLength;
  
  float fogAmount = 1.0-exp(-rayLength * 0.02); //0.008
  float sunAmount = 0.0;//pow( max( dot (nRay, sunDir), 0.0), 8.0);
  
  vec4 fogColor = mix(vec4(0.5,0.6,0.7,1.0), vec4(1.0,0.9,0.7,1.0), sunAmount);
  return mix(currColor, fogColor, fogAmount);
}

    </script>
<script id="sunset" type="x-shader/x-fragment">
precision highp float;

const bool USE_MOUSE = true; // Set this to true for God Mode :)

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;
const float PI = 3.14159265;
const float MAX_RAYMARCH_DIST = 150.0;
const float MIN_RAYMARCH_DELTA = 0.00015; 
const float GRADIENT_DELTA = 0.015;
float waveHeight1 = 0.005;
float waveHeight2 = 0.004;
float waveHeight3 = 0.001;

// --------------------- START of SIMPLEX NOISE
//
// Description : Array and textureless GLSL 2D simplex noise function.
//      Author : Ian McEwan, Ashima Arts.
//  Maintainer : ijm
//     Lastmod : 20110822 (ijm)
//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
//               Distributed under the MIT License. See LICENSE file.
//               https://github.com/ashima/webgl-noise
// 

vec3 mod289(vec3 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec2 mod289(vec2 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec3 permute(vec3 x) {
  return mod289(((x*34.0)+1.0)*x);
}

float snoise(vec2 v)
  {
  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                     -0.577350269189626,  // -1.0 + 2.0 * C.x
                      0.024390243902439); // 1.0 / 41.0
// First corner
  vec2 i  = floor(v + dot(v, C.yy) );
  vec2 x0 = v -   i + dot(i, C.xx);

// Other corners
  vec2 i1;
  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0
  //i1.y = 1.0 - i1.x;
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  // x0 = x0 - 0.0 + 0.0 * C.xx ;
  // x1 = x0 - i1 + 1.0 * C.xx ;
  // x2 = x0 - 1.0 + 2.0 * C.xx ;
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;

// Permutations
  i = mod289(i); // Avoid truncation effects in permutation
  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
    + i.x + vec3(0.0, i1.x, 1.0 ));

  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
  m = m*m ;
  m = m*m ;

// Gradients: 41 points uniformly over a line, mapped onto a diamond.
// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)

  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;

// Normalise gradients implicitly by scaling m
// Approximation of: m *= inversesqrt( a0*a0 + h*h );
  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );

// Compute final noise value at P
  vec3 g;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}

// --------------------- END of SIMPLEX NOISE


float map(vec3 p) {
  return p.y + (0.5 + waveHeight1 + waveHeight2 + waveHeight3) 
    + snoise(vec2(p.x + time * 0.4, p.z + time * 0.6)) * waveHeight1
    + snoise(vec2(p.x * 1.6 - time * 0.4, p.z * 1.7 - time * 0.6)) * waveHeight2
      + snoise(vec2(p.x * 6.6 - time * 1.0, p.z * 2.7 + time * 1.176)) * waveHeight3;
}

vec3 gradientNormalFast(vec3 p, float map_p) {
    return normalize(vec3(
        map_p - map(p - vec3(GRADIENT_DELTA, 0, 0)),
        map_p - map(p - vec3(0, GRADIENT_DELTA, 0)),
        map_p - map(p - vec3(0, 0, GRADIENT_DELTA))));
}

float intersect(vec3 p, vec3 ray_dir, out float map_p, out int iterations) {
  iterations = 0;
  if (ray_dir.y >= 0.0) { return -1.0; } // to see the sea you have to look down
  
  float distMin = (- 0.5 - p.y) / ray_dir.y;
  float distMid = distMin;
  for (int i = 0; i < 50; i++) {
    //iterations++;
    distMid += max(0.05 + float(i) * 0.002, map_p);
    map_p = map(p + ray_dir * distMid);
    if (map_p > 0.0) { 
      distMin = distMid + map_p;
    } else { 
      float distMax = distMid + map_p;
      // interval found, now bisect inside it
      for (int i = 0; i < 10; i++) {
        //iterations++;
        distMid = distMin + (distMax - distMin) / 2.0;
        map_p = map(p + ray_dir * distMid);
        if (abs(map_p) < MIN_RAYMARCH_DELTA) return distMid;
        if (map_p > 0.0) {
          distMin = distMid + map_p;
        } else {
          distMax = distMid + map_p;
        }
      }
      return distMid;
    }
  }
  return distMin;
}

void main( void ) {
  float waveHeight = USE_MOUSE ? mouse.x * 5.0 : cos(time * 0.03) * 1.2 + 1.6;
  waveHeight1 *= waveHeight;
  waveHeight2 *= waveHeight;
  waveHeight3 *= waveHeight;
  
  vec2 position = vec2((gl_FragCoord.x - resolution.x / 2.0) / resolution.y, (gl_FragCoord.y - resolution.y / 2.0) / resolution.y);
  vec3 ray_start = vec3(0, 0.2, -2);
  vec3 ray_dir = normalize(vec3(position,0) - ray_start);
  ray_start.y = cos(time * 0.5) * 0.2 - 0.25 + sin(time * 2.0) * 0.05;
  
  const float dayspeed = 0.04;
  float subtime = max(-0.16, sin(time * dayspeed) * 0.2);
  float middayperc = USE_MOUSE ? mouse.y * 0.3 - 0.15 : max(0.0, sin(subtime));
  vec3 light1_pos = vec3(0.0, middayperc * 200.0, USE_MOUSE ? 200.0 : cos(subtime * dayspeed) * 200.0);
  float sunperc = pow(max(0.0, min(dot(ray_dir, normalize(light1_pos)), 1.0)), 190.0 + max(0.0,light1_pos.y * 4.3));
  vec3 suncolor = (1.0 - max(0.0, middayperc)) * vec3(1.5, 1.2, middayperc + 0.5) + max(0.0, middayperc) * vec3(1.0, 1.0, 1.0) * 4.0;
  vec3 skycolor = vec3(middayperc + 0.8, middayperc + 0.7, middayperc + 0.5);
  vec3 skycolor_now = suncolor * sunperc + (skycolor * (middayperc * 1.6 + 0.5)) * (1.0 - sunperc);
  vec4 color = vec4(0.0, 0.0, 0.0, 1.0);
  float map_p;
  int iterations;
  float dist = intersect(ray_start, ray_dir, map_p, iterations);
  if (dist > 0.0) {
    vec3 p = ray_start + ray_dir * dist;
    vec3 light1_dir = normalize(light1_pos - p);
          vec3 n = gradientNormalFast(p, map_p);
    vec3 ambient = skycolor_now * 0.1;
          vec3 diffuse1 = vec3(1.1, 1.1, 0.6) * max(0.0, dot(light1_dir, n)  * 2.8);
    vec3 r = reflect(light1_dir, n);
    vec3 specular1 = vec3(1.5, 1.2, 0.6) * (0.8 * pow(max(0.0, dot(r, ray_dir)), 200.0));     
    float fog = min(max(p.z * 0.07, 0.0), 1.0);
          color.rgb = (vec3(0.6,0.6,1.0) * diffuse1 + specular1 + ambient)  * (1.0 - fog) + skycolor_now * fog;
      } else {
          color.rgb = skycolor_now.rgb;
      }
  gl_FragColor = color;
}
    </script>
<script id="big white lines" type="x-shader/x-fragment">
                    #ifdef GL_ES
precision mediump float;
#endif

// quadratic bezier curve evaluation
// posted by Trisomie21

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

int solveCubic(in float a, in float b, in float c, out float r[3])
{
  float  p = b - a*a / 3.0;
  float  q = a * (2.0*a*a - 9.0*b) / 27.0 + c;
  float p3 = p*p*p;
  float  d = q*q + 4.0*p3 / 27.0;
  float offset = -a / 3.0;
  if(d >= 0.0) { // Single solution
    float z = sqrt(d);
    float u = (-q + z) / 2.0;
    float v = (-q - z) / 2.0;
    u = sign(u)*pow(abs(u), 1.0/3.0);
    v = sign(v)*pow(abs(v), 1.0/3.0);
    if(abs(p) < abs(q)*0.005) {
      if(q <0.0) v = p / (3.0 * -pow(-q, 1.0/3.0));
      else u = p / (3.0 * pow(q, 1.0/3.0)); 
    }     
    r[0] = offset + u + v;
    return 1;
  }
  float u = sqrt(-p / 3.0);
  float v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;
  float m = cos(v), n = sin(v)*1.732050808;
  r[0] = offset + u * (m + m);
  r[1] = offset - u * (n + m);
  r[2] = offset + u * (n - m);
  return 3;
}


float DistanceToQBSpline(in vec2 P0, in vec2 P1, in vec2 P2, in vec2 p)
{
  float dis = 1e20;
  
  vec2  sb = (P1 - P0) * 2.0;
  vec2  sc = P0 - P1 * 2.0 + P2;
  vec2  sd = P1 - P0;
  float sA = 1.0 / dot(sc, sc);
  float sB = 3.0 * dot(sd, sc);
  float sC = 2.0 * dot(sd, sd);
  
  vec2  D = P0 - p;

  float a = sA;
  float b = sB;
  float c = sC + dot(D, sc);
  float d = dot(D, sd);

      float res[3];
  int n = solveCubic(b*a, c*a, d*a, res);

  float t = clamp(res[0],0.0, 1.0);
  vec2 pos = P0 + (sb + sc*t)*t;
  dis = min(dis, length(pos - p));
  
      if(n>1) {
  t = clamp(res[1],0.0, 1.0);
  pos = P0 + (sb + sc*t)*t;
  dis = min(dis, length(pos - p));
      
  t = clamp(res[2],0.0, 1.0);
  pos = P0 + (sb + sc*t)*t;
  dis = min(dis, length(pos - p));      
      }

      return dis;
}

void main(void)
{
  vec2 position = gl_FragCoord.xy;
  const int pointCount = 4;
  vec2 p[2 * pointCount + 1];
  
  p[0] = vec2(resolution.x*0.5,resolution.y*.2);
  p[1] = mouse*resolution;
  p[2] = vec2(resolution.x*0.4,resolution.y*.8);
  p[4] = vec2(resolution.x*0.6,resolution.y*.8);
  p[6] = vec2(resolution.x*0.6,resolution.y*.6);
  p[8] = vec2(resolution.x*0.7,resolution.y*.2);
  
  float d = 9999.0;
  for (int i = 0; i < pointCount; ++i)
  {
    if (i > 0)
      p[2*i+1] = 2.0 * p[2*i] - p[2*i - 1];
    d = min(d, DistanceToQBSpline(p[2*i], p[2*i + 1], p[2*i + 2], position));
  }
  
  float lineThickness = 12.0;
  float lineSoftness = 1.0;
  float outline = 1.0;
  d = (d - (lineThickness-1.0)) / lineSoftness;
  if(outline>0.0) d = abs(d)-outline;
  
  // Curve Control point
  
  d = clamp(d, 0.0, 1.0);
  d = mix(0.8, 0.5, d);
  gl_FragColor = vec4(d,d,d, 1.0);
}
    </script>
<script id="big lines" type="x-shader/x-fragment">
    #ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

const float pi   = 3.1415926535897932384626433832795; //pi
const float cupi = 1.4645918875615232630201425272638; //curt of pi
const float twpi = 6.283185307179586476925286766559 ; //2 x pi 

const float rez = cupi*twpi;

vec3 rotate(vec3 v,vec2 r) 
{
  mat3 rxmat = mat3(1,   0    ,    0    ,
        0,cos(r.y),-sin(r.y),
        0,sin(r.y), cos(r.y));
  mat3 rymat = mat3(cos(r.x), 0,-sin(r.x),
           0    , 1,    0    ,
        sin(r.x), 0,cos(r.x));

  return v*rxmat*rymat;
}

float snoise(vec3 v);

void main()
{
  vec2 res = vec2(resolution.x/resolution.y,1.0);
  vec2 p = ( gl_FragCoord.xy / resolution.y ) -(res/2.0);
  vec2 m = (0.3)*pi*vec2(2.,1.);
  vec3 color = vec3(0.0);
  vec3 pos = normalize(rotate(vec3(p,0.9),vec2(m)));
  float dist = 0.000001;
  float shell = abs(snoise(pos*0.3+vec3(time/2.0,0,0)*0.3));
  dist = max(dist,shell*(1.3));
  color = mix(vec3(1,1,1),vec3(.1,0.5 + ( ( 0.5 + cos(time) * 0.5 ) / 2.0 )  ,0.95),1.-dist); 
  gl_FragColor = vec4(color.xyz, 1.0 );
}

//
// Description : Array and textureless GLSL 2D/3D/4D simplex 
//               noise functions.
//      Author : Ian McEwan, Ashima Arts.
//  Maintainer : ijm
//     Lastmod : 20110822 (ijm)
//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
//               Distributed under the MIT License. See LICENSE file.
//               https://github.com/ashima/webgl-noise
// 

vec3 mod289(vec3 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 mod289(vec4 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 permute(vec4 x) {
     return mod289(((x*34.0)+1.0)*x);
}

vec4 taylorInvSqrt(vec4 r)
{
  return 1.79284291400159 - 0.85373472095314 * r;
}

float snoise(vec3 v)
  { 
  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

// First corner
  vec3 i  = floor(v + dot(v, C.yyy) );
  vec3 x0 =   v - i + dot(i, C.xxx) ;

// Other corners
  vec3 g = step(x0.yzx, x0.xyz);
  vec3 l = 1.0 - g;
  vec3 i1 = min( g.xyz, l.zxy );
  vec3 i2 = max( g.xyz, l.zxy );

  //   x0 = x0 - 0.0 + 0.0 * C.xxx;
  //   x1 = x0 - i1  + 1.0 * C.xxx;
  //   x2 = x0 - i2  + 2.0 * C.xxx;
  //   x3 = x0 - 1.0 + 3.0 * C.xxx;
  vec3 x1 = x0 - i1 + C.xxx;
  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y

// Permutations
  i = mod289(i); 
  vec4 p = permute( permute( permute( 
             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
    
// Gradients: 7x7 points over a square, mapped onto an octahedron.
// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
  float n_ = 0.142857142857; // 1.0/7.0
  vec3  ns = n_ * D.wyz - D.xzx;

  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)

  vec4 x_ = floor(j * ns.z);
  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

  vec4 x = x_ *ns.x + ns.yyyy;
  vec4 y = y_ *ns.x + ns.yyyy;
  vec4 h = 1.0 - abs(x) - abs(y);

  vec4 b0 = vec4( x.xy, y.xy );
  vec4 b1 = vec4( x.zw, y.zw );

  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;
  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;
  vec4 s0 = floor(b0)*2.0 + 1.0;
  vec4 s1 = floor(b1)*2.0 + 1.0;
  vec4 sh = -step(h, vec4(0.0));

  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

  vec3 p0 = vec3(a0.xy,h.x);
  vec3 p1 = vec3(a0.zw,h.y);
  vec3 p2 = vec3(a1.xy,h.z);
  vec3 p3 = vec3(a1.zw,h.w);

//Normalise gradients
  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;

// Mix final noise value
  vec4 m = max(0.7 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
  m = m * m;
  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                                dot(p2,x2), dot(p3,x3) ) );
  }
</script>
    <script id="ripple" type="x-shader/x-fragment">
                  

                    //水波
                    precision mediump float;

                          uniform float     time;
                          uniform vec2      resolution;
                          uniform vec2      mouse;
                    varying vec2 surfacePosition;

                          #define MAX_ITER 5

                          void main( void )
                          {
                              vec2 v_texCoord = gl_FragCoord.xy / resolution;

                              vec2 p =  v_texCoord * 8.0 - vec2(20.0);
                      p = (surfacePosition - vec2(1.5))* 8.0;
                              vec2 i = p;
                              float c = 1.0;
                              float inten = .03;

                              for (int n = 0; n < MAX_ITER; n++)
                              {
                                  float t = time * (1.0 - (3.0 / float(n+1)));

                                  i = p + vec2(cos(t - i.x) + sin(t + i.y),
                                  sin(t - i.y) + cos(t + i.x));
                          
                                  c += 1.0/length(vec2(p.x / (sin(i.x+t)/inten),
                                  p.y / (cos(i.y+t)/inten)));
                              }

                              c /= float(MAX_ITER);
                              c = 1.5 - sqrt(c);

                              vec4 texColor = vec4(0.02, 0.15, 0.02, 1.);

                              texColor.rgb *= (1.0 / (1.0 - (c + 0.05)));

                              gl_FragColor = texColor;
                          }



</script>

    <script id="tree" type="x-shader/x-fragment">



                    //变化的树
                    #ifdef GL_ES
                    precision mediump float;
                    #endif

                    #extension GL_OES_standard_derivatives : enable

                    uniform float time;
                    uniform vec2 mouse;
                    uniform vec2 resolution;
                    varying vec2 surfacePosition;

                    void main( void ) {

                      gl_FragColor = vec4( 1.0 );
                      
                      vec2 Z = 10.*(surfacePosition-vec2(0.,.09));
                      float width = 1.5;
                      for(float i = 0.; i <= 1.; i += 1./64.){
                        //if(i > mouse.x) return;
                        if(-Z.y - abs(Z.x) > 0. && Z.y > -width) gl_FragColor *= vec4(i*3.,.4+i/1.,0,1);
                        float ph = -sign(Z.x)*3.14159/(4.+8.*(mouse.y-.5));
                        Z += vec2(-sign(Z.x)*width*1.0,0.);
                        Z *= mat2(cos(ph), sin(ph), -sin(ph), cos(ph));
                        width /= sqrt(2.+4.*(mouse.x-.5));
                      }
                    }


</script>

    <script id="pillar" type="x-shader/x-fragment">


                    //立体的柱子
                    #ifdef GL_ES
                    precision mediump float;
                    #endif

                    #extension GL_OES_standard_derivatives : enable

                    uniform float time;
                    uniform vec2 mouse;
                    uniform vec2 resolution;

                    float sdBox( vec3 p, vec3 b ) {
                      vec3 d = abs(p) - b;
                      return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
                    }

                    float sdCapsule(vec3 p, vec3 a, vec3 b, float r) {
                      vec3 pa = p - a;
                      vec3 ba = b - a;
                      float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
                      return length(pa - h * ba) - r;
                    }

                    float sdCappedCylinder( vec3 p, vec2 h ) {
                      vec2 d = abs(vec2(length(p.xz),p.y)) - h;
                      return min(max(d.x,d.y),0.0) + length(max(d,0.0));
                    }

                    vec3 tri(in vec3 x){return abs(fract(x)-.5);}
                    float surfFunc(in vec3 p){
                      return dot(tri(p*0.5 + tri(p*0.25).yzx), vec3(0.666));
                    }

                    float smin(float a, float b, float k) {
                      float h = clamp((b - a)/k *0.5 + 0.5, 0.0, 1.0);
                      return mix(b, a, h) - k * h * (1.0 - h);
                    }

                    float hash(vec2 p) {
                      return fract(sin(p.x * 15.57 + p.y * 37.89) * 43758.26);
                    }

                    float map(vec3 p) {

                      vec3 q = p;
                      q.x *= 1.0 + 0.5 * cos(q.y / 0.8 * 3.141592);
                      float d = sdCappedCylinder(q, vec2(0.4, 0.4));
                      d = max(d, -sdBox(q, vec3(5.0, 0.15, 0.15)));
                      d = min(d, sdBox(p - vec3(0.0, 0.0, -1.0), vec3(1.0, 1.0, 0.01)));
                      d = min(d, sdBox(p - vec3(0.0, -1.0, 0.0), vec3(1.0, 0.01, 1.0)));
                      d = min(d, sdBox(p - vec3(1.0, 0.0, 0.0), vec3(0.01, 1.0, 1.0)));
                      return d;
                    }

                    vec3 calcNormal(vec3 p) {
                      vec2 e = vec2(-1.0, 1.0) * 0.001;
                      return normalize(
                        e.xyy * map(p + e.xyy) +
                        e.yxy * map(p + e.yxy) +
                        e.yyx * map(p + e.yyx) +
                        e.xxx * map(p + e.xxx)
                      );
                    }

                    float calcAO(in vec3 ro, in vec3 rd) {
                      float t = 0.0;
                      float h = 0.0;
                      float occ = 0.0;
                      for(int i = 0; i < 5; i++) {
                        t = 0.01 + 0.12*float(i)/4.0;
                        h = map(ro + rd * t);
                        occ += (t-h)*(4.0-float(i));
                      }
                      return clamp(1.0 - 2.0*occ, 0.0, 1.0);
                    }

                    float softshadow(in vec3 ro, in vec3 rd, in float tmin, in float tmax) {
                      float t = tmin;
                      float h = 0.0;
                      float sh = 1.0;
                      for(int i = 0; i < 20; i++) {
                      if(t > tmax) continue;
                        h = map(ro + rd * t);
                        sh = min(sh, h/t*50.0);
                        t += h * 0.5;
                      }
                      return clamp(sh, 0.0, 1.0);
                    }

                    float trace(in vec3 ro, in vec3 rd){
                      float FAR = 50.0;
                      float t = 0.0, h;
                      for(int i = 0; i < 72; i++){
                      h = map(ro+rd*t);
                      if(abs(h)<0.002*(t*.125 + 1.) || t>FAR) break;       
                        t += step(h, 1.)*h*.2 + h*.35;
                      }
                      
                      return min(t, FAR);
                    }

                    void main() {
                      vec2 uv = (gl_FragCoord.xy - 0.5*resolution.xy) / resolution.y;
                      
                      vec3 ro = vec3(-6.0, 3.0, 6.0) + vec3(mouse.x * 2.0 - 1.0, 0.0, 0.0) * 3.0;
                      vec3 ta = vec3(0.0, 0.0, 0.0);
                      
                      vec3 cw = normalize(ta - ro);
                      vec3 cup = vec3(0.0, 1.0, 0.0);
                      vec3 cu = normalize(cross(cw, cup));
                      vec3 cv = normalize(cross(cu, cw));
                      
                      float pi = 3.141592;
                      float fovy = pi / 4.0;
                      float f = tan(fovy * 0.5);
                      vec3 rd = normalize(cu * uv.x + cv * uv.y + (1.0/f) * cw);
                      
                        //-----

                      float e = 0.001;
                      float h = 2.0 * e;
                      float t = trace(ro, rd);
                      
                      float ff = clamp((t - 1.0) / 30.0, 0.0, 1.0);
                      ff = exp(-3. * ff);
                      vec3 sky = vec3(0., .9, 2.8);
                      vec3 col = sky;
                      
                      vec3 lig_pos0 = vec3(0.0, 1.0, 0.0) * 10.0;
                      vec3 lig_pos1 = vec3(-1.0, 0.0, 0.0) * 10.0;
                      vec3 lig_pos2 = vec3(0.0, 0.0, 1.0) * 10.0;
                      
                      float dur = 10.0;
                      float tt = mod(time, dur) / dur;
                      
                      vec3 lig_pos = mix(lig_pos0, lig_pos1, smoothstep(0.0, 0.333, tt));
                      lig_pos = mix(lig_pos, lig_pos2, smoothstep(0.333, 0.666, tt));
                      lig_pos = mix(lig_pos, lig_pos0, smoothstep(0.666, 1.0, tt));
                      if(t < 50.0) {
                        vec3 pos = ro + rd * t;
                        vec3 nor = calcNormal(pos);
                        vec3 lig = normalize(lig_pos);
                        float dif = clamp(dot(nor, lig), 0.0, 1.0);
                        vec3 ref = reflect(rd, nor);
                        float spe = pow(clamp(dot(ref, lig), 0.0, 1.0), 64.0);
                        float sh = softshadow(pos, lig, 0.01, 10.0);
                        float fre = 1.0 - dot(nor, -rd);
                        
                        col = vec3(1.0) * (dif + spe + fre * 0.5) * sh;
                        col = mix(sky, col, ff);
                      }
                      
                      gl_FragColor = vec4(col, 1.0);
                    }


</script>

    <script id="cement flower" type="x-shader/x-fragment">



                    //水泥花朵
                    #ifdef GL_ES
                    precision mediump float;
                    #endif

                    #extension GL_OES_standard_derivatives : enable

                    uniform float time;
                    uniform vec2 mouse;
                    uniform vec2 resolution;


                    //----------------------------------------------------------------------
                    // FlowerTest.glsl
                    // original:   https://www.shadertoy.com/view/MltSRf
                    // RayMarcher Created by inigo quilez - iq/2013
                    // License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
                    //----------------------------------------------------------------------

                    float ballFlower (vec3 p)
                    { 
                      const float radius = 1.0;
                      float q = length(p);
                      p.y -= 0.4;
                    //  p.xz *= 5.4;
                      vec3 n = p; // normalize(p);
                      float rho   = atan(length(vec2(n.x,n.z)),n.y)*20.0 + q*15.0;
                      float theta = atan(n.x,n.z)*9.0 + p.y*5.0+rho;
                      float a = 0.1*(1.2-abs(dot(n,vec3(0,1,0)) ));
                      return q -radius + a*cos(theta) + a*sin(rho - time);
                    }
                    //----------------------------------------------------------------------

                    vec2 map( in vec3 pos )
                    {    
                        return vec2( ballFlower(pos),11) ;
                    }

                    vec2 castRay( in vec3 ro, in vec3 rd )
                    {
                        float tmin = 1.0;
                        float tmax = 20.0;
                        
                    #if 0
                        float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );
                        float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );
                                                                     else           tmax = min( tmax, tp2 ); }
                    #endif
                        
                        float precis = 0.002;
                        float t = tmin*0.1;
                        float m = -1.0;
                        for( int i=0; i<215; i++ )
                        {
                            vec2 res = map( ro+rd*t );
                            if( res.x<precis || t>tmax ) break;
                            t += res.x*0.3;
                            m = res.y;
                        }
                        if( t>tmax ) m=-1.0;
                        return vec2( t, m );
                    }

                    float softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
                    {
                        float res = 1.0;
                        float t = mint;
                        for( int i=0; i<16; i++ )
                        {
                            float h = map( ro + rd*t ).x;
                            res = min( res, 8.0*h/t );
                            t += clamp( h, 0.02, 0.10 );
                            if( h<0.001 || t>tmax ) break;
                        }
                        return clamp( res, 0.0, 1.0 );
                    }

                    vec3 calcNormal( in vec3 pos )
                    {
                        vec3 eps = vec3( 0.001, 0.0, 0.0 );
                        vec3 nor = vec3( map(pos+eps.xyy).x - map(pos-eps.xyy).x,
                                         map(pos+eps.yxy).x - map(pos-eps.yxy).x,
                                         map(pos+eps.yyx).x - map(pos-eps.yyx).x );
                        return normalize(nor);
                    }

                    float calcAO( in vec3 pos, in vec3 nor )
                    {
                        float occ = 0.0;
                        float sca = 1.0;
                        for( int i=0; i<5; i++ )
                        {
                            float hr = 0.01 + 0.12*float(i)/4.0;
                            vec3 aopos =  nor * hr + pos;
                            float dd = map( aopos ).x;
                            occ += -(dd-hr)*sca;
                            sca *= 0.95;
                        }
                        return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    
                    }

                    vec3 render( in vec3 ro, in vec3 rd )
                    { 
                        vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;
                        vec2 res = castRay(ro,rd);
                        float t = res.x;
                      float m = res.y;
                        if( m > -0.5 )
                        {
                            vec3 pos = ro + t*rd;
                            vec3 nor = calcNormal( pos );
                            vec3 ref = reflect( rd, nor );
                            
                            // material        
                            col = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );
                        
                            if( m<1.5 )
                            {
                                float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);
                                col = 0.4 + 0.1*f*vec3(1.0);
                            }

                            // lighting        
                            float occ = calcAO( pos, nor );
                            vec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );
                            float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );
                            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );
                            float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);
                            float dom = smoothstep( -0.1, 0.1, ref.y );
                            float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );
                            float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);
                            
                            dif *= softshadow( pos, lig, 0.02, 2.5 );
                            dom *= softshadow( pos, ref, 0.02, 2.5 );

                            vec3 lin = vec3(0.0);
                            lin += 1.20*dif*vec3(1.00,0.85,0.55);
                            lin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;
                            lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;
                            lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;
                            lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;
                            lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;
                            col = col*lin;

                          col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );
                        }
                        return vec3( clamp(col,0.0,1.0) );
                    }

                    mat3 setCamera( in vec3 ro, in vec3 ta, float cr )
                    {
                        vec3 cw = normalize(ta-ro);
                        vec3 cp = vec3(sin(cr), cos(cr),0.0);
                        vec3 cu = normalize( cross(cw,cp) );
                        vec3 cv = normalize( cross(cu,cw) );
                        return mat3( cu, cv, cw );
                    }

                    void main()
                    {
                        vec2 q = gl_FragCoord.xy / resolution.xy;
                        vec2 p = 2.0*q - 1.0;
                        p.x *= resolution.x / resolution.y;
                        vec2 mo =  mouse.xy;
                         
                        float time = 15.0 + time;

                        // camera 
                        vec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), -0.0 + 4.0*mo.y, 0.5 + 3.5*sin(0.1*time + 6.0*mo.x) );
                        vec3 ta = vec3( -0.5, -0.4, 0.5 );
                      
                        // camera-to-world transformation
                        mat3 ca = setCamera( ro, ta, 0.0 );
                        
                        // ray direction
                        vec3 rd = ca * normalize( vec3(p.xy,2.0) );

                        // render 
                        vec3 col = render( ro+vec3(1,0,0), rd );

                        col = pow( col, vec3(0.7) );

                        gl_FragColor=vec4( col, 1.0 );
                    }


</script>

    <script id="electricty country" type="x-shader/x-fragment">



                    //电子国度
                    #ifdef GL_ES
                    precision mediump float;
                    #endif
                     
                    uniform float time;
                    uniform vec2 mouse;
                    uniform vec2 resolution;
                     
                    // by srtuss, 2013
                    // was trying to find some sort of "mechanical" fractal for texture/heightmap
                    // generation, but then i ended up with this.
                     
                    // rotate position around axis
                    vec2 rotate(vec2 p, float a)
                    {
                      return vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));
                    }
                     
                    // 1D random numbers
                    float rand(float n)
                    {
                        return fract(sin(n) * 43758.5453123);
                    }
                     
                    // 2D random numbers
                    vec2 rand2(in vec2 p)
                    {
                      return fract(vec2(sin(p.x * 1.32 + p.y * 54.077), cos(p.x * 91.32 + p.y * 9.077)));
                    }
                     
                    // 1D noise
                    float noise1(float p)
                    {
                      float fl = floor(p);
                      float fc = fract(p);
                      return mix(rand(fl), rand(fl + 1.0), fc);
                    }
                     
                    // voronoi distance noise, based on iq's articles
                    float voronoi(in vec2 x)
                    {
                      vec2 p = floor(x);
                      vec2 f = fract(x);
                      
                      vec2 res = vec2(8.0);
                      for(int j = -1; j <= 1; j ++)
                      {
                        for(int i = -1; i <= 1; i ++)
                        {
                          vec2 b = vec2(i, j);
                          vec2 r = vec2(b) - f + rand2(p + b);
                          
                          // chebyshev distance, one of many ways to do this
                          float d = max(abs(r.x), abs(r.y));
                          
                          if(d < res.x)
                          {
                            res.y = res.x;
                            res.x = d;
                          }
                          else if(d < res.y)
                          {
                            res.y = d;
                          }
                        }
                      }
                      return res.y - res.x;
                    }
                     
                     
                    #define flicker (noise1(time * 2.0) * 0.9 + 0.5)
                     
                    void main(void)
                    {
                      vec2 uv = gl_FragCoord.xy / resolution.xy;
                      uv = (uv - 0.5) * 2.0;
                      vec2 suv = uv;
                      uv.x *= resolution.x / resolution.y;
                      
                      
                      float v = 0.0;
                      
                      // that looks highly interesting:
                      //v = 1.0 - length(uv) * 1.3;
                      
                      
                      // a bit of camera movement
                      uv *= 0.6 + sin(time * 0.1) * 0.1;
                      uv = rotate(uv, sin(time * 0.3) * 1.0);
                      uv += time * 0.4;
                      
                      
                      // add some noise octaves
                      float a = 0.6, f = 1.0;
                      
                      for(int i = 0; i < 3; i ++) // 4 octaves also look nice, its getting a bit slow though
                      { 
                        float v1 = voronoi(uv * f + 1.0);
                        float v2 = 0.0;
                        
                        // make the moving electrons-effect for higher octaves
                        if(i > 0)
                        {
                          // of course everything based on voronoi
                          v2 = voronoi(uv * f * 0.5 + 5.0 + time);
                          
                          float va = 0.0, vb = 0.0;
                          va = 1.0 - smoothstep(0.0, 0.1, v1);
                          vb = 1.0 - smoothstep(0.0, 0.08, v2);
                          v += a * pow(va * (0.5 + vb), 2.0);
                        }
                        
                        // make sharp edges
                        v1 = 1.0 - smoothstep(0.0, 0.3, v1);
                        
                        // noise is used as intensity map
                        v2 = a * (noise1(v1 * 5.5 + 0.1));
                        
                        // octave 0's intensity changes a bit
                        if(i == 0)
                          v += v2 * flicker;
                        else
                          v += v2;
                        
                        f *= 3.0;
                        a *= 0.7;
                      }
                     
                      // slight vignetting
                      v *= exp(-0.6 * length(suv)) * 1.2;
                      
                      // use texture channel0 for color? why not.
                      //vec3 cexp = texture2D(iChannel0, uv * 0.001).xyz * 3.0 + texture2D(iChannel0, uv * 0.01).xyz;//vec3(1.0, 2.0, 4.0);
                      
                      // old blueish color set
                      vec3 cexp = vec3(3.0, 1.0, 3.0);
                        cexp *= 1.3;
                     
                      vec3 col = vec3(pow(v, cexp.x), pow(v, cexp.y), pow(v, cexp.z)) * 2.0;
                      
                      gl_FragColor = vec4(col, 1.0);
                    }


</script>

    <script id="red stars" type="x-shader/x-fragment">



                    //红色星云
                    #ifdef GL_ES
                    precision mediump float;
                    #endif
                     
                     
                    uniform float time;
                    uniform vec2 mouse;
                    uniform vec2 resolution;


                    #define iterations 14
                    #define formuparam2 (0.3 + 0.7*(abs(2.0*(fract(time*0.002))-1.0)))
                     
                    #define volsteps 5
                    #define stepsize 0.290
                     
                    #define zoom 0.900
                    #define tile   0.850
                    #define speed2  0.80
                     
                    #define brightness 0.003
                    #define darkmatter 0.400
                    #define distfading 0.560
                    #define saturation 0.800


                    #define transverseSpeed zoom*2.0
                    #define cloud 0.11 

                     
                    float triangle(float x, float a) { 
                      float output2 = 2.0*abs(  2.0*  ( (x/a) - floor( (x/a) + 0.5) ) ) - 1.0;
                      return output2;
                    }
                     
                    float field(in vec3 p) {  
                      float strength = 7. + .03 * log(1.e-6 + fract(sin(time) * 4373.11));
                      float accum = 0.;
                      float prev = 0.;
                      float tw = 0.;  

                      for (int i = 0; i < 6; ++i) {
                        float mag = dot(p, p);
                        p = abs(p) / mag + vec3(-.5, -.8 + 0.1*sin(time*0.7 + 2.0), -1.1+0.3*cos(time*0.3));
                        float w = exp(-float(i) / 7.);
                        accum += w * exp(-strength * pow(abs(mag - prev), 2.3));
                        tw += w;
                        prev = mag;
                      }
                      return max(0., 5. * accum / tw - .7);
                    }



                    void main() {   
                          vec2 uv2 =  gl_FragCoord.xy / resolution.xy;
                      vec2 uvs =  uv2 * resolution.xy  / resolution.y;
                      
                      float time2 = time;               
                            float speed = speed2;
                            speed = .01 * cos(time2*0.02 + 3.1415926/4.0);          
                      //speed = 0.0;  
                          float formuparam = formuparam2;
                      
                          //get coords and direction  
                      vec2 uv = uvs;           
                      //mouse rotation
                      float a_xz = -0.9;
                      float a_yz = .6;
                      float a_xy = -0.9 + time*0.08;  
                      
                      mat2 rot_xz = mat2(cos(a_xz),sin(a_xz),-sin(a_xz),cos(a_xz)); 
                      mat2 rot_yz = mat2(cos(a_yz),sin(a_yz),-sin(a_yz),cos(a_yz));   
                      mat2 rot_xy = mat2(cos(a_xy),sin(a_xy),-sin(a_xy),cos(a_xy));
                      

                      float v2 =1.0;  
                      vec3 dir=vec3(uv*zoom,1.); 
                      vec3 from=vec3(0.0, 0.0,0.0);                               
                            from.x -= 5.0*(mouse.x-0.5);
                            from.y -= 5.0*(mouse.y-0.5);
                                   
                                   
                      vec3 forward = vec3(0.0,-0.0,1.);   
                      from.x += transverseSpeed*(1.0)*cos(0.01*time) + 0.001*time;
                      from.y += transverseSpeed*(1.0)*sin(0.01*time) +0.001*time;
                      from.z += 0.003*time; 
                      
                      dir.xy*=rot_xy;
                      forward.xy *= rot_xy;
                      dir.xz*=rot_xz;
                      forward.xz *= rot_xz; 
                      dir.yz*= rot_yz;
                      forward.yz *= rot_yz;
                      
                      from.xy*=-rot_xy;
                      from.xz*=rot_xz;
                      from.yz*= rot_yz;
                       
                      
                      //zoom
                      float zooom = (time2-3311.)*speed;
                      from += forward* zooom;
                      float sampleShift = mod( zooom, stepsize );
                       
                      float zoffset = -sampleShift;
                      sampleShift /= stepsize; // make from 0 to 1
                      
                      //volumetric rendering
                      float s=0.24;
                      float s3 = s + stepsize/2.0;
                      vec3 v=vec3(0.);
                      float t3 = 0.0; 
                      
                      vec3 backCol2 = vec3(0.);
                      for (int r=0; r<volsteps; r++) {
                        vec3 p2=from+(s+zoffset)*dir;// + vec3(0.,0.,zoffset);
                        vec3 p3=from+(s3+zoffset)*dir;// + vec3(0.,0.,zoffset);
                        
                        p2 = abs(vec3(tile)-mod(p2,vec3(tile*2.))); // tiling fold
                        p3 = abs(vec3(tile)-mod(p3,vec3(tile*2.))); // tiling fold    
                        #ifdef cloud
                        t3 = field(p3);
                        #endif
                        
                        float pa,a=pa=0.;
                        for (int i=0; i<iterations; i++) {
                          p2=abs(p2)/dot(p2,p2)-formuparam; // the magic formula
                          //p=abs(p)/max(dot(p,p),0.005)-formuparam; // another interesting way to reduce noise
                          float D = abs(length(p2)-pa); // absolute sum of average change
                          a += i > 7 ? min( 12., D) : D;
                          pa=length(p2);
                        }
                        
                        
                        //float dm=max(0.,darkmatter-a*a*.001); //dark matter
                        a*=a*a; // add contrast
                        //if (r>3) fade*=1.-dm; // dark matter, don't render near
                        // brightens stuff up a bit
                        float s1 = s+zoffset;
                        // need closed form expression for this, now that we shift samples
                        float fade = pow(distfading,max(0.,float(r)-sampleShift));    
                        //t3 += fade;   
                        v+=fade;
                              //backCol2 -= fade;

                        // fade out samples as they approach the camera
                        if( r == 0 )
                          fade *= (1. - (sampleShift));
                        // fade in samples as they approach from the distance
                        if( r == volsteps-1 )
                          fade *= sampleShift;
                        v+=vec3(s1,s1*s1,s1*s1*s1*s1)*a*brightness*fade; // coloring based on distance
                        
                        backCol2 += mix(.4, 1., v2) * vec3(1.8 * t3 * t3 * t3, 1.4 * t3 * t3, t3) * fade;

                        
                        s+=stepsize;
                        s3 += stepsize;   
                      }//фор
                               
                      v=mix(vec3(length(v)),v,saturation); //color adjust 

                      vec4 forCol2 = vec4(v*.01,1.);  
                      #ifdef cloud
                      backCol2 *= cloud;
                      #endif  
                      backCol2.b *= -3.8;
                      backCol2.r *= 0.05; 
                      
                      backCol2.b = 0.5*mix(backCol2.g, backCol2.b, 0.8);
                      backCol2.g = -0.;
                      backCol2.bg = mix(backCol2.gb, backCol2.bg, 0.5*(cos(time*0.01) + 1.0));  
                      gl_FragColor = forCol2 + vec4(backCol2, 1.0);
                    }



</script>

    <script id="beautiful wait" type="x-shader/x-fragment">

                    //高级等待 *****
                    #ifdef GL_ES
                    precision mediump float;
                    #endif
                    #extension GL_OES_standard_derivatives : enable
                    uniform float time;
                    uniform vec2 resolution;
                    const float INTERVAL = 2.;
                    const float PI = 3.14159265358979323844;
                    //
                    //  r*cos(a) = R + t*(R*cos(b) - R)
                    //  r*sin(a) = t*R*sin(b)
                    //
                    //  t = (r*sin(a))/(R*sin(b))
                    //
                    //  r*cos(a) = R + (r*sin(a))/(R*sin(b))*(R*cos(b) - R)
                    //  r*cos(a) = R + (r*sin(a)/sin(b))*(cos(b) - 1)
                    //  r*(cos(a) - (sin(a)/sin(b))*(cos(b) - 1)) = R
                    float inside_polygon(vec2 pos, vec2 center, float r, float n, float s)
                    {
                            float theta = 2.*PI/n;
                            vec2 d = pos - center;
                            float a = mod(mod(atan(d.y, d.x) + s, 2.*PI), theta);
                            float l = length(d);
                           float m = r*cos(.5*theta)/cos(a - .5*theta); // r/(cos(a) - (sin(a)/sin(theta))*(cos(theta) - 1.));
                           const float border = .001;
                           return smoothstep(m + border, m - border, l);
                    }
                    float wobble(vec2 pos)
                    {
                            vec2 d = pos;
                            float a = (atan(d.y, d.x) + PI/2.)/(2.*PI);
                            float l = .75;
                            float t = mod(time, INTERVAL)/INTERVAL;
                            float o = t*(1. + l);
                            return smoothstep(o, o - l, a);
                    }
                    float inside_triangle(vec2 pos, vec2 center, float r, float s)
                    {
                           return inside_polygon(pos, center, wobble(center)*r, 3., s);
                    }
                    float inside_triangles(vec2 pos, float r)
                    {
                            const float da = 2.*PI/6.;
                            float a = 0.;
                            float v = 0.;
                            for (int i = 0; i < 6; i++) {
                                    float c = cos(a);
                                    float s = sin(a);
                                    vec2 d = vec2(c, s);
                                    vec2 n = vec2(-s, c);
                                    vec2 o0 = (2./3.)*sqrt(3.)*d*r;
                                    vec2 o1 = (5./6.)*sqrt(3.)*d*r;
                                    float r_triangle = 1.*r/sqrt(3.);
                                    v += inside_triangle(pos, o0, r_triangle, a) +
                                          inside_triangle(pos, o1 - n*.5*r, r_triangle, a + PI) +
                                            inside_triangle(pos, o1 + n*.5*r, r_triangle, a + PI);
                                    a += da;
                            }
                            return v;
                    }
                    void main()
                    {
                            const float radius = 20.;
                            vec2 pos = (gl_FragCoord.xy*2. - resolution)/min(resolution.x, resolution.y);
                            float r0 = .25;
                            float r1 = 2.*r0;
                            float r = mix(r1, r0, mod(time, INTERVAL)/INTERVAL);
                            float v = (inside_triangles(pos, r) + inside_polygon(pos, vec2(0., 0.), r, 6., PI/6.));
                            vec4 bg = mix(vec4(1.,.0,1.,1.),vec4(.0,.8,1.,1.),gl_FragCoord.y/resolution.y);
                            vec4 tri = mix(vec4(1.3,.0,1.,1.),vec4(.0,1.3,1.3,1.),gl_FragCoord.y/resolution.y);
                            gl_FragColor = mix(bg, tri, v);
                            //mix(vec4(.5,.1.,1.,1.),vec4(.0,.25,.25,1.),gl_FragCoord.y/resolution.y)
                    }



</script>

    <script id="old wall" type="x-shader/x-fragment">

                    //旧旧的墙面 *****
                    // 00f404afdd835ac3af3602c8943738ea - please mark changes (and/or add docs), and retain this line.

                    #ifdef GL_ES
                    precision mediump float;
                    #endif
                     

                    uniform float time;
                    uniform vec2 mouse;
                    uniform vec2 resolution;

                    float _MinStep = 0.125;

                    //////////////////////////////////////////////////////////////
                    // http://www.gamedev.net/topic/502913-fast-computed-noise/
                    // replaced costly cos with z^2. fullreset
                    vec4 random4 (const vec4 x) {
                        vec4 z = mod(mod(x, vec4(5612.0)), vec4(3.1415927 * 2.0));
                        return fract ((z*z) * vec4(56812.5453));
                    }
                    const float A = 1.0;
                    const float B = 57.0;
                    const float C = 113.0;
                    const vec3 ABC = vec3(A, B, C);
                    const vec4 A3 = vec4(0, B, C, C+B);
                    const vec4 A4 = vec4(A, A+B, C+A, C+A+B);
                    float cnoise4 (const in vec3 xx) {
                        vec3 x = xx; // mod(xx + 32768.0, 65536.0); // ignore edge issue
                        vec3 fx = fract(x);
                        vec3 ix = x-fx;
                        vec3 wx = fx*fx*(3.0-2.0*fx);
                        float nn = dot(ix, ABC);

                        vec4 N1 = nn + A3;
                        vec4 N2 = nn + A4;
                        vec4 R1 = random4(N1);
                        vec4 R2 = random4(N2);
                        vec4 R = mix(R1, R2, wx.x);
                        float re = mix(mix(R.x, R.y, wx.y), mix(R.z, R.w, wx.y), wx.z);

                        return 1.0 - 2.0 * re;
                    }

                    //////////////////////////////////////////////////////////////
                    // distance functions
                    // http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm
                    float sdSphere( vec3 p, float s ) { return length(p)-s; }
                    float udBox( vec3 p, vec3 b ) {  return length(max(abs(p)-b,0.0)); }
                    float udRoundBox( vec3 p, vec3 b, float r ) { return length(max(abs(p)-b,0.0))-r; }
                    float sdTorus( vec3 p, vec2 t ) { vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }
                    vec3  opRep(vec3 p, vec3 r) { return mod(p,r)-0.5*r; }
                    vec3  opTx(vec3 p, mat4 m ) { return (m*vec4(p,1.0)).xyz; }

                    /////////////////////////////////////////////////////
                    // the rest

                    float fbm(vec3 p) {
                        float f;
                        f = 0.5000*cnoise4( p ); p = p*2.02;
                        f += 0.2500*cnoise4( p ); p = p*2.03;
                        f += 0.1250*cnoise4( p ); p = p*2.01;
                        f += 0.0625*cnoise4( p ); 
                      return f;
                    }

                    float scene(vec3 p) { 
                      vec3 pw = vec3(0.,0.,10.);
                      float pa = udRoundBox(p+pw,vec3(100.,5,5.),0.22);
                      float pb = udRoundBox(p-pw,vec3(100.,5,5.),0.22);
                      float d = min(pa,pb);
                      
                      pa = udRoundBox(p+pw*2.,vec3(100.,80.,.2),0.22);
                      pb = udRoundBox(p-pw*2.,vec3(100.,80.,.2),0.22);
                      d = min(d,min(pa,pb));

                      vec3 c = opRep(p,vec3(20.,4.5,14.))-vec3(0.,0.,7.);
                      d = min(d,udRoundBox(c+pw+vec3(0.,0.0,-3.),vec3(1.75,2.,0.75),0.22));

                      float e = udRoundBox(p-vec3(0.,30.,4.),vec3(100.,0.1,0.1),0.2);
                      e = min(e,udRoundBox(p-vec3(0.,31.,4.),vec3(100.,0.06,0.06),0.1));
                      e = min(e,udRoundBox(p-vec3(0.,5.,1.),vec3(100.,0.1,0.1),0.2));
                      e = min(e,udRoundBox(p-vec3(0.,4.,1.),vec3(100.,0.1,0.1),0.2)); 
                      e = min(e,udRoundBox(p-vec3(7.45,0.,-7.5),vec3(0.1,100.,0.1),0.1)); 

                      float n = fbm(p);   
                      return min(e,n*0.32+d); // 'texture'
                    }

                    vec4 color(float d) { 
                      return mix(vec4(1.,1.,1.,0.25),vec4(0.2,0.1,0.,0.05),smoothstep(0.,0.1,d)); 
                    }

                    vec4 ray(vec3 pos, vec3 step) {
                        vec4 sum = vec4(0.);
                        vec4 col;
                        float d = 9999.0;
                    #define RAY1  { d = scene(pos); col = color(d); col.rgb *= col.a; sum += col*(1.0 - sum.a); pos += step*max(d,_MinStep); }
                    #define RAY4  RAY1 RAY1 RAY1 RAY1
                        RAY4 RAY4 RAY4 RAY4
                        return sum;
                    }

                    void main( void ) {
                      vec3 e = vec3(sin(time*0.2)*20.,14.,-20.); 
                      vec3 p = vec3((gl_FragCoord.xy / resolution.xy) * 2. -1., 1.);
                      p.x *= resolution.x/resolution.y;
                      p += e;
                      gl_FragColor = ray(p, normalize(p-e));
                    }




</script>

    <script id="color lines" type="x-shader/x-fragment">






                    //淡彩色线条
                    #ifdef GL_ES
                    precision mediump float;
                    #endif

                    uniform vec2 resolution;
                    uniform float time;

                    float d2y(float d){ d*= 40.; return 1./(d*d);}

                    vec3 hsv2rgb(vec3 c)
                    {
                        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
                    }

                    float gauss(float s, float x){
                        return (0.85)*exp(-x*x/(2.*s*s));
                    }
                    #if 1
                    float blur(float dist, float width, float blur, float intens){
                        float w = width;
                        float e = 0.85*blur;
                        dist*=0.75;
                        float b = smoothstep(-w-e, -w+e, dist)-smoothstep(w-e, w+e, dist);
                        return 1.0*pow(b,1.9)*(1.+80.*blur)*intens;
                        //return 0.9*b*intens;
                    }
                    #else
                    float blur(float dist, float width, float blur, float intens){
                        float w = width;
                        dist = max(abs(dist)-width,0.);
                        float b = gauss(0.02+w*10.*blur,dist);
                        return b*intens;
                    }
                    #endif
                    float d2y2(float d, float i){
                        float b = 0.04*i+0.0001;
                        return blur(d , 0.03, b, 0.4);
                    }



                    float f(float x){
                        return blur(0.5*x, 0.03, 0.04+0.5, 1.);
                    }


                    #define N 8
                    // hauteur de la vague
                    float wave(float x, int i){
                        float i_f=float(i);
                        float fy = (3.3-0.5*i_f)*sin(x*2.+2.8*time+.6*i_f);
                        return fy * (0.4+0.3*cos(x));
                    }

                    void main(void)
                    {
                        vec2 uv = (gl_FragCoord.xy / resolution - vec2(0.5)) * vec2(resolution.x / resolution.y, 1.0) * 1.0;
                        uv.y *= 2.2;
                        uv.x *= 2.1;

                      
                        float yf = 0.*d2y(distance(uv.y*2., f(uv.x)));
                        vec3 col = vec3(0.0);
                        for(int i = 0; i<N; ++i){
                            float i_f = float(i)*0.8+1.;
                            float y = d2y2(distance(3.*uv.y, wave(uv.x, i)),i_f);
                            col += 0.8*y *hsv2rgb(vec3(0.00015*time+i_f*0.1-0.05, 0.6,1.0));
                            
                        }
                        
                        gl_FragColor = vec4(vec3(yf)+(233./255.)-col, 1.0);
                    }




</script>

    <script id="toon cloud" type="x-shader/x-fragment">





                    //卡通云 *****
                    // ----------------------------------------------------------------------------------------
                    //  "Toon Cloud" by Antoine Clappier - March 2015
                    //
                    //  Licensed under:
                    //  A Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
                    //  http://creativecommons.org/licenses/by-nc-sa/4.0/
                    // ----------------------------------------------------------------------------------------
                    // original from https://www.shadertoy.com/view/4t23RR
                    // ----------------------------------------------------------------------------------------

                    #ifdef GL_ES
                    precision mediump float;
                    #endif

                    uniform vec2 resolution;
                    uniform float time;

                    #define TAU 6.28318530718


                    const vec3 BackColor  = vec3(0.0, 0.4, 0.58);
                    const vec3 CloudColor = vec3(0.18,0.70,0.87);


                    float Func(float pX)
                    {
                      return 0.6*(0.5*sin(0.1*pX) + 0.5*sin(0.553*pX) + 0.7*sin(1.2*pX));
                    }


                    float FuncR(float pX)
                    {
                      return 0.5 + 0.25*(1.0 + sin(mod(40.0*pX, TAU)));
                    }


                    float Layer(vec2 pQ, float pT)
                    {
                      vec2 Qt = 3.5*pQ;
                      pT *= 0.5;
                      Qt.x += pT;

                      float Xi = floor(Qt.x);
                      float Xf = Qt.x - Xi -0.5;

                      vec2 C;
                      float Yi;
                      float D = 1.0 - step(Qt.y,  Func(Qt.x));

                      // Disk:
                      Yi = Func(Xi + 0.5);
                      C = vec2(Xf, Qt.y - Yi ); 
                      D =  min(D, length(C) - FuncR(Xi+ pT/80.0));

                      // Previous disk:
                      Yi = Func(Xi+1.0 + 0.5);
                      C = vec2(Xf-1.0, Qt.y - Yi ); 
                      D =  min(D, length(C) - FuncR(Xi+1.0+ pT/80.0));

                      // Next Disk:
                      Yi = Func(Xi-1.0 + 0.5);
                      C = vec2(Xf+1.0, Qt.y - Yi ); 
                      D =  min(D, length(C) - FuncR(Xi-1.0+ pT/80.0));

                      return min(1.0, D);
                    }

                    void main(void){
                      vec2 uv = 1.2*(2.0*gl_FragCoord.xy - resolution.xy) / resolution.y;
                      
                      // Render:
                      vec3 Color= BackColor;

                      for(float J=0.0; J<=1.0; J+=0.2)
                      {
                        // Cloud Layer: 
                        float Lt =  time*(0.5  + 2.0*J)*(1.0 + 0.1*sin(226.0*J)) + 17.0*J;
                        vec2 Lp = vec2(0.0, 0.3+1.5*( J - 0.5));
                        float L = Layer(uv + Lp, Lt);

                        // Blur and color:
                        float Blur = 4.0*(0.5*abs(2.0 - 5.0*J))/(11.0 - 5.0*J);

                        float V = mix( 0.0, 1.0, 1.0 - smoothstep( 0.0, 0.01 +0.2*Blur, L ) );
                        vec3 Lc=  mix( CloudColor, vec3(1.0), J);

                        Color =mix(Color, Lc,  V);
                      }
                      gl_FragColor = vec4(Color,1.);
                    }
</script>

    <script id="thinkering" type="x-shader/x-fragment">

// bpt.2017 thinkering

#ifdef GL_ES
precision highp float;
#endif

#extension GL_OES_standard_derivatives : enable

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;
varying vec2 surfacePosition;

// using as a starting point thx https://www.shadertoy.com/view/MtKSWt

vec4 BezierPoint(vec4 p0, vec4 p1, vec4 p2, float t){
    vec4 v1 = p1-p0;
    vec4 v2 = p2-p1;
    vec4 o0 = p0+v1*t;
    vec4 o1 = p1+v2*t;
    vec4 v3 = o1-o0;
    return v3*t+o0;
}

float dot2(vec4 v) {return dot(v,v);}

float BezierLine(vec4 p, vec4 a, vec4 b, vec4 c,float minDist)
{
    for( float i = 0.0; i <= 1.0; i+=0.001)
    {
        minDist = min( dot2(p-BezierPoint(a,b,c,i)), minDist);
    }
    return pow(minDist,0.125);
}

void main( void )
{
    vec2 uv = (surfacePosition*vec2(2.0,2.0));
    vec4 p3 = vec2(1.,0.).xyxy;
//    vec4 p2 = vec4(0.0,sin(time)*uv.x,0.0,sin(time)*uv.x)*cos(time*2.0);//
    vec4 p2 = mouse.xyxy*8.0-4.0;
    vec4 p1 = -p3;
    
    gl_FragColor = vec4( vec3(
         BezierLine(vec4(uv,uv),p1,p2,p3,1.0)
    ),1.0);
}
</script>

    <script id="Majestic Wireframe Cube" type="x-shader/x-fragment">
 // Majestic Wireframe Cube
// By: Brandon Fogerty
// bfogerty at gmail dot com
// xdpixel.com

#ifdef GL_ES
precision mediump float;
#endif

#extension GL_OES_standard_derivatives : enable

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

float line( vec2 a, vec2 b, vec2 p )
{
    vec2 aTob = b - a;
    vec2 aTop = p - a;

    float t = dot( aTop, aTob ) / dot( aTob, aTob);

    t = clamp( t, 0.0, 1.0);

    float d = length( p - (a + aTob * t) );
    d = 0.05 / d;

    d = pow(d, 7.0);
    return clamp( d, 0.0, 1.0 );
}

mat4 perspectiveMatrix(float fovYInRad, float aspectRatio)
{    
    float yScale = 1.0/tan(fovYInRad / 2.0);
    float xScale = yScale / aspectRatio;  
    float zf = 100.0;
    float zn = 0.3;
    
    float z1 = zf/(zf-zn);
    float z2 = -zn*zf/(zf-zn);

    mat4 result = mat4(xScale, 0.0, 0.0, 0.0,
              0.0, yScale, 0.0, 0.0,
              0.0, 0.0, z1, z2,
              0.0, 0.0, -1.0, 0.0);
    
    return result;
}

mat4 translationMatrix(vec3 pos)
{
    mat4 result = 
    mat4(1.0, 0.0, 0.0, 0.0, 
         0.0, 1.0, 0.0, 0.0,
         0.0, 0.0, 1.0, 0.0,
         pos.x, pos.y, pos.z, 1.0 );
    
    return result;
}

mat4 rotXMatrix(float theta)
{
    float cs = cos(theta);
    float ss = sin(theta);

    mat4 result = 
    mat4(1.0, 0.0, 0.0, 0.0, 
         0.0, cs, -ss, 0.0,
         0.0, ss, cs, 0.0,
         0.0, 0.0, 0.0, 1.0 );

    return result;
}

mat4 rotYMatrix(float theta)
{
    float cs = cos(theta);
    float ss = sin(theta);

    mat4 result = 
    mat4(cs, 0.0, -ss, 0.0, 
         0.0, 1.0, 0.0, 0.0,
         ss, 0.0, cs, 0.0,
         0.0, 0.0, 0.0, 1.0 );

    return result;
}

float particle(vec2 uv, vec4 vert, mat4 mvp, vec2 sizeRange, float sizeOffset, vec2 moveSpeed)
{
    vec4 v = mvp * vert;
    vec2 vp = (v.xy / v.w);

    float size = mix(sizeRange.x, sizeRange.y, sin(time + sizeOffset) * 0.5 + 0.5);
    float t = 1.0 / abs(length(uv.xy - (vp.xy + vec2(cos(time * moveSpeed.x), sin(time * moveSpeed.y)))) * size);

    t = pow( t, 1.5);
    
    return t;
}

void main( void )
{
    vec2 uv = ( gl_FragCoord.xy / resolution.xy ) * 2.0 - 1.0;

    uv *= 10.0;

    const float fovYInRad = (45.0/180.0) * 3.14159;
    float aspectRatio = resolution.x / resolution.y;

    const float vs = 10.0;
    #define maxVerts 16
    vec4 verts [maxVerts];
    verts[0] = vec4( -vs, -vs, vs, 1.0 );
    verts[1] = vec4( -vs,  vs, vs, 1.0 );
    verts[2] = vec4(  vs,  vs, vs, 1.0 );
    verts[3] = vec4(  vs, -vs, vs, 1.0 );

    verts[4] = vec4( -vs, -vs, vs, 1.0 );
    verts[5] = vec4( -vs,  vs, vs, 1.0 );
    verts[6] = vec4( -vs,  vs, -vs, 1.0 );
    verts[7] = vec4( -vs, -vs, -vs, 1.0 );

    verts[8] = vec4( -vs, -vs, -vs, 1.0 );
    verts[9] = vec4( -vs,  vs, -vs, 1.0 );
    verts[10] = vec4( vs,  vs, -vs, 1.0 );
    verts[11] = vec4( vs, -vs, -vs, 1.0 );

    verts[12] = vec4( vs, -vs, vs, 1.0 );
    verts[13] = vec4( vs,  vs, vs, 1.0 );
    verts[14] = vec4( vs,  vs, -vs, 1.0 );
    verts[15] = vec4( vs, -vs, -vs, 1.0 );

    float moveX = mix(10.0, -10.0, sin(time * 0.4) * 0.5 + 0.5);
    float moveY = mix(10.0, -10.0, sin(time * 0.2) * 0.5 + 0.5);
    float moveZ = mix(40.0, 60.0, sin(time * 0.2) * 0.5 + 0.5);

    vec3 pos = vec3( moveX, moveY, moveZ);
    mat4 rotY = rotYMatrix(time) * rotXMatrix(time * 0.5);

    mat4 worldMat = translationMatrix(pos) * rotY;
    mat4 perspective = perspectiveMatrix(fovYInRad, aspectRatio);

    mat4 mvp = perspective * worldMat;

  
  
  
    float t = 0.0;
    for(int i = 0; i < maxVerts; ++i)
    {
        vec4 startWorldVert = mvp * verts[i];
        vec4 endWorldVert;
        if( i+1 < maxVerts)
        {
            endWorldVert = mvp * verts[i + 1];
        }
        else
        {
            endWorldVert = mvp * verts[i - 3];
        }

        if(i != 0 && mod(float(i+1), 4.0) == 0.0)
        {
            endWorldVert = mvp * verts[i - 3];
        }

        vec2 sp = startWorldVert.xy / startWorldVert.w;
        vec2 ep = endWorldVert.xy / endWorldVert.w;

        t += line( sp, ep, uv);
    }

    vec3 fc = vec3( 0.00 );
    fc += vec3(pow(abs(uv.y / 10.0), 2.5));

    fc += vec3( 2.0, 4.0, 8.0 ) * pow(t, 0.2);

  
    t = particle(uv, verts[0], mvp, vec2(20.0, 40.0), 1.0, vec2( 3.0, 1.0));
    fc += vec3(8.0, 4.0, 2.0) * t;

    t = particle(uv, verts[1], mvp, vec2(20.0, 40.0), 14.0, vec2( 1.0, 3.0));
    fc += vec3(4.0, 8.0, 2.0) * t;

    t = particle(uv, verts[10], mvp, vec2(10.0, 40.0), 25.0, vec2( 2.0, 1.0));
    fc += vec3(3.0, 2.0, 7.0) * t;

    t = particle(uv, verts[12], mvp, vec2(10.0, 40.0), 78.0, vec2( 5.0, 3.0));
    fc += vec3(4.0, 3.0, 8.0) * t;

    t = particle(uv, verts[6], mvp, vec2(10.0, 40.0), 100.0, vec2( 5.0, 3.0));
    fc += vec3(8.0, 1.0, 1.0) * t;

    gl_FragColor = vec4( fc, 1.0 );

}      






</script>

    <script id="shui long tou" type="x-shader/x-fragment">


#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

// Spout - @P_Malin

// Port of textured version from - www.shadertoy.com/view/lsXGzH

//#define LOW_QUALITY

#ifdef LOW_QUALITY
    #define kRaymarchMaxIter 16
#else
    #define kRaymarchMaxIter 32
    
    #define ENABLE_AMBIENT_OCCLUSION
    #define DOUBLE_SIDED_TRANSPARENCY
#endif

#define ENABLE_SPECULAR
#define ENABLE_REFLECTIONS
#define ENABLE_TRANSPARENCY
#define ENABLE_SHADOWS
#define ENABLE_FOG

#define ENABLE_DIRECTIONAL_LIGHT
#define ENABLE_DIRECTIONAL_LIGHT_FLARE

//#define ENABLE_POINT_LIGHT
//#define ENABLE_POINT_LIGHT_FLARE

const float kPipeRadius = 0.4;
const float kPipeThickness = 0.15;
const float kPipeHeight = 2.0;
//float kPipeHeight = 2.0 + sin(iGlobalTime);

const float kWaterNoiseScale = 0.025;

const float kWaterVelocity = 1.0;

const float kWaterAccel = -1.0;

const float kWaterAnimSpeed = 80.0;
const float kTrenchWaterAnimSpeed = 20.0;

const float watRef = 1.0 / 1.3330;

float kRipplePos = sqrt(abs(2.0 * kPipeHeight / kWaterAccel)) * kWaterVelocity;

const float kPI = 3.141592654;
const float kTwoPI = kPI * 2.0;

const float kNoTransparency = -1.0;
const float kTransparency = 1.0;
const float kInverseTransparency = 0.0;

struct C_Ray
{
    vec3 vOrigin;
    vec3 vDir;
    float fStartDistance;
    float fLength;
};

struct C_HitInfo
{
    vec3 vPos;
    float fDistance;
    vec3 vObjectId;
};
    
struct C_Surface
{
    vec3 vNormal;
    vec3 cReflection;
    vec3 cTransmission;    
};

struct C_Material
{
    vec3 cAlbedo;
    float fR0;
    float fSmoothness;
    vec2 vParam;

    float fTransparency;
    float fRefractiveIndex;
};

struct C_Shading
{
    vec3 cDiffuse;
    vec3 cSpecular;
};

struct C_PointLight
{
    vec3 vPos;
    vec3 cColour;
};

struct C_DirectionalLight
{
    vec3 vDir;
    vec3 cColour;
};

vec3 RotateX( const in vec3 vPos, const in float fAngle )
{
    float s = sin(fAngle);
    float c = cos(fAngle);
    
    vec3 vResult = vec3( vPos.x, c * vPos.y + s * vPos.z, -s * vPos.y + c * vPos.z);
    
    return vResult;
}

vec3 RotateY( const in vec3 vPos, const in float fAngle )
{
    float s = sin(fAngle);
    float c = cos(fAngle);
    
    vec3 vResult = vec3( c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);
    
    return vResult;
}

vec3 RotateZ( const in vec3 vPos, const in float fAngle )
{
    float s = sin(fAngle);
    float c = cos(fAngle);
    
    vec3 vResult = vec3( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y, vPos.z);
    
    return vResult;
}

/////////////////////////////////////
// Distance Field CSG
// These carry with them the material parameters in yzw

vec4 DistCombineUnion( const in vec4 v1, const in vec4 v2 )
{
    //if(v1.x < v2.x) return v1; else return v2;
    return mix(v1, v2, step(v2.x, v1.x));
}

vec4 DistCombineUnionConditional( const in vec4 v1, const in vec4 v2, const in float fCondition )
{    
  //if( fCondition < 0.0 )
  //            return v1;
                
    return mix(v1, v2, step(v2.x, v1.x) * step(0.0, fCondition));
}

vec4 DistCombineIntersect( const in vec4 v1, const in vec4 v2 )
{
    return mix(v2, v1, step(v2.x,v1.x));
}

vec4 DistCombineSubtract( const in vec4 v1, const in vec4 v2 )
{
    return DistCombineIntersect(v1, vec4(-v2.x, v2.yzw));
}

/////////////////////////////////////
// Scene Description 

const float kMaterialIdWall = 1.0;
const float kMaterialIdPipe = 2.0;
const float kMaterialIdWater = 3.0;

float Noise(vec2 p)
{
    vec2 s = sin(p * 0.6345) + sin(p * 1.62423);
    return dot(s, vec2(0.125)) + 0.5;
}

// result is x=scene distance y=material or object id; zw are material specific parameters (maybe uv co-ordinates)
vec4 GetDistanceScene( const in vec3 vPos, const in float fTransparentScale )
{          
    vec4 vResult = vec4(10000.0, -1.0, 0.0, 0.0);
            
  float fDistFloor = vPos.y;
  float fDistBrick = fDistFloor;
  
  float fDistTrench = length(vPos.yz + vec2(-0.4, 0.0)) - 1.0;
  fDistBrick = max(fDistBrick, -(fDistTrench));
  
  float fDistWall = vPos.x + 1.0;
  fDistBrick = min(fDistBrick, fDistWall);
  
    vec4 vDistFloor = vec4(fDistBrick, kMaterialIdWall, vPos.xz + vec2(vPos.y, 0.0));
    vResult = DistCombineUnion(vResult, vDistFloor);    

    vec3 vWaterDomain = vPos - vec3(0.0, kPipeHeight, 0.0);

    float t= max(vWaterDomain.x / kWaterVelocity, 0.0);
  
  // Equations of motion
  float s = 0.5 * kWaterAccel * t * t;
  float v = -kWaterAccel * t;
  
  vWaterDomain.y -= s;    
                
    float fDistWater = (length(vWaterDomain.yz) - kPipeRadius);
                
    float fDistPipe = max(fDistWater - kPipeThickness, vWaterDomain.x);
    fDistPipe = max(fDistPipe, -fDistWater); // subtract the water from the pipe to make the hole
    vec4 vDistPipe = vec4(fDistPipe, kMaterialIdPipe, vPos.xy);        
        
    vResult = DistCombineUnion(vResult, vDistPipe);    
  
  // compensate for domain distortion of water, otherwise ray sometimes misses
  fDistWater /= (1.0 + v * 0.5);
  
    vec2 vNoiseDomain = vPos.xz;
                
  // modify noise for water in trench
  float fInTrench = step(vPos.y, (-0.1 + 0.05));        
  vec2 vRippleCentre1 = vPos.xz - vec2(kRipplePos, 0.0);
  vNoiseDomain.x = mix(vNoiseDomain.x, length(vRippleCentre1), fInTrench);
  float fNoiseScale = mix(t * t, 1.0 / (1.0 + vNoiseDomain.x), fInTrench) * kWaterNoiseScale;
  float fWaterSpeed = mix(kWaterAnimSpeed * kWaterVelocity, kTrenchWaterAnimSpeed, fInTrench);
  
  vNoiseDomain *= 30.0; 
  vNoiseDomain.x += -time * fWaterSpeed;
  
  float fTrenchWaterDist = vPos.y + 0.1;
  fDistWater = min(fDistWater, fTrenchWaterDist);
  
  fDistWater += Noise(vNoiseDomain) * fNoiseScale;
  
  // Negate the distance to the water if transparent scale is 0.0     
  // This allows us to ratrace "out" of water
  fDistWater *= (fTransparentScale * 2.0) - 1.0;
  
  vec4 vDistWater = vec4(fDistWater, kMaterialIdWater, vPos.xy);        
  // The condition allows us to ignore water for secondary rays
  vResult = DistCombineUnionConditional(vResult, vDistWater, fTransparentScale);
              
    return vResult;
}

float GetRayFirstStep( const in C_Ray ray )
{
    return ray.fStartDistance;  
}

C_Material GetObjectMaterial( const in C_HitInfo hitInfo )
{
    C_Material mat;
              
    if(hitInfo.vObjectId.x == kMaterialIdWall)
    {
        // floor
        mat.fR0 = 0.02;
  vec2 vTile = step(vec2(0.15), fract(hitInfo.vObjectId.yz));
  float fTile = vTile.x * vTile.y;
        mat.cAlbedo = vec3(1.0) * (fTile * 0.8 + 0.2);
        mat.fSmoothness = 1.0;
        
        mat.fSmoothness = mat.cAlbedo.r;
        mat.fTransparency = 0.0;
    }
    else
    if(hitInfo.vObjectId.x == kMaterialIdPipe)
    {
        // pipe
        mat.fR0 = 0.8;
        mat.fSmoothness = 1.0;
        mat.cAlbedo = vec3(0.5);
        mat.fTransparency = 0.0;
    }
    else
    {
  // water
        mat.fR0 = 0.01;
        mat.fSmoothness = 1.0;
        mat.fTransparency = 1.0;
        mat.fRefractiveIndex = watRef; //1.0 / 1.3330;
        const float fExtinctionScale = 2.0;
    const vec3 vExtinction = vec3(0.3, 0.7, 0.9);
        mat.cAlbedo = (vec3(1.0) - vExtinction) * fExtinctionScale; // becomes extinction for transparency
    }
    
    return mat;
}

vec3 GetSkyGradient( const in vec3 vDir )
{
    const vec3 cColourTop = vec3(0.7, 0.8, 1.0);
    const vec3 cColourHorizon = cColourTop * 0.5;

    float fBlend = clamp(vDir.y, 0.0, 1.0);
    return mix(cColourHorizon, cColourTop, fBlend);
}

C_PointLight GetPointLight()
{
    C_PointLight result;

    result.vPos = vec3(0.5, 1.0, -2.0);
    result.cColour = vec3(32.0, 6.0, 1.0) * 10.0;

    return result;
}

C_DirectionalLight GetDirectionalLight()
{
    C_DirectionalLight result;

    result.vDir = normalize(vec3(-0.2, -0.3, 0.5));
    result.cColour = vec3(8.0, 7.5, 7.0);

    return result;
}

vec3 GetAmbientLight(const in vec3 vNormal)
{
    return GetSkyGradient(vNormal);
}

/////////////////////////////////////
// Raymarching 

vec3 GetSceneNormal( const in vec3 vPos, const in float fTransparentScale )
{
    // tetrahedron normal
    const float fDelta = 0.025;

    vec3 vOffset1 = vec3( fDelta, -fDelta, -fDelta);
    vec3 vOffset2 = vec3(-fDelta, -fDelta,  fDelta);
    vec3 vOffset3 = vec3(-fDelta,  fDelta, -fDelta);
    vec3 vOffset4 = vec3( fDelta,  fDelta,  fDelta);

    float f1 = GetDistanceScene( vPos + vOffset1, fTransparentScale ).x;
    float f2 = GetDistanceScene( vPos + vOffset2, fTransparentScale ).x;
    float f3 = GetDistanceScene( vPos + vOffset3, fTransparentScale ).x;
    float f4 = GetDistanceScene( vPos + vOffset4, fTransparentScale ).x;

    vec3 vNormal = vOffset1 * f1 + vOffset2 * f2 + vOffset3 * f3 + vOffset4 * f4;

    return normalize( vNormal );
}

#define kRaymarchEpsilon 0.01
// This is an excellent resource on ray marching -> http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm
void Raymarch( const in C_Ray ray, out C_HitInfo result, const int maxIter, const float fTransparentScale )
{        
    result.fDistance = GetRayFirstStep( ray );
    result.vObjectId.x = 0.0;
        
    for(int i=0;i<=kRaymarchMaxIter;i++)              
    {
        result.vPos = ray.vOrigin + ray.vDir * result.fDistance;
        vec4 vSceneDist = GetDistanceScene( result.vPos, fTransparentScale );
        result.vObjectId = vSceneDist.yzw;
        
        // abs allows backward stepping - should only be necessary for non uniform distance functions
        if((abs(vSceneDist.x) <= kRaymarchEpsilon) || (result.fDistance >= ray.fLength) || (i > maxIter))
        {
            break;
        }                        

        result.fDistance = result.fDistance + vSceneDist.x; 
    }


    if(result.fDistance >= ray.fLength)
    {
        result.fDistance = 1000.0;
        result.vPos = ray.vOrigin + ray.vDir * result.fDistance;
        result.vObjectId.x = 0.0;
    }
}

float GetShadow( const in vec3 vPos, const in vec3 vNormal, const in vec3 vLightDir, const in float fLightDistance )
{
    #ifdef ENABLE_SHADOWS
    C_Ray shadowRay;
    shadowRay.vDir = vLightDir;
    shadowRay.vOrigin = vPos;
    const float fShadowBias = 0.05;
    shadowRay.fStartDistance = fShadowBias / abs(dot(vLightDir, vNormal));
    shadowRay.fLength = fLightDistance - shadowRay.fStartDistance;
  
    C_HitInfo shadowIntersect;
    Raymarch(shadowRay, shadowIntersect, 32, kNoTransparency);
    
    float fShadow = step(0.0, shadowIntersect.fDistance) * step(fLightDistance, shadowIntersect.fDistance );
    
    return fShadow;          
    #else
      return 1.0;
    #endif
}

// use distance field to evaluate ambient occlusion
float GetAmbientOcclusion(const in C_HitInfo intersection, const in C_Surface surface)
{
    #ifdef ENABLE_AMBIENT_OCCLUSION    
    vec3 vPos = intersection.vPos;
    vec3 vNormal = surface.vNormal;
  
    float fAmbientOcclusion = 1.0;
  
    float fDist = 0.0;
    for(int i=0; i<=5; i++)
    {
      fDist += 0.1;
  
      vec4 vSceneDist = GetDistanceScene(vPos + vNormal * fDist, kNoTransparency);
  
      fAmbientOcclusion *= 1.0 - max(0.0, (fDist - vSceneDist.x) * 0.2 / fDist );                                 
    }
  
    return fAmbientOcclusion;
    #else
      return 1.0;
    #endif    
}

/////////////////////////////////////
// Lighting and Shading

#define kFogDensity 0.05

void ApplyAtmosphere(inout vec3 col, const in C_Ray ray, const in C_HitInfo hitInfo)
{
    #ifdef ENABLE_FOG
    // fog
    float fFogAmount = exp(hitInfo.fDistance * -kFogDensity);
    vec3 cFog = GetSkyGradient(ray.vDir);

    #ifdef ENABLE_DIRECTIONAL_LIGHT_FLARE
    C_DirectionalLight directionalLight = GetDirectionalLight();
    float fDirDot = clamp(dot(-directionalLight.vDir, ray.vDir), 0.0, 1.0);
    cFog += directionalLight.cColour * pow(fDirDot, 10.0);
    #endif 

    col = mix(cFog, col, fFogAmount);
    #endif

    // glare from light (a bit hacky - use length of closest approach from ray to light)
    #ifdef ENABLE_POINT_LIGHT_FLARE
    C_PointLight pointLight = GetPointLight();

    vec3 vToLight = pointLight.vPos - ray.vOrigin;
    float fPointDot = dot(vToLight, ray.vDir);
    fPointDot = clamp(fPointDot, 0.0, hitInfo.fDistance);

    vec3 vClosestPoint = ray.vOrigin + ray.vDir * fPointDot;
    float fDist = length(vClosestPoint - pointLight.vPos);
    col += pointLight.cColour * 0.01/ (fDist * fDist);
    #endif    
}

// http://en.wikipedia.org/wiki/Schlick's_approximation
float Schlick( const in vec3 vNormal, const in vec3 vView, const in float fR0, const in float fSmoothFactor)
{
    float fDot = dot(vNormal, -vView);
    fDot = clamp((1.0 - fDot), 0.0, 1.0);
    float fDotPow = pow(fDot, 5.0);
    return fR0 + (1.0 - fR0) * fDotPow * fSmoothFactor;
}

vec3 ApplyFresnel(const in vec3 vDiffuse, const in vec3 vSpecular, const in vec3 vNormal, const in vec3 vView, const in C_Material material)
{
    float fFresnel = Schlick(vNormal, vView, material.fR0, material.fSmoothness * 0.9 + 0.1);
    return mix(vDiffuse, vSpecular, fFresnel);    
}

float GetBlinnPhongIntensity(const in vec3 vIncidentDir, const in vec3 vLightDir, const in vec3 vNormal, const in float fSmoothness)
{          
    vec3 vHalf = normalize(vLightDir - vIncidentDir);
    float fNdotH = max(0.0, dot(vHalf, vNormal));

    float fSpecPower = exp2(4.0 + 6.0 * fSmoothness);
    float fSpecIntensity = (fSpecPower + 2.0) * 0.125;

    return pow(fNdotH, fSpecPower) * fSpecIntensity;
}

C_Shading ApplyPointLight( const in C_PointLight light, const in vec3 vSurfacePos, const in vec3 vIncidentDir, const in vec3 vNormal, const in C_Material material )
{
    C_Shading shading;
    
    vec3 vToLight = light.vPos - vSurfacePos;
    vec3 vLightDir = normalize(vToLight);
    float fLightDistance = length(vToLight);
    
    float fAttenuation = 1.0 / (fLightDistance * fLightDistance);
    
    float fShadowFactor = GetShadow( vSurfacePos, vNormal, vLightDir, fLightDistance );
    vec3 vIncidentLight = light.cColour * fShadowFactor * fAttenuation * max(0.0, dot(vLightDir, vNormal));
    
    shading.cDiffuse = vIncidentLight;                                  
    shading.cSpecular = GetBlinnPhongIntensity( vIncidentDir, vLightDir, vNormal, material.fSmoothness ) * vIncidentLight;
    
    return shading;
}  

C_Shading ApplyDirectionalLight( const in C_DirectionalLight light, const in vec3 vSurfacePos, const in vec3 vIncidentDir, const in vec3 vNormal, const in C_Material material )
{
    C_Shading shading;

    const float kShadowRayLength = 10.0;      
    vec3 vLightDir = -light.vDir;
    float fShadowFactor = GetShadow( vSurfacePos, vNormal, vLightDir, kShadowRayLength );
    vec3 vIncidentLight = light.cColour * fShadowFactor * max(0.0, dot(vLightDir, vNormal));
    
    shading.cDiffuse = vIncidentLight;                                  
    shading.cSpecular = GetBlinnPhongIntensity( vIncidentDir, vLightDir, vNormal, material.fSmoothness ) * vIncidentLight;
    
    return shading;
}  


vec3 ShadeSurface(const in C_Ray ray, const in C_HitInfo hitInfo, const in C_Surface surface, const in C_Material material)
{
    vec3 cScene;
    
    C_Shading shading;

    shading.cDiffuse = vec3(0.0);
    shading.cSpecular = vec3(0.0);
    
    float fAmbientOcclusion = GetAmbientOcclusion(hitInfo, surface);
    vec3 vAmbientLight = GetAmbientLight(surface.vNormal) * fAmbientOcclusion;
    
    shading.cDiffuse += vAmbientLight;
    shading.cSpecular += surface.cReflection;
              
    #ifdef ENABLE_POINT_LIGHT
    C_PointLight pointLight = GetPointLight();
    C_Shading pointLighting = ApplyPointLight(pointLight, hitInfo.vPos,ray.vDir, surface.vNormal, material);
    shading.cDiffuse += pointLighting.cDiffuse;
    shading.cSpecular += pointLighting.cSpecular;
    #endif

    #ifdef ENABLE_DIRECTIONAL_LIGHT
  C_DirectionalLight directionalLight = GetDirectionalLight();
    C_Shading directionLighting = ApplyDirectionalLight(directionalLight, hitInfo.vPos, ray.vDir, surface.vNormal, material);
    shading.cDiffuse += directionLighting.cDiffuse;
    shading.cSpecular += directionLighting.cSpecular;
    #endif

    vec3 vDiffuseReflection = shading.cDiffuse * material.cAlbedo;          

    // swap diffuse for transmission
    vDiffuseReflection = mix(vDiffuseReflection, surface.cTransmission, material.fTransparency);    

    #ifdef ENABLE_SPECULAR
    cScene = ApplyFresnel(vDiffuseReflection , shading.cSpecular, surface.vNormal, ray.vDir, material);
    #else
    cScene = vDiffuseReflection;
    #endif
    
    return cScene;
}

vec3 GetSceneColourSecondary( const in C_Ray ray );

vec3 GetReflection( const in C_Ray ray, const in C_HitInfo hitInfo, const in C_Surface surface )
{
    #ifdef ENABLE_REFLECTIONS    
    {
        // get colour from reflected ray
        const float fSeparation    = 0.1;

        C_Ray reflectRay;
        reflectRay.vDir = reflect(ray.vDir, surface.vNormal);
        reflectRay.vOrigin = hitInfo.vPos;
        reflectRay.fLength = 16.0;
        reflectRay.fStartDistance = fSeparation / abs(dot(reflectRay.vDir, surface.vNormal));
        
        return GetSceneColourSecondary(reflectRay);      
    }
    #else
        return GetSkyGradient(reflect(ray.vDir, surface.vNormal));                              
    #endif
}

vec3 GetTransmission( const in C_Ray ray, const in C_HitInfo hitInfo, const in C_Surface surface, const in C_Material material )
{
    #ifdef ENABLE_TRANSPARENCY  
    {
        const float fSeparation = 0.05;

        // Trace until outside transparent object
        C_Ray refractRay;
        // we dont handle total internal reflection (in that case refract returns a zero length vector)
        refractRay.vDir = refract(ray.vDir, surface.vNormal, material.fRefractiveIndex);
        refractRay.vOrigin = hitInfo.vPos;
        refractRay.fLength = 16.0;
        refractRay.fStartDistance = fSeparation / abs(dot(refractRay.vDir, surface.vNormal));

    #ifdef DOUBLE_SIDED_TRANSPARENCY
    
      C_HitInfo hitInfo2;
      Raymarch(refractRay, hitInfo2, 32, kInverseTransparency);
      vec3 vNormal = GetSceneNormal(hitInfo2.vPos, kInverseTransparency);
      
      // get colour from rest of scene
      C_Ray refractRay2;
      refractRay2.vDir = refract(refractRay.vDir, vNormal, 1.0 / material.fRefractiveIndex);
      refractRay2.vOrigin = hitInfo2.vPos;
      refractRay2.fLength = 16.0;
      refractRay2.fStartDistance = 0.0;//fSeparation / abs(dot(refractRay2.vDir, vNormal));
      
      float fExtinctionDist = hitInfo2.fDistance;
      vec3 vSceneColour = GetSceneColourSecondary(refractRay2);
    
    #else
    
      vec3 vSceneColour = GetSceneColourSecondary(refractRay);                                                                        
      float fExtinctionDist = 0.5;
    
    #endif
                                
        vec3 cMaterialExtinction = material.cAlbedo;
        // extinction should really be exp(-) but this is a nice hack to get RGB
        vec3 cExtinction = (1.0 / (1.0 + (cMaterialExtinction * fExtinctionDist)));
                                
                                return vSceneColour * cExtinction;
    }
    #else
        return GetSkyGradient(reflect(ray.vDir, surface.vNormal));                              
    #endif
}

// no reflections, no transparency, used for secondary rays
vec3 GetSceneColourSecondary( const in C_Ray ray )
{
    C_HitInfo hitInfo;
    Raymarch(ray, hitInfo, 32, kNoTransparency);
                        
    vec3 cScene;

    if(hitInfo.vObjectId.x < 0.5)
    {
        cScene = GetSkyGradient(ray.vDir);
    }
    else
    {
        C_Surface surface;        
        surface.vNormal = GetSceneNormal(hitInfo.vPos, kNoTransparency);

        C_Material material = GetObjectMaterial(hitInfo);

        // use sky gradient instead of reflection
        surface.cReflection = GetSkyGradient(reflect(ray.vDir, surface.vNormal));
        
        material.fTransparency = 0.0;

        // apply lighting
        cScene = ShadeSurface(ray, hitInfo, surface, material);
    }

    ApplyAtmosphere(cScene, ray, hitInfo);

    return cScene;
}

vec3 GetSceneColourPrimary( const in C_Ray ray )
{                                                          
    C_HitInfo intersection;
    Raymarch(ray, intersection, 256, kTransparency);
                
    vec3 cScene;

    if(intersection.vObjectId.x < 0.5)
    {
        cScene = GetSkyGradient(ray.vDir);
    }
    else
    {
        C_Surface surface;
        
        surface.vNormal = GetSceneNormal(intersection.vPos, kTransparency);

        C_Material material = GetObjectMaterial(intersection);

        surface.cReflection = GetReflection(ray, intersection, surface);

        if(material.fTransparency > 0.0)
        {    
            surface.cTransmission = GetTransmission(ray, intersection, surface, material);
        }

        // apply lighting
        cScene = ShadeSurface(ray, intersection, surface, material);
    }

    ApplyAtmosphere(cScene, ray, intersection);

    return cScene;
}

float kFarClip = 30.0;

void GetCameraRay( const in vec3 vPos, const in vec3 vForwards, const in vec3 vWorldUp, out C_Ray ray)
{
    vec2 vUV = ( gl_FragCoord.xy / resolution.xy );
    vec2 vViewCoord = vUV * 2.0 - 1.0;

    float fRatio = resolution.x / resolution.y;
    vViewCoord.y /= fRatio;                          

    ray.vOrigin = vPos;

    vec3 vRight = normalize(cross(vForwards, vWorldUp));
    vec3 vUp = cross(vRight, vForwards);
        
    ray.vDir = normalize( vRight * vViewCoord.x + vUp * vViewCoord.y + vForwards); 
    ray.fStartDistance = 0.0;
    ray.fLength = kFarClip;      
}

void GetCameraRayLookat( const in vec3 vPos, const in vec3 vInterest, out C_Ray ray)
{
    vec3 vForwards = normalize(vInterest - vPos);
    vec3 vUp = vec3(0.0, 0.1, 0.0);

    GetCameraRay(vPos, vForwards, vUp, ray);
}

vec3 OrbitPoint( const in float fHeading, const in float fElevation )
{
    return vec3(sin(fHeading) * cos(fElevation), sin(fElevation), cos(fHeading) * cos(fElevation));
}

vec3 Gamma( const in vec3 cCol )
{
    return cCol * cCol;
}

vec3 Tonemap( const in vec3 cCol )
{
    // simple Reinhard tonemapping operator    
    vec3 vResult = cCol / (0.2 + cCol);

    return Gamma(vResult);
}

void main( void )
{
    C_Ray ray;
    
    float fHeading = mix(-0.7, kPI + 0.5, mouse.x);
    float fElevation = mix(1.5, -0.25, mouse.y);
    float fCameraDist = mix(4.0, 2.5, mouse.y);
    
    vec3 vCameraPos = OrbitPoint(fHeading, fElevation) * fCameraDist;
    vec3 vCameraIntrest = vec3(1.0, 0.9, 0.0);

    GetCameraRayLookat( vCameraIntrest + vCameraPos, vCameraIntrest, ray);

    vec3 cScene = GetSceneColourPrimary( ray );  

    const float fExposure = 3.0;    
    gl_FragColor = vec4( Tonemap(cScene), 1.0 );
}
</script>

    <script id="rubiks cube" type="x-shader/x-fragment">
// GLSL rubik's cube by Kabuto

#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

// Traces a single big cube (= here: layer of 3x3 small cubes)
void cubetrace(vec3 pos, vec3 dir, vec3 scale, vec3 ofs, inout vec4 hit) {
  pos *= scale;
  pos += ofs;
  dir *= scale;
  vec3 h1 = (-pos-sign(dir))/dir;
  vec3 h2 = (-pos+sign(dir))/dir;
  float h1f = max(max(h1.x,h1.y),h1.z);
  float h2f = min(min(h2.x,h2.y),h2.z);
  if (h1f < h2f && h1f < hit.w) {
    hit = vec4((pos+dir*h1f-ofs)/scale,h1f);
  }
}

// What layer to rotate in what frame
// x: rotation axis (0 to 2), y: rotation layer (0 to 2), z: rotation direction (-1 or 1)
// Math has to be that way (rounding redundantly) due to numerical precision issues
vec3 rotframe(float time) {
  time = floor(time)+.5;
  return floor(vec3(mod(time,3.),mod(floor(time/3.+.1)+.5,3.),floor(mod(time,2.))*2.-1.));
}


const int FRAMES = 32;

void main( void ) {
  vec3 pos = vec3(0.,-.21,-7.);
  vec2 uv = (gl_FragCoord.xy - resolution*.5)/resolution.y*.5;
  vec3 dir = normalize(vec3(uv,1.));

  float tf = mod(time,float(FRAMES))+1e-5;
  vec3 r = rotframe(tf);
  
  float t2 = time*.3;
  mat3 globalrot = mat3(cos(t2),0,-sin(t2),0,1,0,sin(t2),0,cos(t2));
  
  float t = -fract(tf)*3.141592653589*.5*r.z;
  mat3 rot = r.x < .5 ?
    mat3(1,0,0,0,cos(t),sin(t),0,-sin(t),cos(t))
  : r.x < 1.5 ?
    mat3(cos(t),0,-sin(t),0,1,0,sin(t),0,cos(t)) :
    mat3(cos(t),sin(t),0,-sin(t),cos(t),0,0,0,1);

  mat3 rot2 = mat3(1,0,0,0,1,0,0,0,1);

  float a = -.4;
  mat3 prot = mat3(1,0,0,0,cos(a),sin(a),0,-sin(a),cos(a))*globalrot;
  pos *= prot;
  dir *= prot;

  vec4 vhit = vec4(0,0,0,1e9);
  vec3 s = r.x < .5 ? vec3(1,0,0) : r.x < 1.5 ? vec3(0,1,0) : vec3(0,0,1);
  cubetrace(pos*(r.y==0.?rot:rot2),dir*(r.y==0.?rot:rot2),vec3(1,1,1)+s*2.,s*2.,vhit);
  cubetrace(pos*(r.y==1.?rot:rot2),dir*(r.y==1.?rot:rot2),vec3(1,1,1)+s*2.,vec3(0, 0,0),vhit);
  cubetrace(pos*(r.y==2.?rot:rot2),dir*(r.y==2.?rot:rot2),vec3(1,1,1)+s*2.,-s*2.,vhit);
  
    
    
  vec3 hit = vhit.xyz;
  
  for (int i = FRAMES-1; i >= 0; i--) {
    if (float(i)+1. < tf) {
      vec3 r = rotframe(float(i));
      hit = r.x < .5 ? hit : r.x < 1.5 ? hit.yzx : hit.zxy;
      if (abs(floor(hit.x*1.49+1.5)- r.y) < .5) hit.yz *= mat2(0,-r.z,r.z,0);
      hit = r.x < .5 ? hit : r.x < 1.5 ? hit.zxy : hit.yzx;
    }
  }
  
  
  vec3 ahit = abs(hit.xyz);
  vec3 side = sign(hit.xyz)*step(vec3(.99),ahit);
  float m = max(max(ahit.x,ahit.y),ahit.z);
  
  hit.xyz *= 3.;
  hit.xyz = abs(fract(hit.xyz*.5+.5)-.5)*2.;
  float b = max(max(hit.x,hit.y),hit.z);
  float d = min(min(hit.x,hit.y),hit.z);
  float c = hit.x+hit.y+hit.z-b-d;
  c = max(c-.7,0.);
  d = max(d-.7,0.);
  
  
  
  vec3 facecolour = max(side,vec3(0)) + (1.+min(side,vec3(0)))*dot(-min(side,vec3(0)),vec3(1));
  vec3 colour = vec3(step(sqrt(c*c+d*d),.17)*step(.99,m))*facecolour+step(m,.1);
  colour += 1.-min(1.,float(FRAMES)-tf);
  
  gl_FragColor = vec4( colour, 1.0 );

}
</script>

    <script id="cloud" type="x-shader/x-fragment">
#ifdef GL_ES
precision mediump float;
#endif

#extension GL_OES_standard_derivatives : enable

uniform float time;
//uniform vec2 mouse;
uniform vec2 resolution;

const float cloudscale = 1.1;
const float speed = 0.01;
const float clouddark = 0.5;
const float cloudlight = 0.3;
const float cloudcover = 0.2;
const float cloudalpha = 8.0;
const float skytint = 0.5;
const vec3 skycolour1 = vec3(0.2, 0.4, 0.6);
const vec3 skycolour2 = vec3(0.4, 0.7, 1.0);

const mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );


vec2 hash( vec2 p ) {
  p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));
  return -1.0 + 2.0*fract(sin(p)*43758.5453123);
}

float noise( in vec2 p ) {
    const float K1 = 0.366025404; // (sqrt(3)-1)/2;
    const float K2 = 0.211324865; // (3-sqrt(3))/6;
    
    vec2 i = floor(p + (p.x+p.y)*K1);
    vec2 a = p - i + (i.x+i.y)*K2;
    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));
    vec2 b = a - o + K2;
    vec2 c = a - 1.0 + 2.0*K2;
    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );
    vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));
    
    return dot(n, vec3(70.0));
}

float fbm(vec2 n) {
  float total = 0.0, amplitude = 0.1;
  for (int i = 0; i < 7; i++) {
    total += noise(n) * amplitude;
    n = m * n;
    amplitude *= 0.4;
  }
  return total;
}

// -----------------------------------------------

void main() {

    vec2 p = gl_FragCoord.xy / (resolution.xy);
    vec2 uv = p*vec2(resolution.x / resolution.y, 0.9);
    float localTime = time * speed;
    float q = fbm(uv * cloudscale * 0.1);

    //ridged noise shape
  float r = 0.0;
  uv *= cloudscale;
    uv -= q - localTime;
    float weight = 0.8;
    for (int i=0; i<8; i++){
    r += abs(weight*noise( uv ));
        uv = m*uv + localTime;
    weight *= 0.7;
    }

    //noise shape
  float f = 0.0;
    uv = p*vec2(resolution.x/resolution.y,1.0);
  uv *= cloudscale;
    uv -= q - localTime;
    weight = 0.7;
    for (int i=0; i<8; i++){
    f += weight*noise( uv );
        uv = m*uv + localTime;
    weight *= 0.6;
    }

    f *= r + f;

    //noise colour
    float c = 0.0;
   localTime = time * speed * 2.0;
    uv = p*vec2(resolution.x/resolution.y,1.0);
  uv *= cloudscale*2.0;
    uv -= q - localTime;
    weight = 0.4;
    for (int i=0; i<7; i++){
    c += weight*noise( uv );
        uv = m*uv + localTime;
    weight *= 0.6;
    }

    //noise ridge colour
    float c1 = 0.0;
   localTime = time * speed * 3.0;
    uv = p*vec2(resolution.x/resolution.y,1.0);
  uv *= cloudscale*3.0;
    uv -= q - localTime;
    weight = 0.4;
    for (int i=0; i<7; i++){
    c1 += abs(weight*noise( uv ));
        uv = m*uv + localTime;
    weight *= 0.6;
    }

    c += c1;

    vec3 skycolour = mix(skycolour2, skycolour1, p.y);
    vec3 cloudcolour = vec3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight*c), 0.0, 1.0);

    f = cloudcover + cloudalpha*f*r;

    vec3 result = mix(skycolour, clamp(skytint * skycolour + cloudcolour, 0.0, 1.0), clamp(f + c, 0.0, 1.0));

  gl_FragColor = vec4( result, 1.0 );
}
</script>

    <script id="big tree" type="x-shader/x-fragment">

#ifdef GL_ES
precision mediump float;
#endif

#extension GL_OES_standard_derivatives : enable

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;
varying vec2 surfacePosition;

const float tri_a = tan(3.14/3.);
bool tri(vec2 p, float k){
  return p.y < p.x * tri_a + k && p.y < p.x * -tri_a + k && p.y > -k;
}

void main( void ) {
  vec2 p = surfacePosition;
  float z = 1.0;
  vec3 color = vec3(.4+.2*float(mod(floor(p.x*32.), 2.)==mod(floor(p.y*32.), 2.)));
  
  #define R2(T) mat2(cos(T), -sin(T), sin(T), cos(T))
  
  p = surfacePosition+vec2(0,.5);
  for(int i = 0; i <= 15; i += 1){
    if(tri(p, 0.04)){
      color = vec3(0.4,0.3,0.0);
      z += 0.125;
    }
    p.y -= 0.03;
    p *= R2((mouse.x-.5)*0.1*cos(time+float(i))*cos(time+float(i)));
  }
  p.y += 0.1;
  for(int i = 0; i <= 4; i += 1){
    p *= R2(-.93*2.*3.14159*sign(p.x));
    p.y += -0.09;
    if(tri(p*vec2(1.5,1), 0.06)){
      color = vec3(0.4,0.3,0.0);
      z += 0.25;
    }
    p *= 1.1*R2((mouse.x-.5)*0.4*cos(time+float(i))*cos(time+float(i)));
  }
  //p *= R2(atan(p.x, p.y)*12.);
  for(int i = 0; i <= 7; i += 1){
    if(tri(p, 0.125*abs(length(p*5.)-.5))){
      color = vec3(0.1+z*0.1,0.3,0.1);
      z += 0.1;
      z *= 1.2;
    }
    p.y -= 0.033;
    p *= 0.9*R2(-.95*2.*3.14159*sign(p.x));
    p *= R2((mouse.x-.5)*0.3*cos(time+float(i))*cos(time+float(i)));
  }
  
  gl_FragColor = vec4( color*z, 1.0 );
}           
</script>

    <script id="colorful voronoi" type="x-shader/x-fragment">


                    // Colorful Voronoi
                    // By: Brandon Fogerty
                    // bfogerty at gmail dot com
                    // xdpixel.com

                    #ifdef GL_ES
                    precision mediump float;
                    #endif

                    uniform float time;
                    uniform vec2 mouse;
                    uniform vec2 resolution;

                    vec2 hash(vec2 p)
                    {
                        mat2 m = mat2(  13.85, 47.77,
                                        99.41, 88.48
                                    );

                        return fract(sin(m*p) * 46738.29);
                    }

                    float voronoi(vec2 p)
                    {
                        vec2 g = floor(p);
                        vec2 f = fract(p);

                        float distanceToClosestFeaturePoint = 1.0;
                        for(int y = -1; y <= 1; y++)
                        {
                            for(int x = -1; x <= 1; x++)
                            {
                                vec2 latticePoint = vec2(x, y);
                                float currentDistance = distance(latticePoint + hash(g+latticePoint), f);
                                distanceToClosestFeaturePoint = min(distanceToClosestFeaturePoint, currentDistance);
                            }
                        }

                        return distanceToClosestFeaturePoint;
                    }

                    void main( void )
                    {
                        vec2 uv = ( gl_FragCoord.xy / resolution.xy ) * 2.0 - 1.0;
                        uv.x *= resolution.x / resolution.y;

                        float offset = voronoi(uv*10.0 + vec2(time));
                        float t = 1.0/abs(((uv.x + sin(uv.y + time)) + offset) * 30.0);

                        float r = voronoi( uv * 1.0 ) * 10.0;
                        vec3 finalColor = vec3(10.0 * uv.y, 2.0, 1.0 * r) * t;
                        
                        gl_FragColor = vec4(finalColor, 1.0 );
                    }

</script>

    <script id="small flower" type="x-shader/x-fragment">
                    #ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

#define pi 3.1415926535897932384626433832795
#define flyCount 30.


float testFuncFloor(float v){

    const float amplitude=1.;
    const float t=pi*2.;
    float k=4.*amplitude/t;
    float r=mod( v  ,t);
    float d=floor(v /(.5* t) );
    
  return mix(k* r-amplitude ,  amplitude*3.-k* r ,mod(d,2.)  );
}

float getRad(vec2 q){
   return atan(q.y,q.x); 
}

vec2 noise(vec2 tc){
    //return (2.*texture2D(iChannel0, tc).xy-1.).xy;
    return vec2(fract(sin(tc.x) ),fract(sin(tc.y) ) );
}

float firefly(vec2 p,float size){
    
  //return smoothstep(0.,size,dot(p,p)*200. );
  return smoothstep(0.,size,length(p) );

}

const float pow=1.;
const float flySpeed=0.1;


vec3 RetroCrtEffect(vec3 rgb, vec2 texCoord, vec2 resolution)
{
    const float blendFactor = 0.1; // range (0.0, 1.0]
    float artifact = cos(texCoord.y * resolution.y * 2.0) * 0.5 + 0.5;
    return max(rgb - vec3(artifact * blendFactor), vec3(0.0));
}

void main( void ) {

    float pow=1.;
    const float duration=1.;
    float t=duration*(1.+sin(3.* time ) );
  vec2 p= gl_FragCoord.xy / resolution.xy;
   
  float ratio= resolution.y/resolution.x;
    
     vec2 uv=p;
    uv.y*=ratio;
    
    
    vec2 flowerP=vec2(.618,0.518);
    vec2 q=p-flowerP-vec2( pow*.008*cos(3.*time) ,pow*.008*sin(3.*time) ) ;
    vec2 rootP=p-+flowerP-vec2( pow*.02*cos(3.*time)*p.y ,-0.48+pow*.008*sin(3.*time) );
   
  q.y*=ratio;
  
    //sky
    vec3 col=mix( vec3(0.1,0.6,0.5), vec3(0.2,0.1,0.2), sqrt(p.y)*.6 );
    

    //draw stem 
    float width=0.01;
    float h=.5;
    float w=.0005;
    col=mix(vec3(.5,.7,.4),col, 1.- (1.- smoothstep(h,h+width, abs(rootP.y ) )  ) * (1.- smoothstep(w,w+width, abs(rootP.x-0.1*sin(4.*rootP.y+pi*.35) ) )  ) );
    
    //draw flower 
    vec3 flowerCol=mix(vec3(.7,.7,.2),vec3(.7,.9,.7), smoothstep( .0,1.,length(q)*10. ) ) ;

    const float edge=.02;
    float r= .1+0.05*( testFuncFloor( getRad( q ) *7.  + 2.*q.x*(t-duration)  )  );

  col=mix(flowerCol,col, smoothstep(r,r+edge,  length( q )  ) );
    
  //draw buds
    float r1=0.;
    r1=.04;
    vec3 budCol=mix (vec3(.3,.4,0.),vec3(.9,.8,0.), length(q)*10. );
  col=mix(budCol,col, smoothstep(r1,r1+0.01,  length( q )  ) );
    
    //draw firefly
  //vec3 flyCol=mix (vec3(.1,.4,0.1),vec3(.1,1.,1.), length(q)*10. );
  
    for (float i=0.;i<flyCount;i++){
    
        float seed=i/flyCount;
  float seed2=fract(i/flyCount*5.);
        float t1=1.*(1.+sin(noise(vec2(seed) ).x* time ) );
      vec2 fireflyP=uv- 
        vec2(noise(vec2(seed2) ).x+noise(vec2(seed2) ).x*t1*flySpeed,
       noise(vec2(seed) ).y+noise(vec2(seed) ).y*t1*flySpeed);
      
    float fly= firefly( fireflyP,.002+.008*seed );
      vec3 flyCol=mix(vec3(0.1,0.9,0.1)*t1,vec3(0.), fly );
      col+=flyCol;
    }

    //vec3 color = RetroCrtEffect(col, uv, resolution.xy);
    vec3 color = col;

  
    gl_FragColor= vec4(color, 1.0);
  /*
  vec2 position = ( gl_FragCoord.xy / resolution.xy ) + mouse / 4.0;

  float color = 0.0;
  color += sin( position.x * cos( time / 15.0 ) * 80.0 ) + cos( position.y * cos( time / 15.0 ) * 10.0 );
  color += sin( position.y * sin( time / 10.0 ) * 40.0 ) + cos( position.x * sin( time / 25.0 ) * 40.0 );
  color += sin( position.x * sin( time / 5.0 ) * 10.0 ) + sin( position.y * sin( time / 35.0 ) * 80.0 );
  color *= sin( time / 10.0 ) * 0.5;

  gl_FragColor = vec4( vec3( color, color * 0.5, sin( color + time / 3.0 ) * 0.75 ), 1.0 );
  */
}

    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">

      #ifdef GL_ES
      precision mediump float;
      #endif

      uniform vec2 resolution;
      uniform sampler2D texture;

      void main() {

        vec2 uv = gl_FragCoord.xy / resolution.xy;
        gl_FragColor = texture2D( texture, uv );

      }

    </script>

    <script id="vertexShader" type="x-shader/x-vertex">

      attribute vec3 position;

      void main() {

        gl_Position = vec4( position, 1.0 );

      }

    </script>

    <script id="surfaceVertexShader" type="x-shader/x-vertex">

      attribute vec3 position;
      attribute vec2 surfacePosAttrib;
      varying vec2 surfacePosition;

      void main() {

        surfacePosition = surfacePosAttrib;
        gl_Position = vec4( position, 1.0 );

      }

    </script>

    <script>

      initialize_helper();

      var compressor=initialize_compressor();

      if ( !window.requestAnimationFrame ) {

        window.requestAnimationFrame = ( function() {

          return window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            window.oRequestAnimationFrame ||
            window.msRequestAnimationFrame ||
            function ( callback, element ) {

              window.setTimeout( callback, 1000 / 60 );

            };

        } )();

      }

      // Get older browsers safely through init code, so users can read the
      // message about how to download newer browsers.
      if (!Date.now) {
        Date.now = function() {
          return +new Date();
        };
      }

      // Greetings to Iq/RGBA! ;)

      var quality = 2, quality_levels = [ 0.5, 1, 2, 4, 8 ];
      var toolbar, compileButton, fullscreenButton, compileTimer, errorLines = [];
      var code, canvas, gl, buffer, currentProgram, vertexPosition, screenVertexPosition, panButton,
      parameters = { startTime: Date.now(), time: 0, mouseX: 0.5, mouseY: 0.5, screenWidth: 0, screenHeight: 0 },
      surface = { centerX: 0, centerY: 0, width: 1, height: 1, isPanning: false, isZooming: false, lastX: 0, lastY: 0 },
      frontTarget, backTarget, screenProgram, getWebGL, resizer = {}, compileOnChangeCode = true;

      init();
      if (gl) { animate(); }

      function init() {

        if (!document.addEventListener) {
          document.location = 'http://get.webgl.org/';
          return;
        }

        canvas = document.createElement( 'canvas' );
        canvas.style.display = 'block';
        document.body.appendChild( canvas );

        compileButton = document.createElement( 'button' );
        compileButton.textContent = 'compile';
        compileButton.addEventListener( 'click', function ( event ) {

          compile();

        }, false );
        // toolbar.appendChild( compileButton );

        // from helper.js
        add_server_buttons();

        // Initialise WebGL

        try {

          gl = canvas.getContext( 'experimental-webgl', { preserveDrawingBuffer: true } );

        } catch( error ) { }

        if ( !gl ) {

          alert("WebGL not supported, but code will be shown.");

        } else {
          
          // enable dFdx, dFdy, fwidth
          gl.getExtension('OES_standard_derivatives');

          // Create vertex buffer (2 triangles)

          buffer = gl.createBuffer();
          gl.bindBuffer( gl.ARRAY_BUFFER, buffer );
          gl.bufferData( gl.ARRAY_BUFFER, new Float32Array( [ - 1.0, - 1.0, 1.0, - 1.0, - 1.0, 1.0, 1.0, - 1.0, 1.0, 1.0, - 1.0, 1.0 ] ), gl.STATIC_DRAW );

          // Create surface buffer (coordinates at screen corners)

          surface.buffer = gl.createBuffer();
        }

        // initialize code editor
        code = CodeMirror(document.body, {
          lineNumbers: true,
          matchBrackets: true,
          indentWithTabs: true,
          tabSize: 8,
          indentUnit: 8,
          mode: "text/x-glsl",
          onChange: function () {
            if (compileOnChangeCode) {
              clearTimeout(compileTimer);
              compileTimer = setTimeout(compile, 500);
            }
          }
        });
        code.getWrapperElement().style.display = '';

        resizer.offsetMouseX = 0;
        resizer.offsetMouseY = 0;
        resizer.isResizing = false;
        resizer.currentWidth = 100;
        resizer.currentHeight = 100;
        resizer.minWidth = 100;
        resizer.minHeight = 100;
        resizer.maxWidth = 100;
        resizer.maxHeight = 100;
        resizer.element = document.createElement( 'div' );
        resizer.element.className = 'resizer';
        code.getWrapperElement().appendChild(resizer.element);

        resizer.element.addEventListener( 'mousedown', function ( event ) {
          if (event.button !== 2) {
            resizer.offsetMouseX = event.clientX - resizer.currentWidth;
            resizer.offsetMouseY = event.clientY - resizer.currentHeight;
            resizer.isResizing = true;
            event.preventDefault();
          }
        }, false );
        
        if (gl) {

          var surfaceMouseDown = function ( event ) {

            if (event.shiftKey) {
              resetSurface();
            }

            if (event.button === 0) {
              surface.isPanning = true;
              document.body.style.cursor = 'move';
            } else {
              surface.isZooming = true;
              document.body.style.cursor = 'se-resize';
              // panButton.style.cursor = 'se-resize';
            }

            surface.lastX = event.clientX;
            surface.lastY = event.clientY;
            event.preventDefault();

          };

          var noContextMenu = function ( event ) {

            event.preventDefault();

          };

          canvas.addEventListener( 'mousedown', surfaceMouseDown, false );
          // panButton.addEventListener( 'mousedown', surfaceMouseDown, false );

          canvas.addEventListener( 'contextmenu', noContextMenu, false);
          // panButton.addEventListener( 'contextmenu', noContextMenu, false);
        }
        
        var clientXLast, clientYLast;

        document.addEventListener( 'mousemove', function ( event ) {

          var clientX = event.clientX;
          var clientY = event.clientY;

          if (clientXLast == clientX && clientYLast == clientY)
            return;

          clientXLast = clientX;
          clientYLast = clientY;

          // stopHideUI();

          var codeElement, dx, dy;
          
          parameters.mouseX = clientX / window.innerWidth;
          parameters.mouseY = 1 - clientY / window.innerHeight;
            
          if (resizer.isResizing) {

            resizer.currentWidth = Math.max(Math.min(clientX - resizer.offsetMouseX, resizer.maxWidth), resizer.minWidth);
            resizer.currentHeight = Math.max(Math.min(clientY - resizer.offsetMouseY, resizer.maxHeight), resizer.minWidth);
            codeElement = code.getWrapperElement();
            codeElement.style.width = resizer.currentWidth + 'px';
            codeElement.style.height = resizer.currentHeight + 'px';
            code.refresh();
            event.preventDefault();

          } else if (surface.isPanning) {

            dx = clientX - surface.lastX;
            dy = clientY - surface.lastY;
            surface.centerX -= dx * surface.width / window.innerWidth;
            surface.centerY += dy * surface.height / window.innerHeight;
            surface.lastX = clientX;
            surface.lastY = clientY;
            computeSurfaceCorners();
            event.preventDefault();

          } else if (surface.isZooming) {

            dx = clientX - surface.lastX;
            dy = clientY - surface.lastY;
            surface.height *= Math.pow(0.997, dx + dy);
            surface.lastX = clientX;
            surface.lastY = clientY;
            computeSurfaceCorners();
            event.preventDefault();

          }
        }, false );

        function settleDown ( event ) {
          resizer.isResizing = surface.isPanning = surface.isZooming = false;
          document.body.style.cursor = 'default';
          // panButton.style.cursor = 'move';
        }

        function mouseLeave(event) {
          settleDown(event);

          if (!isCodeVisible())
            startHideUITimer();
        }

        document.addEventListener( 'mouseup', settleDown, false );
        document.addEventListener( 'mouseleave', mouseLeave, false );

        onWindowResize();
        window.addEventListener( 'resize', onWindowResize, false );
        load_url_code();

        compileScreenProgram();

      }

      function isCodeVisible() {
        return code && code.getWrapperElement().style.display !== 'none';
      }

      var hideUITimer;
      var isUIHidden = false;

      function startHideUITimer () {

        stopHideUITimer();
        if (!isUIHidden && !isCodeVisible())
          hideUITimer = window.setTimeout(onHideUITimer, 1000 * 5 );

        function onHideUITimer() {

          stopHideUITimer();
          if (!isUIHidden && !isCodeVisible()) {

            isUIHidden = true;
            // toolbar.style.display = 'none';
            document.body.style.cursor = 'none';
          }
        }

        function stopHideUITimer () {

          if (hideUITimer) {

            window.clearTimeout(hideUITimer);
            hideUITimer = 0;
          }
        }
      }

      function stopHideUI () {

        if (isUIHidden) {

          isUIHidden = false;
          // toolbar.style.display = '';
          document.body.style.cursor = '';
        }
        startHideUITimer();
      }


      function computeSurfaceCorners() {

        if (gl) {

          surface.width = surface.height * parameters.screenWidth / parameters.screenHeight;
          
          var halfWidth = surface.width * 0.5, halfHeight = surface.height * 0.5;
          
          gl.bindBuffer( gl.ARRAY_BUFFER, surface.buffer );
          gl.bufferData( gl.ARRAY_BUFFER, new Float32Array( [
            surface.centerX - halfWidth, surface.centerY - halfHeight,
            surface.centerX + halfWidth, surface.centerY - halfHeight,
            surface.centerX - halfWidth, surface.centerY + halfHeight,
            surface.centerX + halfWidth, surface.centerY - halfHeight,
            surface.centerX + halfWidth, surface.centerY + halfHeight,
            surface.centerX - halfWidth, surface.centerY + halfHeight ] ), gl.STATIC_DRAW );

        }

      }

      function resetSurface() {

        surface.centerX = surface.centerY = 0;
        surface.height = 1;
        computeSurfaceCorners();

      }

      function compile() {
      
        if (!gl) {
        
          if (!getWebGL) {
          
            getWebGL = true;
            compileButton.addEventListener( 'click', function ( event ) {

              document.location = 'http://get.webgl.org/';

            }, false );
            compileButton.title = 'http://get.webgl.org/';
            compileButton.style.color = '#ff0000';
            compileButton.textContent = 'WebGL not supported!';
            set_save_button('hidden');
            
          }
          return;
          
        }

        var program = gl.createProgram();
        var fragment = code.getValue();
        var vertex = document.getElementById( 'surfaceVertexShader' ).textContent;

        var vs = createShader( vertex, gl.VERTEX_SHADER );
        var fs = createShader( fragment, gl.FRAGMENT_SHADER );

        if ( vs == null || fs == null ) return null;

        gl.attachShader( program, vs );
        gl.attachShader( program, fs );

        gl.deleteShader( vs );
        gl.deleteShader( fs );

        gl.linkProgram( program );

        if ( !gl.getProgramParameter( program, gl.LINK_STATUS ) ) {

          var error = gl.getProgramInfoLog( program );

          compileButton.title = error;
          console.error( error );

          console.error( 'VALIDATE_STATUS: ' + gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'ERROR: ' + gl.getError() );
          compileButton.style.color = '#ff0000';
          compileButton.textContent = 'compiled with errors';

          set_save_button('hidden');

          return;

        }

        if ( currentProgram ) {

          gl.deleteProgram( currentProgram );
          setURL( fragment );

        }

        currentProgram = program;

        compileButton.style.color = '#00ff00';
        compileButton.textContent = 'compiled successfully';

        set_save_button('visible');

        // panButton.style.display = (fragment.indexOf('varying vec2 surfacePosition;') >= 0) ? 'inline' : 'none';

        // Cache uniforms

        cacheUniformLocation( program, 'time' );
        cacheUniformLocation( program, 'mouse' );
        cacheUniformLocation( program, 'resolution' );
        cacheUniformLocation( program, 'backbuffer' );
        cacheUniformLocation( program, 'surfaceSize' );

        // Load program into GPU

        gl.useProgram( currentProgram );

        // Set up buffers

        surface.positionAttribute = gl.getAttribLocation(currentProgram, "surfacePosAttrib");
        gl.enableVertexAttribArray(surface.positionAttribute);

        vertexPosition = gl.getAttribLocation(currentProgram, "position");
        gl.enableVertexAttribArray( vertexPosition );

      }

      function compileScreenProgram() {
      
        if (!gl) { return; }

        var program = gl.createProgram();
        var fragment = document.getElementById( 'fragmentShader' ).textContent;
        var vertex = document.getElementById( 'vertexShader' ).textContent;

        var vs = createShader( vertex, gl.VERTEX_SHADER );
        var fs = createShader( fragment, gl.FRAGMENT_SHADER );

        gl.attachShader( program, vs );
        gl.attachShader( program, fs );

        gl.deleteShader( vs );
        gl.deleteShader( fs );

        gl.linkProgram( program );

        if ( !gl.getProgramParameter( program, gl.LINK_STATUS ) ) {

          console.error( 'VALIDATE_STATUS: ' + gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'ERROR: ' + gl.getError() );

          return;

        }

        screenProgram = program;

        gl.useProgram( screenProgram );

        cacheUniformLocation( program, 'resolution' );
        cacheUniformLocation( program, 'texture' );

        screenVertexPosition = gl.getAttribLocation(screenProgram, "position");
        gl.enableVertexAttribArray( screenVertexPosition );

      }

      function cacheUniformLocation( program, label ) {

        if ( program.uniformsCache === undefined ) {

          program.uniformsCache = {};

        }

        program.uniformsCache[ label ] = gl.getUniformLocation( program, label );

      }

      //

      function createTarget( width, height ) {

        var target = {};

        target.framebuffer = gl.createFramebuffer();
        target.renderbuffer = gl.createRenderbuffer();
        target.texture = gl.createTexture();

        // set up framebuffer

        gl.bindTexture( gl.TEXTURE_2D, target.texture );
        gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );

        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );

        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

        gl.bindFramebuffer( gl.FRAMEBUFFER, target.framebuffer );
        gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0 );

        // set up renderbuffer

        gl.bindRenderbuffer( gl.RENDERBUFFER, target.renderbuffer );

        gl.renderbufferStorage( gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height );
        gl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, target.renderbuffer );

        // clean up

        gl.bindTexture( gl.TEXTURE_2D, null );
        gl.bindRenderbuffer( gl.RENDERBUFFER, null );
        gl.bindFramebuffer( gl.FRAMEBUFFER, null);

        return target;

      }

      function createRenderTargets() {

        frontTarget = createTarget( parameters.screenWidth, parameters.screenHeight );
        backTarget = createTarget( parameters.screenWidth, parameters.screenHeight );

      }

      //

      var dummyFunction = function() {};


      //
      
      function htmlEncode(str){

        return String(str)
          .replace(/&/g, '&amp;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;');

      }

      //

      function createShader( src, type ) {
      
        var shader = gl.createShader( type );
        var line, lineNum, lineError, index = 0, indexEnd;

        while (errorLines.length > 0) {
          line = errorLines.pop();
          code.setLineClass(line, null);
          code.clearMarker(line);
        }

        gl.shaderSource( shader, src );
        gl.compileShader( shader );

        compileButton.title = '';

        if ( !gl.getShaderParameter( shader, gl.COMPILE_STATUS ) ) {

          var error = gl.getShaderInfoLog( shader );
          
          // Remove trailing linefeed, for FireFox's benefit.
          while ((error.length > 1) && (error.charCodeAt(error.length - 1) < 32)) {
            error = error.substring(0, error.length - 1);
          }

          compileButton.title = error;
          console.error( error );

          compileButton.style.color = '#ff0000';
          compileButton.textContent = 'compiled with errors';

          set_save_button('hidden');

          while (index >= 0) {
            index = error.indexOf("ERROR: 0:", index);
            if (index < 0) { break; }
            index += 9;
            indexEnd = error.indexOf(':', index);
            if (indexEnd > index) {
              lineNum = parseInt(error.substring(index, indexEnd));
              if ((!isNaN(lineNum)) && (lineNum > 0)) {
                index = indexEnd + 1;
                indexEnd = error.indexOf("ERROR: 0:", index);
                lineError = htmlEncode((indexEnd > index) ? error.substring(index, indexEnd) : error.substring(index));
                line = code.setMarker(lineNum - 1, '<abbr title="' + lineError + '">' + lineNum + '</abbr>', "errorMarker");
                code.setLineClass(line, "errorLine");
                errorLines.push(line);
              }
            }
          }

          return null;

        }

        return shader;

      }

      //

      function onWindowResize( event ) {

        var isMaxWidth = ((resizer.currentWidth === resizer.maxWidth) || (resizer.currentWidth === resizer.minWidth)),
          isMaxHeight = ((resizer.currentHeight === resizer.maxHeight) || (resizer.currentHeight === resizer.minHeight));

        // toolbar.style.width = window.innerWidth - 47 + 'px';

        resizer.isResizing = false;
        resizer.maxWidth = window.innerWidth - 75;
        resizer.maxHeight = window.innerHeight - 125;
        if (isMaxWidth || (resizer.currentWidth > resizer.maxWidth)) {
          resizer.currentWidth = resizer.maxWidth;
        }
        if (isMaxHeight || (resizer.currentHeight > resizer.maxHeight)) {
          resizer.currentHeight = resizer.maxHeight;
        }
        if (resizer.currentWidth < resizer.minWidth) { resizer.currentWidth = resizer.minWidth; }
        if (resizer.currentHeight < resizer.minHeight) { resizer.currentHeight = resizer.minHeight; }

        code.getWrapperElement().style.top = '75px';
        code.getWrapperElement().style.left = '25px';
        code.getWrapperElement().style.width = resizer.currentWidth + 'px';
        code.getWrapperElement().style.height = resizer.currentHeight + 'px';

        canvas.width = window.innerWidth / quality;
        canvas.height = window.innerHeight / quality;

        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';

        parameters.screenWidth = canvas.width;
        parameters.screenHeight = canvas.height;

        computeSurfaceCorners();

        if (gl) {
        
          gl.viewport( 0, 0, canvas.width, canvas.height );

          createRenderTargets();
          
        }
      }

      //

      function animate() {

        requestAnimationFrame( animate );
        render();

      }

      function render() {

        if ( !currentProgram ) return;

        parameters.time = Date.now() - parameters.startTime;

        // Set uniforms for custom shader

        gl.useProgram( currentProgram );

        gl.uniform1f( currentProgram.uniformsCache[ 'time' ], parameters.time / 1000 );
        gl.uniform2f( currentProgram.uniformsCache[ 'mouse' ], parameters.mouseX, parameters.mouseY );
        gl.uniform2f( currentProgram.uniformsCache[ 'resolution' ], parameters.screenWidth, parameters.screenHeight );
        gl.uniform1i( currentProgram.uniformsCache[ 'backbuffer' ], 0 );
        gl.uniform2f( currentProgram.uniformsCache[ 'surfaceSize' ], surface.width, surface.height );

        gl.bindBuffer( gl.ARRAY_BUFFER, surface.buffer );
        gl.vertexAttribPointer( surface.positionAttribute, 2, gl.FLOAT, false, 0, 0 );
        
        gl.bindBuffer( gl.ARRAY_BUFFER, buffer );
        gl.vertexAttribPointer( vertexPosition, 2, gl.FLOAT, false, 0, 0 );

        gl.activeTexture( gl.TEXTURE0 );
        gl.bindTexture( gl.TEXTURE_2D, backTarget.texture );

        // Render custom shader to front buffer

        gl.bindFramebuffer( gl.FRAMEBUFFER, frontTarget.framebuffer );

        gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );
        gl.drawArrays( gl.TRIANGLES, 0, 6 );

        // Set uniforms for screen shader

        gl.useProgram( screenProgram );

        gl.uniform2f( screenProgram.uniformsCache[ 'resolution' ], parameters.screenWidth, parameters.screenHeight );
        gl.uniform1i( screenProgram.uniformsCache[ 'texture' ], 1 );

        gl.bindBuffer( gl.ARRAY_BUFFER, buffer );
        gl.vertexAttribPointer( screenVertexPosition, 2, gl.FLOAT, false, 0, 0 );
        
        gl.activeTexture( gl.TEXTURE1 );
        gl.bindTexture( gl.TEXTURE_2D, frontTarget.texture );

        // Render front buffer to screen

        gl.bindFramebuffer( gl.FRAMEBUFFER, null );

        gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );
        gl.drawArrays( gl.TRIANGLES, 0, 6 );

        // Swap buffers

        var tmp = frontTarget;
        frontTarget = backTarget;
        backTarget = tmp;



      }
      code.getWrapperElement().style.display = 'none';
    </script><canvas style="display: block; width: 583px; height: 682px;" width="291" height="341"></canvas><div style="position: absolute; top: -125px; left: 25px; width: 536px;"><div style="float: right;"><button title="Pan: left-drag, Zoom: right-drag. Use &#39;hide code&#39; for a large pan/zoom area." style="cursor: move; display: inline;">pan/zoom</button><button title="Press F11 to enter or leave fullscreen mode">fullscreen</button><a href="http://www.glslsandbox.com/">gallery</a></div>

<div style="position: fixed;top :0px;left:80px;right:0px;bottom:0px;font:20px 宋体;word-spacing:direction:rtl;overflow:auto;rgba(255,255,255,0.15);text-align:left;">
<!--changeTag-->
<body>
<section id="吴-晓" class="level1">
<h1>吴 晓</h1>
<section id="图形工程师" class="level2">
<h2>图形工程师</h2>
<ul>
<li>电话: <a href="tel://86-15861657693">86-15861657693</a></li>
<li>邮件: <a href="mailto:tinysilk@hotmail.com">tinysilk@hotmail.com</a></li>
<li>博客（墙外）: <a href="http://tinyslik.github.io">tinyslik.github.io</a></li>
<li>博客（墙内）: <a href="http://tinyslik.coding.me">tinyslik.coding.me</a></li>
<li>Github: <a href="http://github.com/TinySlik">TinySlik</a></li>
</ul>
<div align="center">
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAAEtCAIAAADCxLhMAAAAAXNSR0IArs4c6QAAAAlwSFlzAAAuIwAALiMBeKU/dgAAEV5pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDUuNC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWZFWD0iaHR0cDovL2NpcGEuanAvZXhpZi8xLjAvIgogICAgICAgICAgICB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmF1eD0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC9hdXgvIgogICAgICAgICAgICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgICAgICAgICAgIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIj4KICAgICAgICAgPGV4aWY6U2NlbmVUeXBlPjE8L2V4aWY6U2NlbmVUeXBlPgogICAgICAgICA8ZXhpZjpTdWJzZWNUaW1lRGlnaXRpemVkPjAwPC9leGlmOlN1YnNlY1RpbWVEaWdpdGl6ZWQ+CiAgICAgICAgIDxleGlmOklTT1NwZWVkUmF0aW5ncz4KICAgICAgICAgICAgPHJkZjpTZXE+CiAgICAgICAgICAgICAgIDxyZGY6bGk+MjAwPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC9leGlmOklTT1NwZWVkUmF0aW5ncz4KICAgICAgICAgPGV4aWY6Rmxhc2ggcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8ZXhpZjpGdW5jdGlvbj5GYWxzZTwvZXhpZjpGdW5jdGlvbj4KICAgICAgICAgICAgPGV4aWY6RmlyZWQ+RmFsc2U8L2V4aWY6RmlyZWQ+CiAgICAgICAgICAgIDxleGlmOlJldHVybj4wPC9leGlmOlJldHVybj4KICAgICAgICAgICAgPGV4aWY6TW9kZT4wPC9leGlmOk1vZGU+CiAgICAgICAgICAgIDxleGlmOlJlZEV5ZU1vZGU+RmFsc2U8L2V4aWY6UmVkRXllTW9kZT4KICAgICAgICAgPC9leGlmOkZsYXNoPgogICAgICAgICA8ZXhpZjpVc2VyQ29tbWVudD4KICAgICAgICAgICAgPHJkZjpBbHQ+CiAgICAgICAgICAgICAgIDxyZGY6bGkgeG1sOmxhbmc9IngtZGVmYXVsdCI+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOkFsdD4KICAgICAgICAgPC9leGlmOlVzZXJDb21tZW50PgogICAgICAgICA8ZXhpZjpDb250cmFzdD4wPC9leGlmOkNvbnRyYXN0PgogICAgICAgICA8ZXhpZjpDb21wcmVzc2VkQml0c1BlclBpeGVsPjQvMTwvZXhpZjpDb21wcmVzc2VkQml0c1BlclBpeGVsPgogICAgICAgICA8ZXhpZjpHYWluQ29udHJvbD4wPC9leGlmOkdhaW5Db250cm9sPgogICAgICAgICA8ZXhpZjpTdWJzZWNUaW1lT3JpZ2luYWw+MDA8L2V4aWY6U3Vic2VjVGltZU9yaWdpbmFsPgogICAgICAgICA8ZXhpZjpEaWdpdGFsWm9vbVJhdGlvPjEvMTwvZXhpZjpEaWdpdGFsWm9vbVJhdGlvPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+MzAxPC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6Q3VzdG9tUmVuZGVyZWQ+MDwvZXhpZjpDdXN0b21SZW5kZXJlZD4KICAgICAgICAgPGV4aWY6TWV0ZXJpbmdNb2RlPjU8L2V4aWY6TWV0ZXJpbmdNb2RlPgogICAgICAgICA8ZXhpZjpQaXhlbFhEaW1lbnNpb24+MjAwPC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6U3Vic2VjVGltZT4wMDwvZXhpZjpTdWJzZWNUaW1lPgogICAgICAgICA8ZXhpZjpTY2VuZUNhcHR1cmVUeXBlPjA8L2V4aWY6U2NlbmVDYXB0dXJlVHlwZT4KICAgICAgICAgPGV4aWY6Rm9jYWxMZW5JbjM1bW1GaWxtPjc4PC9leGlmOkZvY2FsTGVuSW4zNW1tRmlsbT4KICAgICAgICAgPGV4aWY6Q29tcG9uZW50c0NvbmZpZ3VyYXRpb24+CiAgICAgICAgICAgIDxyZGY6U2VxPgogICAgICAgICAgICAgICA8cmRmOmxpPjE8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaT4yPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGk+MzwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPjA8L3JkZjpsaT4KICAgICAgICAgICAgPC9yZGY6U2VxPgogICAgICAgICA8L2V4aWY6Q29tcG9uZW50c0NvbmZpZ3VyYXRpb24+CiAgICAgICAgIDxleGlmOkV4cG9zdXJlTW9kZT4xPC9leGlmOkV4cG9zdXJlTW9kZT4KICAgICAgICAgPGV4aWY6U2F0dXJhdGlvbj4wPC9leGlmOlNhdHVyYXRpb24+CiAgICAgICAgIDxleGlmOkV4cG9zdXJlVGltZT4xMC8xNjAwPC9leGlmOkV4cG9zdXJlVGltZT4KICAgICAgICAgPGV4aWY6U2hhcnBuZXNzPjE8L2V4aWY6U2hhcnBuZXNzPgogICAgICAgICA8ZXhpZjpFeGlmVmVyc2lvbj4wMjIxPC9leGlmOkV4aWZWZXJzaW9uPgogICAgICAgICA8ZXhpZjpGaWxlU291cmNlPjM8L2V4aWY6RmlsZVNvdXJjZT4KICAgICAgICAgPGV4aWY6Rmxhc2hQaXhWZXJzaW9uPjAxMDA8L2V4aWY6Rmxhc2hQaXhWZXJzaW9uPgogICAgICAgICA8ZXhpZjpXaGl0ZUJhbGFuY2U+MDwvZXhpZjpXaGl0ZUJhbGFuY2U+CiAgICAgICAgIDxleGlmOkNvbG9yU3BhY2U+MTwvZXhpZjpDb2xvclNwYWNlPgogICAgICAgICA8ZXhpZjpTdWJqZWN0RGlzdFJhbmdlPjA8L2V4aWY6U3ViamVjdERpc3RSYW5nZT4KICAgICAgICAgPGV4aWY6Rm9jYWxMZW5ndGg+NTIwLzEwPC9leGlmOkZvY2FsTGVuZ3RoPgogICAgICAgICA8ZXhpZjpFeHBvc3VyZVByb2dyYW0+MTwvZXhpZjpFeHBvc3VyZVByb2dyYW0+CiAgICAgICAgIDxleGlmOlNlbnNpbmdNZXRob2Q+MjwvZXhpZjpTZW5zaW5nTWV0aG9kPgogICAgICAgICA8ZXhpZjpGTnVtYmVyPjkwLzEwPC9leGlmOkZOdW1iZXI+CiAgICAgICAgIDxleGlmOk1heEFwZXJ0dXJlVmFsdWU+NTAvMTA8L2V4aWY6TWF4QXBlcnR1cmVWYWx1ZT4KICAgICAgICAgPGV4aWY6TGlnaHRTb3VyY2U+MDwvZXhpZjpMaWdodFNvdXJjZT4KICAgICAgICAgPGV4aWY6RXhwb3N1cmVCaWFzVmFsdWU+MzAvNjwvZXhpZjpFeHBvc3VyZUJpYXNWYWx1ZT4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5QaXhlbG1hdG9yIDMuNC4yPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDEwLTA3LTE1VDAxOjMwOjA0LjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTc6MDI6MjUgMTI6MDI6MzI8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8dGlmZjpDb21wcmVzc2lvbj41PC90aWZmOkNvbXByZXNzaW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICAgICA8dGlmZjpYUmVzb2x1dGlvbj4zMDA8L3RpZmY6WFJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOllSZXNvbHV0aW9uPjMwMDwvdGlmZjpZUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6TW9kZWw+TklLT04gRDQwPC90aWZmOk1vZGVsPgogICAgICAgICA8dGlmZjpNYWtlPk5JS09OIENPUlBPUkFUSU9OPC90aWZmOk1ha2U+CiAgICAgICAgIDxleGlmRVg6UGhvdG9ncmFwaGljU2Vuc2l0aXZpdHk+MjAwPC9leGlmRVg6UGhvdG9ncmFwaGljU2Vuc2l0aXZpdHk+CiAgICAgICAgIDxwaG90b3Nob3A6RGF0ZUNyZWF0ZWQ+MjAxMC0wNy0xNVQwMTozMDowNC4wMDwvcGhvdG9zaG9wOkRhdGVDcmVhdGVkPgogICAgICAgICA8YXV4OkxlbnM+QUYtUyBEWCBab29tLU5pa2tvciAxOC01NW1tIGYvMy41LTUuNkcgRUQ8L2F1eDpMZW5zPgogICAgICAgICA8YXV4OkxlbnNJbmZvPjE4LzEgNTUvMSA3LzIgMjgvNTwvYXV4OkxlbnNJbmZvPgogICAgICAgICA8YXV4OlNlcmlhbE51bWJlcj45MDg3MzY5PC9hdXg6U2VyaWFsTnVtYmVyPgogICAgICAgICA8YXV4OkltYWdlTnVtYmVyPjI2MTc1PC9hdXg6SW1hZ2VOdW1iZXI+CiAgICAgICAgIDxhdXg6Rmxhc2hDb21wZW5zYXRpb24+MC8xPC9hdXg6Rmxhc2hDb21wZW5zYXRpb24+CiAgICAgICAgIDxhdXg6TGVuc0lEPi04MzQwNjE2Njc0NjQyNDU3MDgyPC9hdXg6TGVuc0lEPgogICAgICAgICA8ZGM6c3ViamVjdD4KICAgICAgICAgICAgPHJkZjpTZXEvPgogICAgICAgICA8L2RjOnN1YmplY3Q+CiAgICAgICAgIDx4bXBNTTpJbnN0YW5jZUlEPnV1aWQ6ZmFmNWJkZDUtYmEzZC0xMWRhLWFkMzEtZDMzZDc1MTgyZjFiPC94bXBNTTpJbnN0YW5jZUlEPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9y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" width="130" height="190/"></p>
</div>
</section>
<section id="简介" class="level2">
<h2>简介</h2>
<p>一个有四年开发经验的小司机。 开发过很多款上线手游项目，上架了appStroe，googlePlay以及国内大量的杂鱼渠道；</p>
</section>
<section id="特长" class="level2">
<h2>特长</h2>
<p>能胜任android（java），ios（OC）单平台或者跨平台C++的开发工作，对css，html5，js均有良好的掌握度，能够进行前端开发；<br />
对openGL有良好的掌握度，对shader优化编写使用熟练。对图形数学有良好的认识和基础。 长期使用cocos2d-x,uinity3d游戏引擎，对游戏引擎的工具编写也有良好的习惯。</p>
</section>
<section id="工作经验" class="level2">
<h2>工作经验</h2>
<section id="cocos2d-x-开发工程师-在-mochang有限公司" class="level3">
<h3><strong>cocos2d-x 开发工程师</strong> 在 <a href="https://www.mochang.net/">MoChang有限公司</a></h3>
<p><em>2014.1 - 2015.6</em></p>
<p>1.在公司主要从事cocos2d-x游戏的制作和维护工作，使用C++重构代码，配置更多的功能模块. 2.作为从事生物科技工作的我来说，这是一次挑战，我学习到了很多C++基本的语法及表驱动，插件架构等常用的语言设计模式。补习了很多程序及系统的基础原理，对linux系统的学习了一段时间，能独立编写小型的c++服务器。 3.在公司我工作了一年半，上架了一些比较简单的欧美儿童游戏，有大量的功能模块重用和维护。 4.期间也独立完成很多 ios 及安卓端的 sdk包括广告的和功能的接入。 5.制作小型游戏制定文档并按照需求文档在较短的时间内提交上线。 6.由于团队小，所以大量的与美术的协调工作都由我独立完成，团队的策划担任高层领导角色，团队具有比较高的自由度。</p>
</section>
<section id="cc-开发工程师-在-南京光辉互动网络科技有限公司熊大叔儿童教育" class="level3">
<h3><strong>C/C++ 开发工程师</strong> 在 <a href="https://bie-plc.com/">南京光辉互动网络科技有限公司</a>/<a href="https://www.biemore.com/zh-cn/index.html">熊大叔儿童教育</a></h3>
<p><em>2015.6 - 2016.2</em></p>
<p>1.一线开发游戏项目，对多个产品线不同语言的项目代码进行检查和修改重构，使用代码包括包括js,Lua,C++。 2.实现shader技术优化和难点。 3.负责一些产品最后阶段的代码调试和检查工作，接入一些商业代码,sdk。</p>
</section>
<section id="前端工程师兼培训师-在-南京触控科技办事处" class="level3">
<h3><strong>前端工程师兼培训师</strong> 在 <a href="http://www.chukong-inc.com/">南京触控科技办事处</a></h3>
<p><em>2016.3 - 2016.10</em></p>
<p>1.参与3.x的cocos2d-x引擎代码的修改和维护，上架一些以前的成品代码游戏。 2.培训新员工，培训git，lua,quick-cocos部分内容。 3.修改和上线u3d项目.</p>
</section>
<section id="主要语言技能" class="level3">
<h3>主要语言技能</h3>
<p>注：<br />
+：使用过，了解语法，能够上手修改现有的浅层代码逻辑<br />
++：全盘学习过，理解语言全盘的语法，对语言的相关设计理念有认识，对相关特性够熟练运用 +++：相关语言的基本设计模式能够完全应用于实践，能够胜任框架的搭建</p>
<ul>
<li><a href="http://www.cplusplus.com/">C++</a>+++</li>
<li>C++</li>
<li><a href="http://www.lua.org/">Lua</a>+++</li>
<li><a href="https://www.java.com/zh_CN/">java</a>+</li>
<li><a href="https://developer.apple.com/">objective-C</a>+</li>
<li><a href="https://www.microsoft.com/net/">C#</a>++</li>
<li><a href="https://www.glslsandbox.com/">shader</a>+++</li>
<li><a href="https://www.javascript.com/">javaScript</a>++</li>
<li><a href="http://developers.whatwg.org">HTML</a>++</li>
<li><a href="http://www.w3.org/Style/CSS/Overview.en.html">CSS</a>+</li>
<li><a href="https://www.python.org/">python</a>+</li>
<li><a href="http://www.ruby-lang.org/zh_cn/">Ruby (Rake)</a>++</li>
<li><a href="http://www.uml.org/">UML</a>+</li>
</ul>
</section>
<section id="格式类型使用" class="level3">
<h3>格式类型使用</h3>
<p>注：<br />
+：了解并修改过小于5次。 ++：全盘学习过，熟练使用语法书写内容或修改配置。 +++：查看过底层格式实现原理，并修改使用过自己的衍生格式。</p>
<ul>
<li><a href="http://daringfireball.net/projects/markdown">Markdown</a>++</li>
<li><a href="https://www.xml.com/">XML</a>+</li>
<li><a href="http://www.json.org.cn/">Jason</a>++</li>
<li><a href="https://github.com/Winnerhust/inifile2">ini</a>++</li>
</ul>
</section>
<section id="框架" class="level3">
<h3>框架</h3>
<p>注*：<br />
+：使用过，了接口用法，能够快速使用。 ++：模块化地学习过，理解框架下原理，能够熟练进行相关优化。 +++：查看学习过框架源码，修改框架内部实现并商用化过相关的代码。</p>
<ul>
<li><a href="https://www.opengl.org/">OpenGL （web,ES,glut,glew,glsl…）</a>++</li>
<li><a href="http://opencv.org/">openCV</a>+</li>
<li><a href="http://www.boost.org/">Boost (shared_ptr,λ,tuple,thread…)</a>++</li>
<li><a href="http://www.cocos2d-x.org/">Cocos2d-x</a>+++</li>
<li><a href="https://unity3d.com/cn/">Uinity3d</a>++</li>
<li><a href="https://hexo.io/">hexo</a>++</li>
<li>http,tcp/ip,udp+</li>
</ul>
</section>
<section id="软件" class="level3">
<h3>软件</h3>
<p>注*：<br />
+：使用过，能够完成常规的工具功能 ++：熟练使用，包括快捷键和高度自定义的功能 +++：查看过软件源码，修改衍生过相关的商用版本</p>
<ul>
<li><p>IDE:<a href="http://developer.apple.com">Apple Xcode</a>++/<a href="https://www.visualstudio.com/">VisualStudio</a>++/<a href="http://www.android-studio.org/">AndroidStudio</a>+</p></li>
<li><a href="http://git-scm.com">Git</a>++</li>
<li><a href="http://svn.apache.org">Subversion</a>+</li>
<li><a href="https://www.sourcetreeapp.com/">SourceTree(win)</a>/<a href="https://www.git-tower.com/">Tower(mac)</a>++</li>
<li><p><a href="http://atlassian.com/software/jira">JIRA</a>+</p></li>
<li><a href="http://www.gnu.org/software/grub/">grub/grub2</a>++</li>
<li><p><a href="http://apple.com/macosx">Mac OS X</a>++/<a href="http://ubuntu.com">Ubuntu Linux</a>++</p></li>
<li><a href="http://www.sublimetext.com">Sublime Text</a>++</li>
<li><a href="http://www.vim.org">Vim</a>++</li>
<li><a href="http://www.zsh.org">zsh</a>++</li>
<li><a href="http://www.gnu.org/software/bash/">bash</a>++</li>
<li><p><a href="http://jetbrains.com/webstorm">WebStorm</a>+</p></li>
<li><a href="http://johnmacfarlane.net/pandoc">Pandoc</a>+</li>
<li><a href="https://github.com/doxygen/doxygen">Doxygen</a>+</li>
<li><p><a href="http://www.latex-project.org/">Latex</a>+</p></li>
<li><a href="http://wiki.nginx.org">Nginx</a>+</li>
<li><p><a href="http://mysql.com">MySQL</a>+</p></li>
</ul>
</section>
</section>
<section id="教育" class="level2">
<h2>教育</h2>
<p><a href>扬州大学 动物医学</a>, 2008 - 2012</p>
</section>
<section id="兴趣" class="level2">
<h2>兴趣</h2>
<ul>
<li>玩卡牌游戏（炉石）,至今未上传说…</li>
<li>听音乐,玩一些器材,中西内外新旧都听</li>
<li>养猫,叫毛毛,一只英短蓝色的小母猫</li>
<li>弹吉他,准备周末去卖艺</li>
<li>逛github,知乎,Bilibili 找基佬玩耍</li>
<li>另外已婚未育</li>
</ul>
</section>
<section id="下载" class="level2">
<h2>下载</h2>
<p>以下是我的多种格式下的简历，如有需要请自行下载：</p>
<p><a href="https://github.com/TinySlik/resume/raw/master/resume_cn.docx">doc</a></p>
<p><a href="https://github.com/TinySlik/resume/raw/master/resume_cn.epub">ePub</a></p>
<p>谢谢对我的关注.</p>
<p>©2016 <a href="http://tinyslik.coding.me/resume">Tiny Oh</a>. All rights reserved.</p>
</section>
</section>
</body>
</html>
