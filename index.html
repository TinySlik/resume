<!DOCTYPE html>
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Tiny Wu</title>
    
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <style>

      body {
        -webkit-font-smoothing: antialiased;
        font: 16px helvetica, arial, freesans, clean, sans-serif;
        line-height: 1.4em;
        border: none;
        line-height: 1.5;
        margin: 0 ;
        padding: 0;
        text-align: left;
        overflow: hidden;
        text-shadow:0 0px, 1px 1px #000000;
      }

      @media screen {
        #wrapper {
          padding: 9px;
          background: #f8f8f8;
          border: 1px solid #e9e9e9;
        }
      }
      h1 {
        font-size: 280%;
        margin: 0;
        padding: 0.25em 0 0.92em;
        border-top: none;
        -webkit-transform-origin: 100% 100% 50%;
        -moz-transform-origin: 100% 100% 50%;
        -ms-transform-origin: 100% 100% 50%;
        -o-transform-origin: 100% 100% 50%;
        transform-origin: 100% 100% 50%;
        -webkit-transition: all 400ms ease-in-out;
        -moz-transition: all 400ms ease-in-out;
        -o-transition: all 400ms ease-in-out;
        transition: all 400ms ease-in-out;
      }
      h1.active {
        -webkit-transform: rotate(-5deg);
        -moz-transform: rotate(-5deg);
        -ms-transform: rotate(-5deg);
        -o-transform: rotate(-5deg);
        transform: rotate(-5deg);
        text-shadow: 1px 1px 0px white, 2px 2px 0px #bada55, 3px 3px 0px #bada55, 4px 4px 0px #bada55, 5px 5px 0px #97ba28;
      }
      @media only screen and (min-width: 640px) {
        h1 {
          padding-bottom: 0;
          font-size: 425%;
        }
        h1.active {
          text-shadow: 1px 1px 0px white, 2px 2px 0px #bada55, 3px 3px 0px #bada55, 4px 4px 0px #bada55, 5px 5px 0px #bada55, 6px 6px 0px #bada55, 7px 7px 0px #97ba28;
        }
      }
      @media only screen and (min-width: 900px) {
        h1 {
          float: left;
          width: 57%;
        }
      }

      h2 {
        font-size: 200%;
        margin-top: 1.5em;
      }

      h3 {
        font-size: 150%;
        margin-top: 1.5em;
        border-top: 4px solid rgba(0, 0, 0, 0.07);
        padding-top: 0.5em;
      }

      p {
        margin: 1em 0;
        line-height: 1.5em;
      }

      pre, code {
        font: 12px "Bitstream Vera Sans Mono", "Courier", monospace;
      }

      pre {
        -webkit-box-shadow: rgba(0, 0, 0, 0.066) 0px 1px 2px 0px inset;
        background-color: #eeeeee;
        border: #dddddd 1px solid;
        color: #444444;
        display: block;
        margin: 12px 0;
        overflow: auto;
        padding: 5px;
        white-space: pre;
        max-width: 100%;
        overflow: auto;
      }


      a {
        border-bottom: 1px solid transparent;
        color: #EE113D;
        text-decoration: none;
        -webkit-transition: background-color 500ms, border-bottom-color 500ms, color 500ms;
        -moz-transition: background-color 500ms, border-bottom-color 500ms, color 500ms;
        -o-transition: background-color 500ms, border-bottom-color 500ms, color 500ms;
        transition: background-color 500ms, border-bottom-color 500ms, color 500ms;
      }
      a:hover {
        background-color: #dceca9;
        border-bottom-color: #bada55;
        color: #647b1b;
      }
      a code {
        color: #bada55;
        text-decoration: none;
      }

      table td {
        border-bottom: 1px solid #dddddd;
        padding: 0.2em 1em;
      }


    </style>

  </head>
  <body style="cursor: default;">

    <link rel="stylesheet" href="./GLSL Sandbox_files/codemirror.css">
    <link rel="stylesheet" href="./GLSL Sandbox_files/default.css">

    <script src="./GLSL Sandbox_files/lzma.js"></script>
    <script src="./GLSL Sandbox_files/jquery.js"></script>
    <script src="./GLSL Sandbox_files/helpers.js"></script>
    <script src="./GLSL Sandbox_files/codemirror.js"></script>
    <script src="./GLSL Sandbox_files/glsl.js"></script>

    <script id="sea" type="x-shader/x-fragment">
                  //大海
                  #ifdef GL_ES
                  precision mediump float;
                  #endif

                  uniform float time;
                  vec2 mouse = vec2(20, 0);
                  uniform vec2 resolution;

                  // "Seascape" by Alexander Alekseev aka TDM - 2014
                  // License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.

                  const int NUM_STEPS = 16;
                  const float PI    = 3.1415;
                  const float EPSILON = 1e-3;
                  float EPSILON_NRM = 0.;

                  // sea
                  const int ITER_GEOMETRY = 3;
                  const int ITER_FRAGMENT = 5;
                  const float SEA_HEIGHT = 0.6;
                  const float SEA_CHOPPY = 5.0;
                  const float SEA_SPEED = 1.0;
                  const float SEA_FREQ = 0.16;
                  const vec3 SEA_BASE = vec3(0.1,0.19,0.22);
                  const vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6);
                  float SEA_TIME = 0.;
                  mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);

                  // math
                  mat3 fromEuler(vec3 ang) {
                    vec2 a1 = vec2(sin(ang.x),cos(ang.x));
                      vec2 a2 = vec2(sin(ang.y),cos(ang.y));
                      vec2 a3 = vec2(sin(ang.z),cos(ang.z));
                      mat3 m;
                      m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);
                    m[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);
                    m[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);
                    return m;
                  }
                  float hash( vec2 p ) {
                    float h = dot(p,vec2(127.1,311.7)); 
                      return fract(sin(h)*43758.5453123);
                  }
                  float noise( in vec2 p ) {
                      vec2 i = floor( p );
                      vec2 f = fract( p );  
                    vec2 u = f*f*(3.0-2.0*f);
                      return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), 
                                       hash( i + vec2(1.0,0.0) ), u.x),
                                  mix( hash( i + vec2(0.0,1.0) ), 
                                       hash( i + vec2(1.0,1.0) ), u.x), u.y);
                  }

                  // lighting
                  float diffuse(vec3 n,vec3 l,float p) {
                      return pow(dot(n,l) * 0.4 + 0.6,p);
                  }
                  float specular(vec3 n,vec3 l,vec3 e,float s) {    
                      float nrm = (s + 8.0) / (3.1415 * 8.0);
                      return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;
                  }

                  // sky
                  vec3 getSkyColor(vec3 e) {
                      e.y = max(e.y,0.0);
                      vec3 ret;
                      ret.x = pow(1.0-e.y,2.0);
                      ret.y = 1.0-e.y;
                      ret.z = 0.6+(1.0-e.y)*0.4;
                      return ret;
                  }

                  // sea
                  float sea_octave(vec2 uv, float choppy) {
                      uv += noise(uv);        
                      vec2 wv = 1.0-abs(sin(uv));
                      vec2 swv = abs(cos(uv));    
                      wv = mix(wv,swv,wv);
                      return pow(1.0-pow(wv.x * wv.y,0.65),choppy);
                  }

                  float map(vec3 p) {
                      float freq = SEA_FREQ;
                      float amp = SEA_HEIGHT;
                      float choppy = SEA_CHOPPY;
                      vec2 uv = p.xz; uv.x *= 0.75;
                      
                      float d, h = 0.0;    
                      for(int i = 0; i < ITER_GEOMETRY; i++) {        
                        d = sea_octave((uv+SEA_TIME)*freq,choppy);
                        d += sea_octave((uv-SEA_TIME)*freq,choppy);
                          h += d * amp;        
                        uv *= octave_m; freq *= 1.9; amp *= 0.22;
                          choppy = mix(choppy,1.0,0.2);
                      }
                      return p.y - h;
                  }

                  float map_detailed(vec3 p) {
                      float freq = SEA_FREQ;
                      float amp = SEA_HEIGHT;
                      float choppy = SEA_CHOPPY;
                      vec2 uv = p.xz; uv.x *= 0.75;
                      
                      float d, h = 0.0;    
                      for(int i = 0; i < ITER_FRAGMENT; i++) {        
                        d = sea_octave((uv+SEA_TIME)*freq,choppy);
                        d += sea_octave((uv-SEA_TIME)*freq,choppy);
                          h += d * amp;        
                        uv *= octave_m; freq *= 1.9; amp *= 0.22;
                          choppy = mix(choppy,1.0,0.2);
                      }
                      return p.y - h;
                  }

                  vec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  
                      float fresnel = 1.0 - max(dot(n,-eye),0.0);
                      fresnel = pow(fresnel,3.0) * 0.65;
                          
                      vec3 reflected = getSkyColor(reflect(eye,n));    
                      vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; 
                      
                      vec3 color = mix(refracted,reflected,fresnel);
                      
                      float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);
                      color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;
                      
                      color += vec3(specular(n,l,eye,60.0));
                      
                      return color;
                  }

                  // tracing
                  vec3 getNormal(vec3 p, float eps) {
                      vec3 n;
                      n.y = map_detailed(p);    
                      n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;
                      n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;
                      n.y = eps;
                      return normalize(n);
                  }

                  float heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  
                      float tm = 0.0;
                      float tx = 1000.0;    
                      float hx = map(ori + dir * tx);
                      if(hx > 0.0) return tx;   
                      float hm = map(ori + dir * tm);    
                      float tmid = 0.0;
                      for(int i = 0; i < NUM_STEPS; i++) {
                          tmid = mix(tm,tx, hm/(hm-hx));                   
                          p = ori + dir * tmid;                   
                        float hmid = map(p);
                      if(hmid < 0.0) {
                            tx = tmid;
                              hx = hmid;
                          } else {
                              tm = tmid;
                              hm = hmid;
                          }
                      }
                      return tmid;
                  }

                  // main
                  void main( void ) {
                    EPSILON_NRM = 0.1 / resolution.x;
                    SEA_TIME = time * SEA_SPEED;
                    
                    vec2 uv = gl_FragCoord.xy / resolution.xy;
                      uv = uv * 2.0 - 1.0;
                      uv.x *= resolution.x / resolution.y;    
                      float time = time * 0.3 + mouse.x*0.01;
                    
                    mouse = vec2(time * 0.1, 0);
                          
                      // ray
                      vec3 ang = vec3(3);    
                      vec3 ori = vec3(mouse.x*100.0,3.5,5.0);
                      vec3 dir = normalize(vec3(uv.xy,-2.0));
                    dir.z += length(uv) * 0.15;
                      dir = normalize(dir) * fromEuler(ang);
                      
                      // tracing
                      vec3 p;
                      heightMapTracing(ori,dir,p);
                      vec3 dist = p - ori;
                      vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);
                      vec3 light = normalize(vec3(0.0,1.0,0.8)); 
                               
                      // color
                      vec3 color = mix(
                          getSkyColor(dir),
                          getSeaColor(p,n,light,dir,dist),
                        pow(smoothstep(0.0,-0.05,dir.y),0.3));
                          
                      // post
                    gl_FragColor = vec4(pow(color,vec3(0.75)), 1.0);
                  }

    </script>

    <script id="vertigo" type="x-shader/x-fragment">
                  // 眩晕
                    #ifdef GL_ES
                    precision mediump float;
                    #endif
                    //nuclear throne tunnel
                    //2017.01.29 tigrou dot ind at gmail dot com
                    #extension GL_OES_standard_derivatives : enable

                    uniform float time;
                    uniform vec2 mouse;
                    uniform vec2 resolution;

                    vec4 pattern(vec2 pos, float ang) 
                    {
                            pos = vec2(pos.x * cos(ang) - pos.y * sin(ang), pos.y * cos(ang) + pos.x * sin(ang)); 
                      
                      //if(length(pos) < 0.2)
                      if(abs(pos.x) < 0.2 && abs(pos.y) < 0.2)
                         return vec4(0.0, 0.0, 0.0, 0.0);
                      else if((abs(pos.x) - abs(pos.y)) > 0.0)
                         return vec4(0.59, 0.45, 0.05, 1.0);
                      else
                         return vec4(0.27, 0.07, 0.39, 1.0);      
                    }

                    void main( void ) 
                    {
                      vec2 pos = ( gl_FragCoord.xy / resolution.xy ) - vec2(0.5, 0.5);
                      vec4 color = vec4(0.0);
                      
                      for(float i = 0.01 ; i < 1.0 ; i += 0.005)
                      {
                        float o = 1.0 - i;
                        vec2 offset = vec2(o*cos(o*2.0+time)*0.5, o*sin(o*2.0+time)*0.5);
                        vec4 res = pattern(pos/vec2(i*i*2.7)+offset, i*10.0+time);
                        if(res.a > 0.5)
                             color = res*i*2.7;
                      }

                      gl_FragColor = color;
                    }
                    </script>

    <script id="bunge bedstraw herb" type="x-shader/x-fragment">     
    
                  //四叶草
                    #ifdef GL_ES
                    precision mediump float;
                    #endif

                    #extension GL_OES_standard_derivatives : enable

                    uniform float time;
                    uniform vec2 mouse;
                    uniform vec2 resolution;

                    float leafs = 4.0;
                    //from tutorial created by iq
                    vec3 computeColor(vec2 p) {
                        float ratio = resolution.x / resolution.y;
                        p.y = p.y / ratio;
                        p /= 0.4;
                        p -= vec2(0.5*ratio, 1.1 / ratio);
                        float r = sqrt(dot(p, p));
                        float a = atan(p.y, p.x) + time * 0.2;
                        float s = 0.5 + 0.5 * sin(leafs * a);
                        float t = 0.15 + 0.35*pow(s, 0.3);
                        t += 0.1 * pow(0.5 + 0.5 * cos(leafs * 2.0 * a), 0.5);
                        float h = r / t;
                        float f = 0.0;
                        if (h < 1.0) {
                            f = 1.0;
                        } else {
                            f = 0.3;
                            h = 2.0;
                        }
                        
                        return mix(vec3(1.0), vec3(0.5 * h, 0.5 + 0.5 * h, 0.0), f);
                    }

                    void main( void )
                    {
                        vec2 uv = vec2(gl_FragCoord.x / resolution.x, gl_FragCoord.y  / resolution.y);
                        vec3 res = computeColor(uv);
                        gl_FragColor = vec4(res.rgb,2.0);
                    }



</script>
<script id="balls" type="x-shader/x-fragment">
// created by Eric 
// stolen straight from https://www.shadertoy.com/view/lsX3DH
#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

#define MOTIONBLUR
#define DEPTHOFFIELD

#define CUBEMAPSIZE 256

#define SAMPLES 8
#define PATHDEPTH 4
#define TARGETFPS 60.

#define FOCUSDISTANCE 17.
#define FOCUSBLUR 0.25

#define RAYCASTSTEPS 20
#define RAYCASTSTEPSRECURSIVE 2

#define EPSILON 0.001
#define MAXDISTANCE 180.
#define GRIDSIZE 8.
#define GRIDSIZESMALL 5.9
#define MAXHEIGHT 10.
#define SPEED 0.5


float ttime;

//
// math functions
//

float hash( const float n ) {
  return fract(sin(n)*43758.54554213);
}
vec2 hash2( const float n ) {
  return fract(sin(vec2(n,n+1.))*vec2(43758.5453123));
}
vec2 hash2( const vec2 n ) {
  return fract(sin(vec2( n.x*n.y, n.x+n.y))*vec2(25.1459123,312.3490423));
}
vec3 hash3( const vec2 n ) {
  return fract(sin(vec3(n.x, n.y, n+2.0))*vec3(36.5453123,43.1459123,11234.3490423));
}
//
// intersection functions
//

float intersectPlane( const vec3 ro, const vec3 rd, const float height) { 
  if (rd.y==0.0) return 500.; 
  float d = -(ro.y - height)/rd.y;
  if( d > 0. ) {
    return d;
  }
  return 500.;
}

float intersectUnitSphere ( const vec3 ro, const vec3 rd, const vec3 sph ) {
  vec3  ds = ro - sph;
  float bs = dot( rd, ds );
  float cs = dot( ds, ds ) - 1.0;
  float ts = bs*bs - cs;

  if( ts > 0.0 ) {
    ts = -bs - sqrt( ts );
    if( ts > 0. ) {
      return ts;
    }
  }
  return 500.;
}

//
// Scene
//

void getSphereOffset( const vec2 grid, out vec2 center ) {
  center = (hash2( grid+vec2(43.12,1.23) ) - vec2(0.5) )*(GRIDSIZESMALL);
}
void getMovingSpherePosition( const vec2 grid, const vec2 sphereOffset, out vec3 center ) {
  // falling?
  float s = 0.1+hash( grid.x*1.23114+5.342+74.324231*grid.y );
  float t = 14.*s + time/s;
  
  float y =  s * MAXHEIGHT * abs( cos( t ) );
  vec2 offset = grid + sphereOffset;
  
  center = vec3( offset.x, y, offset.y ) + 0.5*vec3( GRIDSIZE, 2., GRIDSIZE );
}
void getSpherePosition( const vec2 grid, const vec2 sphereOffset, out vec3 center ) {
  vec2 offset = grid + sphereOffset;
  center = vec3( offset.x, 0., offset.y ) + 0.5*vec3( GRIDSIZE, 2., GRIDSIZE );
}
vec3 getSphereColor( const vec2 grid ) {
  return 0.8*normalize( hash3( grid+vec2(43.12*grid.y,12.23*grid.x) ) );
}

vec3 sundir = normalize( vec3(-1.0,0.8,0.2) );

vec3 getBackgroundColor( const vec3 ro, const vec3 rd ) { 
  return vec3( 0.8, 0.9, 1.0 ) * (1.8 * (rd.y+0.5) );
}

// code duplication because the for-loop requires a const
vec3 traceRec( const vec3 ro, const vec3 rd, out vec3 intersection, out vec3 normal, out float dist, out int material) {
  dist = MAXDISTANCE;
  float distcheck;
  
  vec3 sphereCenter, col;

  material = 0; 
  col = getBackgroundColor(ro, rd);
  
  if( (distcheck = intersectPlane( ro,  rd, 0.)) < MAXDISTANCE ) {
    dist = distcheck;
    material = 1;
    normal = vec3( 0., 1., 0. );
    col = vec3( 0.5 );
  }
  
  // trace grid
  vec3 pos = floor(ro/GRIDSIZE)*GRIDSIZE;
  vec3 ri = 1.0/rd;
  vec3 rs = sign(rd) * GRIDSIZE;
  vec3 dis = (pos-ro + 0.5  * GRIDSIZE + rs*0.5) * ri;
  vec3 mm = vec3(0.0);
  vec2 offset;
  
  for( int i=0; i<RAYCASTSTEPSRECURSIVE; i++ ) {
    if( material != 2 ) {   
      getSphereOffset( pos.xz, offset );      
      
      getMovingSpherePosition( pos.xz, -offset, sphereCenter );     
      if( (distcheck = intersectUnitSphere( ro, rd, sphereCenter )) < dist ) {
        dist = distcheck;
        normal = normalize((ro+rd*dist)-sphereCenter);
        col = getSphereColor(pos.xz);
        material = 2;
      }
      
      getSpherePosition( pos.xz, offset, sphereCenter );
      if( (distcheck = intersectUnitSphere( ro, rd, sphereCenter )) < dist ) {
        dist = distcheck;
        normal = normalize((ro+rd*dist)-sphereCenter);
        col = getSphereColor(pos.xz+vec2(1.,2.));
        material = 2;
      }
      
      mm = step(dis.xyz, dis.zyx);
      dis += mm * rs * ri;
      pos += mm * rs; 
    }
  }
  
  intersection = ro+rd*dist;
  
  return col;
}


vec3 trace(const vec3 ro, const vec3 rd, out vec3 intersection, out vec3 normal, out float dist, out int material) {
  dist = MAXDISTANCE;
  float distcheck;
  
  vec3 sphereCenter, col, normalcheck;
  
  material = 0;
  col = getBackgroundColor(ro, rd);
  
  if( (distcheck = intersectPlane( ro,  rd, 0.)) < MAXDISTANCE ) {
    dist = distcheck;
    material = 1;
    normal = vec3( 0., 1., 0. );
    col = vec3( 0.5 );
  } 
  
  // trace grid
  vec3 pos = floor(ro/GRIDSIZE)*GRIDSIZE;
  vec3 ri = 1.0/rd;
  vec3 rs = sign(rd) * GRIDSIZE;
  vec3 dis = (pos-ro + 0.5  * GRIDSIZE + rs*0.5) * ri;
  vec3 mm = vec3(0.0);
  vec2 offset;
    
  for( int i=0; i<RAYCASTSTEPS; i++ ) {
    if( material != 2 &&  distance( ro.xz, pos.xz ) < dist+GRIDSIZE ) {
      getSphereOffset( pos.xz, offset );
      
      getMovingSpherePosition( pos.xz, -offset, sphereCenter );     
      if( (distcheck = intersectUnitSphere( ro, rd, sphereCenter )) < dist ) {
        dist = distcheck;
        normal = normalize((ro+rd*dist)-sphereCenter);
        col = getSphereColor(pos.xz);
        material = 2;
      }
      
      getSpherePosition( pos.xz, offset, sphereCenter );
      if( (distcheck = intersectUnitSphere( ro, rd, sphereCenter )) < dist ) {
        dist = distcheck;
        normal = normalize((ro+rd*dist)-sphereCenter);
        col = getSphereColor(pos.xz+vec2(1.,2.));
        material = 2;
      }   
      mm = step(dis.xyz, dis.zyx);
      dis += mm * rs * ri;
      pos += mm * rs;   
    }
  }
  
  intersection = ro+rd*dist;
  
  return col;
}

vec2 rv2;

vec3 cosWeightedRandomHemisphereDirection2( const vec3 n ) {
  vec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );
  vec3  vv = normalize( cross( uu, n ) );
  
  float ra = sqrt(rv2.y);
  float rx = ra*cos(6.2831*rv2.x); 
  float ry = ra*sin(6.2831*rv2.x);
  float rz = sqrt( 1.0-rv2.y );
  vec3  rr = vec3( rx*uu + ry*vv + rz*n );

    return normalize( rr );
}


void main(void) {
  //vec2 q = gl_FragCoord.xy/iResolution.xy;
  vec2 q = ( gl_FragCoord.xy / resolution.xy );
  vec2 p = -1.0+2.0*q;
  p.x *= resolution.x/resolution.y;
  
  vec3 col = vec3( 0. );
  
  // raytrace
  int material;
  vec3 normal, intersection;
  float dist;
  float seed = time+(p.x+resolution.x*p.y)*1.51269341231;
  
  for( int j=0; j<SAMPLES; j++ ) {
    float fj = float(j);
    
#ifdef MOTIONBLUR
    ttime = time + fj/(float(SAMPLES)*TARGETFPS);
#endif
    
    rv2 = hash2( 24.4316544311*fj+ttime+seed );
    
    vec2 pt = p+rv2/(0.5*resolution.xy);
        
    // camera 
    vec3 ro = vec3( cos( 0.232*time) * 10., 6.+3.*cos(0.3*time), GRIDSIZE*(time/SPEED) );
    vec3 ta = ro + vec3( -sin( 0.232*ttime) * 10., -2.0+cos(0.23*ttime), 10.0 );
    
    float roll = -0.15*sin(0.5*time);
    
    // camera tx
    vec3 cw = normalize( ta-ro );
    vec3 cp = vec3( sin(roll), cos(roll),0.0 );
    vec3 cu = normalize( cross(cw,cp) );
    vec3 cv = normalize( cross(cu,cw) );
  
#ifdef DEPTHOFFIELD
    // create ray with depth of field
    const float fov = 3.0;
    
        vec3 er = normalize( vec3( pt.xy, fov ) );
        vec3 rd = er.x*cu + er.y*cv + er.z*cw;

        vec3 go = FOCUSBLUR*vec3( (rv2-vec2(0.5))*2., 0.0 );
        vec3 gd = normalize( er*FOCUSDISTANCE - go );
    
        ro += go.x*cu + go.y*cv;
        rd += gd.x*cu + gd.y*cv;
    rd = normalize(rd);
#else
    vec3 rd = normalize( pt.x*cu + pt.y*cv + 1.5*cw );    
#endif      
    vec3 colsample = vec3( 1. );
    
    // first hit
    rv2 = hash2( (rv2.x*2.4543263+rv2.y)*(time+1.) );
    colsample *= trace(ro, rd, intersection, normal, dist, material);

    // bounces
    for( int i=0; i<(PATHDEPTH-1); i++ ) {
      if( material != 0 ) {
        rd = cosWeightedRandomHemisphereDirection2( normal );
        ro = intersection + EPSILON*rd;
            
        rv2 = hash2( (rv2.x*2.4543263+rv2.y)*(time+1.)+(float(i+1)*.23) );
            
        colsample *= traceRec(ro, rd, intersection, normal, dist, material);
      }
    } 
    if( material == 0 ) {     
      col += colsample; 
    }
  }
  col  /= float(SAMPLES);
  
  col = pow( col, vec3(0.7) );  
  col = clamp(col, 0.0, 1.0);
  // contrast 
 //   col = clamp( col*0.7 + 0.3*col*col*(3.0-2.0*col), 0., 1.); 
     
  // vigneting
  col *= 0.25+0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );
  
  gl_FragColor = vec4( col,1.0);
}
</script>
<script id="paint" type="x-shader/x-fragment">
#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 resolution;
uniform float time;
uniform vec2 mouse;

const int   complexity      = 48;    // More points of color.
const float mouse_factor    = 32.0;  // Makes it more/less jumpy.
const float mouse_offset    = 15.0;   // Drives complexity in the amount of curls/cuves.  Zero is a single whirlpool.
const float fluid_speed     = 64.0;  // Drives speed, higher number will make it slower.
const float color_intensity = 0.45;

const float Pi = 3.14159;

void main()
{
  vec2 p=(2.0*gl_FragCoord.xy-resolution)/max(resolution.x,resolution.y);
  for(int i=1;i<complexity;i++)
  {
    vec2 newp=p;
    newp.x+=0.6/float(i)*sin(float(i)*p.y+time/fluid_speed+0.3*float(i))+mouse.y/mouse_factor+mouse_offset;
    newp.y+=0.6/float(i)*sin(float(i)*p.x+time/fluid_speed+0.3*float(i+10))-mouse.x/mouse_factor+mouse_offset;
    p=newp;
  }
  vec3 col=vec3(color_intensity*sin(3.0*p.x)+color_intensity,color_intensity*sin(3.0*p.y)+color_intensity,color_intensity*sin(p.x+p.y)+color_intensity);
  gl_FragColor=vec4(col, 1.0);
}
</script>
<script id="building" type="x-shader/x-fragment">
//building off paulo falcao's raymarch framework -alice
//--added random building size -h3r3 ;)
#ifdef GL_ES
precision highp float;
#endif

uniform vec2 resolution;
uniform float time;
uniform vec2 mouse;
//Simple raymarching sandbox with camera

//Raymarching Distance Fields
//About http://www.iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm
//Also known as Sphere Tracing
//Original seen here: http://twitter.com/#!/paulofalcao/statuses/134807547860353024

//Declare functions
vec2 ObjUnion(in vec2 d1,in vec2 d2);
vec2 obj_floor(in vec3 p);
vec3 color_checkers(in vec3 p);
vec2 obj_roundBox(in vec3 p);
vec2 obj_sdBox( vec3 p, vec3 b );
vec3 color_white(in vec3 p);
vec2 distanceField(in vec3 p);
vec2 obj_infiniteBuildingsShort(in vec3 p);
vec2 obj_simpleBuilding (vec3 p, vec3 b );
vec4 applyFog (in vec4 currColor, in vec3 ray);
float maxcomp(in vec3 p );
vec2 obj_infiniteBuildingsTall(in vec3 p);
vec2 obj_infiniteBuildings(in vec3 p);
float sdCross( in vec3 p );


#define EPS 0.01
#define INF 100000.0

#define PHONG_SHADING 0
#define RAYMARCH_SHADING 1
#define TEST_SHADING 2

#define SPINNING_CAMERA 0
#define MOUSE_CAMERA 1
#define PAN_CAMERA 2
#define STILL_CAMERA 3
#define AUTOPAN_CAMERA 4

// mode selection
const int SHADING_MODE = PHONG_SHADING; 
const int CAMERA_MODE = MOUSE_CAMERA; 
vec3 E;

// some simple colors
const vec3 COLOR_GREY = vec3(0.5,0.5,0.5);
const vec3 COLOR_DARKGREY = vec3(0.74, 0.72, 0.71);
const vec3 COLOR_WHITE = vec3(1.0,1.0,1.0);

//============================== UTILS ====================================//
vec2 distanceField(in vec3 p){
  return ObjUnion(obj_floor(p),obj_infiniteBuildings(p)); // infinite boxes
  
  //vec2 test = ObjUnion(obj_infiniteBuildingsShort(p),obj_infiniteBuildingsTall(p)); //multiple mod patterns
  //return ObjUnion(obj_floor(p),test);
}

vec2 ObjUnion(in vec2 d1,in vec2 d2){
  if (d1.x<d2.x)
  return d1;
  else
  return d2;
}

// http://www.ozone3d.net/blogs/lab/20110427/glsl-random-generator/
float rand(vec2 n)
{
  return 0.5 + 0.5 *
  fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);
}

// from IQ
float maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}



// =============================== OBJECTS =======================================//
// CREDIT: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm //

//FLOOR (color is determined by y-component, ie 0.0)
vec2 obj_floor(in vec3 p){
  return vec2(p.y+2.0,0);
}

// ROUNDBOX (try other objects )
//(color is determined by y-component, ie 1.0)
vec2 obj_roundBox(in vec3 p){
  return vec2(length(max(abs(p)-vec3(1,1,1),0.0))-0.25,1);
}

// SIGNED BOX
vec2 obj_sdBox( vec3 p, vec3 b ){
  vec3  di = abs(p) - b;
  float mc = maxcomp(di);
  return vec2(min(mc,length(max(di,0.0))), 1);
}

// INFINITE BUILDINGS SHORT
vec2 obj_infiniteBuildingsShort(in vec3 p){
  vec3 c = vec3(10,10,10); // how close cubes are to each other
  vec3 f = vec3(7,10,7);
  
  vec3 q = p;
  //repetition in x and z direction
  q.x = mod(p.x,c.x)-0.5*c.x;
  q.x = mod(q.x,f.x)-0.5*f.x;
  
  q.z = mod(p.z,c.z)-0.5*c.z;
  q.z = mod(q.z,f.z)-0.5*f.z;
  
  //building height
  vec3 b = vec3(1.0, 3.0, 1.0);
  return obj_sdBox(q,b);  
}

// INFINITE BUILDINGS TALL
vec2 obj_infiniteBuildingsTall(in vec3 p){
  vec3 c = vec3(11,10,11); // how close cubes are to each other
  
  vec3 q = p;
  //repetition in x and z direction
  q.x = mod(p.x,c.x)-0.8*c.x; 
  q.z = mod(p.z,c.z)-0.5*c.z;
  
  //building height
  vec3 b = vec3(1.0, 8.0, 1.0);
  return obj_sdBox(q,b);
}

// INFINITE BUILDINGS RANDOM (CREDIT: H3R3)
vec2 obj_infiniteBuildings(in vec3 p){
  
  vec3 c = vec3(5,5,5); // how close cubes are to each other
  
  vec3 q = p;
  //repetition in x and z direction
  q.x = mod(p.x,c.x)-0.5*c.x;
  q.z = mod(p.z,c.z)-0.5*c.z;
  
  vec2 pos = vec2(ceil(p.x/c.x), ceil(p.z/c.z));
  
  float height = rand(pos)*5.0;//* 10.0 - 4.0;
  float width1 = rand(pos + 100.0) + 0.5;
  float width2 = rand(pos + 1500.0) + 0.5;
  
  //building height
  //vec3 k = vec3(1,height,1);
  vec3 k = vec3(max(0.0, width1), max(0.0, height), max(0.0, width2));
  return obj_simpleBuilding(q,k); 
}


// SIMPLE BUILDING (white)
vec2 obj_simpleBuilding (vec3 p, vec3 b ){
  float body = obj_sdBox(p,b).x;
  
  vec3 q = p;
  vec3 c = vec3(0.5); //0.5

  q = mod(p,c)-0.5*c;
  
  float cr = sdCross(q*3.0)/3.0;
  body = max( body, -cr );
  
  float top = obj_sdBox(p-vec3(0,b.y,0),vec3(1.0, b.y/25.0, 1.0)).x;
  float inside = obj_sdBox(p,vec3(b.x*0.9, b.y, b.z*0.9)).x;
  body = min(inside,min(body,top));
  
  return vec2(body,1);
}

// SD_CROSS (modified from IQ's original)
float sdCross( in vec3 p ){
  const float w = 0.4;
  float da = obj_sdBox(p.xyz,vec3(INF,w,w)).x;
  float db = obj_sdBox(p.yzx,vec3(w,INF,w)).x;
  float dc = obj_sdBox(p.zxy,vec3(w,w,INF)).x;
  return min(da,db);
}


// ============COLORS============= //
// Checkerboard Color
vec3 color_checkers(in vec3 p){
  if (fract(p.x*.5)>.5)
  if (fract(p.z*.5)>.5)
  return COLOR_GREY;
  else
  return vec3(1,1,1);
  else
  if (fract(p.z*.5)>.5)
  return vec3(1,1,1);
  else
  return COLOR_GREY;
}

// ==================== RAY MARCH =============================//
void main(void){
  //Camera animation
  vec3 U=vec3(0,1,0);//Camera Up Vector
  vec3 viewDest=vec3(0,0,0); //Change camere view vector here
  //vec3 E; //moved to global space
  if (CAMERA_MODE == SPINNING_CAMERA)
  E=vec3(-sin(time/10.0)*10.0,5,cos(time/10.0)*10.0); //spinning scene
  else if(CAMERA_MODE == MOUSE_CAMERA){
    float spin = mouse.x * 8.0; //time * 0.1 + mouse.x * 8.0;
    E=vec3(-sin(spin)*10.0, 10.0 * mouse.y, cos(spin)*10.0);//Change camera path position here
  }
  else if(CAMERA_MODE == PAN_CAMERA){
    E=vec3(-sin(1.0)*10.0,7,cos(1.0)*10.0);
    vec3 moveCamDir = normalize(vec3(E.x,0.0,E.y));
    float mouse_val = mouse.y-0.5;
    E+=moveCamDir*time*(mouse_val>0.0?mouse_val:0.0);
  }
  else if(CAMERA_MODE == STILL_CAMERA){
    E=vec3(-sin(1.0)*10.0,7,cos(1.0)*10.0);//Change camera path position here
  }
  else if (CAMERA_MODE == AUTOPAN_CAMERA){
    E=vec3(-sin(1.0)*10.0,7,cos(1.0)*10.0);
    vec3 moveCamDir = normalize(vec3(E.x,0.0,E.y));
    E+=moveCamDir*time;
  }
  
  
  //Camera setup
  vec3 C=normalize(viewDest-E);
  vec3 A=cross(C, U);
  vec3 B=cross(A, C);
  vec3 M=(E+C);

  vec2 vPos=2.0*gl_FragCoord.xy/resolution.xy - 1.0; // = (2*Sx-1) where Sx = x in screen space (between 0 and 1)
  vec3 P=M + vPos.x*A*resolution.x/resolution.y + vPos.y*B; //normalize resolution in either x or y direction (ie resolution.x/resolution.y)
  vec3 rayDir=normalize(P-E); //normalized direction vector from Eye to point on screen
  
  //Colors
  const vec4 skyColor = vec4(0.7, 0.8, 1.0, 1.0);
  const vec4 sunColor = vec4 (1.0, 0.9, 0.7, 1.0);
  
  //Raymarching
  const vec3 e=vec3(0.1,0,0);
  const float MAX_DEPTH=170.0; //Max depth use 500
  const int MAX_STEPS = 100; // max number of steps use 150
  const float MIN_DIST = 0.01;

  vec2 dist=vec2(0.0,0.0);
  float totalDist=0.0;
  vec3 c,p,n; //c=color (used in PHONG and RAYMARCH modes), p=ray position, n=normal at any point on the surface

  int steps = 0;
  for(int i=0;i<MAX_STEPS;i++){
    steps++;
    totalDist+=dist.x;
    p=E+rayDir*totalDist; // p = eye + total_t*rayDir
    dist=distanceField(p);
    if (abs(dist.x)<MIN_DIST) break; // break when p gets sufficiently close to object or exceeds max dist
  }

  vec4 finalColor = skyColor;
  
  if (totalDist<MAX_DEPTH){
    // check which color to use via the y-component
    if (dist.y==0.0) // floor color
    c=color_checkers(p);
    else if(dist.y==1.0) // building color
    c=COLOR_WHITE;
    
    if(SHADING_MODE==PHONG_SHADING){
      // compute normal at this point on the surface using a gradient vector
      n=normalize(
      vec3(
      dist.x-distanceField(p-e.xyy).x,
      dist.x-distanceField(p-e.yxy).x,
      dist.x-distanceField(p-e.yyx).x));
      
      //e.xyy is equal to (0.001,0.0,0.0) 
      //e.yxy is equal to (0.0,0.001,0.0)
      //e.xxy is equal to (0.0,0.0,0.001)

      //simple phong LightPosition=CameraPosition    
      float b=dot(n,normalize(E-p));
      finalColor=vec4((b*c+pow(b,8.0))*(1.0-totalDist*.01),1.0);
    }
    else if (SHADING_MODE==RAYMARCH_SHADING){
      //Shading based on raymarched distance
      float v = 1.0-float(steps)/float(MAX_STEPS);
      float R=v*c.r, G=v*c.g, B=v*c.b;
      finalColor=vec4(R,G,B,1.0);
    }
    else if (SHADING_MODE==TEST_SHADING){
      vec3 sunDir = vec3(normalize(viewDest-E)); //sun comes from the camera
      
      vec3 N = normalize(vec3(
      distanceField(p).x-distanceField(p-e.xyy).x,
      distanceField(p).x-distanceField(p-e.yxy).x,
      distanceField(p).x-distanceField(p-e.yyx).x)); //normal at point
      
      vec3 L = sunDir;
      vec3 V = normalize(E-p);
      
      // color info is stored in y component
      if (dist.y==0.0) // floor color
        finalColor=vec4(color_checkers(p),1.0);
      if(dist.y==1.0) // building color
        finalColor=vec4(COLOR_GREY,1.0);
      
      //calculate lighting: diffuse + sunlight
      float diffuseTerm = clamp(dot(V,N), 0.0, 1.0);
      finalColor = mix(finalColor, sunColor, diffuseTerm);      
      
    }
  }
  //apply fog
  vec3 r = p-E;
  finalColor = applyFog(finalColor, r);
  gl_FragColor = finalColor;
}


// Fog (credit: http://www.mazapan.se/news/2010/07/15/gpu-ray-marching-with-distance-fields/)
vec4 applyFog (in vec4 currColor, in vec3 ray){
  float rayLength = length(ray);
  vec3 nRay = ray/rayLength;
  
  float fogAmount = 1.0-exp(-rayLength * 0.02); //0.008
  float sunAmount = 0.0;//pow( max( dot (nRay, sunDir), 0.0), 8.0);
  
  vec4 fogColor = mix(vec4(0.5,0.6,0.7,1.0), vec4(1.0,0.9,0.7,1.0), sunAmount);
  return mix(currColor, fogColor, fogAmount);
}

    </script>
<script id="sunset" type="x-shader/x-fragment">
precision highp float;

const bool USE_MOUSE = true; // Set this to true for God Mode :)

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;
const float PI = 3.14159265;
const float MAX_RAYMARCH_DIST = 150.0;
const float MIN_RAYMARCH_DELTA = 0.00015; 
const float GRADIENT_DELTA = 0.015;
float waveHeight1 = 0.005;
float waveHeight2 = 0.004;
float waveHeight3 = 0.001;

// --------------------- START of SIMPLEX NOISE
//
// Description : Array and textureless GLSL 2D simplex noise function.
//      Author : Ian McEwan, Ashima Arts.
//  Maintainer : ijm
//     Lastmod : 20110822 (ijm)
//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
//               Distributed under the MIT License. See LICENSE file.
//               https://github.com/ashima/webgl-noise
// 

vec3 mod289(vec3 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec2 mod289(vec2 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec3 permute(vec3 x) {
  return mod289(((x*34.0)+1.0)*x);
}

float snoise(vec2 v)
  {
  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                     -0.577350269189626,  // -1.0 + 2.0 * C.x
                      0.024390243902439); // 1.0 / 41.0
// First corner
  vec2 i  = floor(v + dot(v, C.yy) );
  vec2 x0 = v -   i + dot(i, C.xx);

// Other corners
  vec2 i1;
  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0
  //i1.y = 1.0 - i1.x;
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  // x0 = x0 - 0.0 + 0.0 * C.xx ;
  // x1 = x0 - i1 + 1.0 * C.xx ;
  // x2 = x0 - 1.0 + 2.0 * C.xx ;
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;

// Permutations
  i = mod289(i); // Avoid truncation effects in permutation
  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
    + i.x + vec3(0.0, i1.x, 1.0 ));

  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
  m = m*m ;
  m = m*m ;

// Gradients: 41 points uniformly over a line, mapped onto a diamond.
// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)

  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;

// Normalise gradients implicitly by scaling m
// Approximation of: m *= inversesqrt( a0*a0 + h*h );
  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );

// Compute final noise value at P
  vec3 g;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}

// --------------------- END of SIMPLEX NOISE


float map(vec3 p) {
  return p.y + (0.5 + waveHeight1 + waveHeight2 + waveHeight3) 
    + snoise(vec2(p.x + time * 0.4, p.z + time * 0.6)) * waveHeight1
    + snoise(vec2(p.x * 1.6 - time * 0.4, p.z * 1.7 - time * 0.6)) * waveHeight2
      + snoise(vec2(p.x * 6.6 - time * 1.0, p.z * 2.7 + time * 1.176)) * waveHeight3;
}

vec3 gradientNormalFast(vec3 p, float map_p) {
    return normalize(vec3(
        map_p - map(p - vec3(GRADIENT_DELTA, 0, 0)),
        map_p - map(p - vec3(0, GRADIENT_DELTA, 0)),
        map_p - map(p - vec3(0, 0, GRADIENT_DELTA))));
}

float intersect(vec3 p, vec3 ray_dir, out float map_p, out int iterations) {
  iterations = 0;
  if (ray_dir.y >= 0.0) { return -1.0; } // to see the sea you have to look down
  
  float distMin = (- 0.5 - p.y) / ray_dir.y;
  float distMid = distMin;
  for (int i = 0; i < 50; i++) {
    //iterations++;
    distMid += max(0.05 + float(i) * 0.002, map_p);
    map_p = map(p + ray_dir * distMid);
    if (map_p > 0.0) { 
      distMin = distMid + map_p;
    } else { 
      float distMax = distMid + map_p;
      // interval found, now bisect inside it
      for (int i = 0; i < 10; i++) {
        //iterations++;
        distMid = distMin + (distMax - distMin) / 2.0;
        map_p = map(p + ray_dir * distMid);
        if (abs(map_p) < MIN_RAYMARCH_DELTA) return distMid;
        if (map_p > 0.0) {
          distMin = distMid + map_p;
        } else {
          distMax = distMid + map_p;
        }
      }
      return distMid;
    }
  }
  return distMin;
}

void main( void ) {
  float waveHeight = USE_MOUSE ? mouse.x * 5.0 : cos(time * 0.03) * 1.2 + 1.6;
  waveHeight1 *= waveHeight;
  waveHeight2 *= waveHeight;
  waveHeight3 *= waveHeight;
  
  vec2 position = vec2((gl_FragCoord.x - resolution.x / 2.0) / resolution.y, (gl_FragCoord.y - resolution.y / 2.0) / resolution.y);
  vec3 ray_start = vec3(0, 0.2, -2);
  vec3 ray_dir = normalize(vec3(position,0) - ray_start);
  ray_start.y = cos(time * 0.5) * 0.2 - 0.25 + sin(time * 2.0) * 0.05;
  
  const float dayspeed = 0.04;
  float subtime = max(-0.16, sin(time * dayspeed) * 0.2);
  float middayperc = USE_MOUSE ? mouse.y * 0.3 - 0.15 : max(0.0, sin(subtime));
  vec3 light1_pos = vec3(0.0, middayperc * 200.0, USE_MOUSE ? 200.0 : cos(subtime * dayspeed) * 200.0);
  float sunperc = pow(max(0.0, min(dot(ray_dir, normalize(light1_pos)), 1.0)), 190.0 + max(0.0,light1_pos.y * 4.3));
  vec3 suncolor = (1.0 - max(0.0, middayperc)) * vec3(1.5, 1.2, middayperc + 0.5) + max(0.0, middayperc) * vec3(1.0, 1.0, 1.0) * 4.0;
  vec3 skycolor = vec3(middayperc + 0.8, middayperc + 0.7, middayperc + 0.5);
  vec3 skycolor_now = suncolor * sunperc + (skycolor * (middayperc * 1.6 + 0.5)) * (1.0 - sunperc);
  vec4 color = vec4(0.0, 0.0, 0.0, 1.0);
  float map_p;
  int iterations;
  float dist = intersect(ray_start, ray_dir, map_p, iterations);
  if (dist > 0.0) {
    vec3 p = ray_start + ray_dir * dist;
    vec3 light1_dir = normalize(light1_pos - p);
          vec3 n = gradientNormalFast(p, map_p);
    vec3 ambient = skycolor_now * 0.1;
          vec3 diffuse1 = vec3(1.1, 1.1, 0.6) * max(0.0, dot(light1_dir, n)  * 2.8);
    vec3 r = reflect(light1_dir, n);
    vec3 specular1 = vec3(1.5, 1.2, 0.6) * (0.8 * pow(max(0.0, dot(r, ray_dir)), 200.0));     
    float fog = min(max(p.z * 0.07, 0.0), 1.0);
          color.rgb = (vec3(0.6,0.6,1.0) * diffuse1 + specular1 + ambient)  * (1.0 - fog) + skycolor_now * fog;
      } else {
          color.rgb = skycolor_now.rgb;
      }
  gl_FragColor = color;
}
    </script>
<script id="big white lines" type="x-shader/x-fragment">
                    #ifdef GL_ES
precision mediump float;
#endif

// quadratic bezier curve evaluation
// posted by Trisomie21

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

int solveCubic(in float a, in float b, in float c, out float r[3])
{
  float  p = b - a*a / 3.0;
  float  q = a * (2.0*a*a - 9.0*b) / 27.0 + c;
  float p3 = p*p*p;
  float  d = q*q + 4.0*p3 / 27.0;
  float offset = -a / 3.0;
  if(d >= 0.0) { // Single solution
    float z = sqrt(d);
    float u = (-q + z) / 2.0;
    float v = (-q - z) / 2.0;
    u = sign(u)*pow(abs(u), 1.0/3.0);
    v = sign(v)*pow(abs(v), 1.0/3.0);
    if(abs(p) < abs(q)*0.005) {
      if(q <0.0) v = p / (3.0 * -pow(-q, 1.0/3.0));
      else u = p / (3.0 * pow(q, 1.0/3.0)); 
    }     
    r[0] = offset + u + v;
    return 1;
  }
  float u = sqrt(-p / 3.0);
  float v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;
  float m = cos(v), n = sin(v)*1.732050808;
  r[0] = offset + u * (m + m);
  r[1] = offset - u * (n + m);
  r[2] = offset + u * (n - m);
  return 3;
}


float DistanceToQBSpline(in vec2 P0, in vec2 P1, in vec2 P2, in vec2 p)
{
  float dis = 1e20;
  
  vec2  sb = (P1 - P0) * 2.0;
  vec2  sc = P0 - P1 * 2.0 + P2;
  vec2  sd = P1 - P0;
  float sA = 1.0 / dot(sc, sc);
  float sB = 3.0 * dot(sd, sc);
  float sC = 2.0 * dot(sd, sd);
  
  vec2  D = P0 - p;

  float a = sA;
  float b = sB;
  float c = sC + dot(D, sc);
  float d = dot(D, sd);

      float res[3];
  int n = solveCubic(b*a, c*a, d*a, res);

  float t = clamp(res[0],0.0, 1.0);
  vec2 pos = P0 + (sb + sc*t)*t;
  dis = min(dis, length(pos - p));
  
      if(n>1) {
  t = clamp(res[1],0.0, 1.0);
  pos = P0 + (sb + sc*t)*t;
  dis = min(dis, length(pos - p));
      
  t = clamp(res[2],0.0, 1.0);
  pos = P0 + (sb + sc*t)*t;
  dis = min(dis, length(pos - p));      
      }

      return dis;
}

void main(void)
{
  vec2 position = gl_FragCoord.xy;
  const int pointCount = 4;
  vec2 p[2 * pointCount + 1];
  
  p[0] = vec2(resolution.x*0.5,resolution.y*.2);
  p[1] = mouse*resolution;
  p[2] = vec2(resolution.x*0.4,resolution.y*.8);
  p[4] = vec2(resolution.x*0.6,resolution.y*.8);
  p[6] = vec2(resolution.x*0.6,resolution.y*.6);
  p[8] = vec2(resolution.x*0.7,resolution.y*.2);
  
  float d = 9999.0;
  for (int i = 0; i < pointCount; ++i)
  {
    if (i > 0)
      p[2*i+1] = 2.0 * p[2*i] - p[2*i - 1];
    d = min(d, DistanceToQBSpline(p[2*i], p[2*i + 1], p[2*i + 2], position));
  }
  
  float lineThickness = 12.0;
  float lineSoftness = 1.0;
  float outline = 1.0;
  d = (d - (lineThickness-1.0)) / lineSoftness;
  if(outline>0.0) d = abs(d)-outline;
  
  // Curve Control point
  
  d = clamp(d, 0.0, 1.0);
  d = mix(0.8, 0.5, d);
  gl_FragColor = vec4(d,d,d, 1.0);
}
    </script>
<script id="big lines" type="x-shader/x-fragment">
    #ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

const float pi   = 3.1415926535897932384626433832795; //pi
const float cupi = 1.4645918875615232630201425272638; //curt of pi
const float twpi = 6.283185307179586476925286766559 ; //2 x pi 

const float rez = cupi*twpi;

vec3 rotate(vec3 v,vec2 r) 
{
  mat3 rxmat = mat3(1,   0    ,    0    ,
        0,cos(r.y),-sin(r.y),
        0,sin(r.y), cos(r.y));
  mat3 rymat = mat3(cos(r.x), 0,-sin(r.x),
           0    , 1,    0    ,
        sin(r.x), 0,cos(r.x));

  return v*rxmat*rymat;
}

float snoise(vec3 v);

void main()
{
  vec2 res = vec2(resolution.x/resolution.y,1.0);
  vec2 p = ( gl_FragCoord.xy / resolution.y ) -(res/2.0);
  vec2 m = (0.3)*pi*vec2(2.,1.);
  vec3 color = vec3(0.0);
  vec3 pos = normalize(rotate(vec3(p,0.9),vec2(m)));
  float dist = 0.000001;
  float shell = abs(snoise(pos*0.3+vec3(time/2.0,0,0)*0.3));
  dist = max(dist,shell*(1.3));
  color = mix(vec3(1,1,1),vec3(.1,0.5 + ( ( 0.5 + cos(time) * 0.5 ) / 2.0 )  ,0.95),1.-dist); 
  gl_FragColor = vec4(color.xyz, 1.0 );
}

//
// Description : Array and textureless GLSL 2D/3D/4D simplex 
//               noise functions.
//      Author : Ian McEwan, Ashima Arts.
//  Maintainer : ijm
//     Lastmod : 20110822 (ijm)
//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
//               Distributed under the MIT License. See LICENSE file.
//               https://github.com/ashima/webgl-noise
// 

vec3 mod289(vec3 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 mod289(vec4 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 permute(vec4 x) {
     return mod289(((x*34.0)+1.0)*x);
}

vec4 taylorInvSqrt(vec4 r)
{
  return 1.79284291400159 - 0.85373472095314 * r;
}

float snoise(vec3 v)
  { 
  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

// First corner
  vec3 i  = floor(v + dot(v, C.yyy) );
  vec3 x0 =   v - i + dot(i, C.xxx) ;

// Other corners
  vec3 g = step(x0.yzx, x0.xyz);
  vec3 l = 1.0 - g;
  vec3 i1 = min( g.xyz, l.zxy );
  vec3 i2 = max( g.xyz, l.zxy );

  //   x0 = x0 - 0.0 + 0.0 * C.xxx;
  //   x1 = x0 - i1  + 1.0 * C.xxx;
  //   x2 = x0 - i2  + 2.0 * C.xxx;
  //   x3 = x0 - 1.0 + 3.0 * C.xxx;
  vec3 x1 = x0 - i1 + C.xxx;
  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y

// Permutations
  i = mod289(i); 
  vec4 p = permute( permute( permute( 
             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
    
// Gradients: 7x7 points over a square, mapped onto an octahedron.
// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
  float n_ = 0.142857142857; // 1.0/7.0
  vec3  ns = n_ * D.wyz - D.xzx;

  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)

  vec4 x_ = floor(j * ns.z);
  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

  vec4 x = x_ *ns.x + ns.yyyy;
  vec4 y = y_ *ns.x + ns.yyyy;
  vec4 h = 1.0 - abs(x) - abs(y);

  vec4 b0 = vec4( x.xy, y.xy );
  vec4 b1 = vec4( x.zw, y.zw );

  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;
  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;
  vec4 s0 = floor(b0)*2.0 + 1.0;
  vec4 s1 = floor(b1)*2.0 + 1.0;
  vec4 sh = -step(h, vec4(0.0));

  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

  vec3 p0 = vec3(a0.xy,h.x);
  vec3 p1 = vec3(a0.zw,h.y);
  vec3 p2 = vec3(a1.xy,h.z);
  vec3 p3 = vec3(a1.zw,h.w);

//Normalise gradients
  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;

// Mix final noise value
  vec4 m = max(0.7 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
  m = m * m;
  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                                dot(p2,x2), dot(p3,x3) ) );
  }
</script>
    <script id="ripple" type="x-shader/x-fragment">
                  

                    //水波
                    precision mediump float;

                          uniform float     time;
                          uniform vec2      resolution;
                          uniform vec2      mouse;
                    varying vec2 surfacePosition;

                          #define MAX_ITER 5

                          void main( void )
                          {
                              vec2 v_texCoord = gl_FragCoord.xy / resolution;

                              vec2 p =  v_texCoord * 8.0 - vec2(20.0);
                      p = (surfacePosition - vec2(1.5))* 8.0;
                              vec2 i = p;
                              float c = 1.0;
                              float inten = .03;

                              for (int n = 0; n < MAX_ITER; n++)
                              {
                                  float t = time * (1.0 - (3.0 / float(n+1)));

                                  i = p + vec2(cos(t - i.x) + sin(t + i.y),
                                  sin(t - i.y) + cos(t + i.x));
                          
                                  c += 1.0/length(vec2(p.x / (sin(i.x+t)/inten),
                                  p.y / (cos(i.y+t)/inten)));
                              }

                              c /= float(MAX_ITER);
                              c = 1.5 - sqrt(c);

                              vec4 texColor = vec4(0.02, 0.15, 0.02, 1.);

                              texColor.rgb *= (1.0 / (1.0 - (c + 0.05)));

                              gl_FragColor = texColor;
                          }



</script>

    <script id="tree" type="x-shader/x-fragment">



                    //变化的树
                    #ifdef GL_ES
                    precision mediump float;
                    #endif

                    #extension GL_OES_standard_derivatives : enable

                    uniform float time;
                    uniform vec2 mouse;
                    uniform vec2 resolution;
                    varying vec2 surfacePosition;

                    void main( void ) {

                      gl_FragColor = vec4( 1.0 );
                      
                      vec2 Z = 10.*(surfacePosition-vec2(0.,.09));
                      float width = 1.5;
                      for(float i = 0.; i <= 1.; i += 1./64.){
                        //if(i > mouse.x) return;
                        if(-Z.y - abs(Z.x) > 0. && Z.y > -width) gl_FragColor *= vec4(i*3.,.4+i/1.,0,1);
                        float ph = -sign(Z.x)*3.14159/(4.+8.*(mouse.y-.5));
                        Z += vec2(-sign(Z.x)*width*1.0,0.);
                        Z *= mat2(cos(ph), sin(ph), -sin(ph), cos(ph));
                        width /= sqrt(2.+4.*(mouse.x-.5));
                      }
                    }


</script>

    <script id="pillar" type="x-shader/x-fragment">


                    //立体的柱子
                    #ifdef GL_ES
                    precision mediump float;
                    #endif

                    #extension GL_OES_standard_derivatives : enable

                    uniform float time;
                    uniform vec2 mouse;
                    uniform vec2 resolution;

                    float sdBox( vec3 p, vec3 b ) {
                      vec3 d = abs(p) - b;
                      return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
                    }

                    float sdCapsule(vec3 p, vec3 a, vec3 b, float r) {
                      vec3 pa = p - a;
                      vec3 ba = b - a;
                      float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
                      return length(pa - h * ba) - r;
                    }

                    float sdCappedCylinder( vec3 p, vec2 h ) {
                      vec2 d = abs(vec2(length(p.xz),p.y)) - h;
                      return min(max(d.x,d.y),0.0) + length(max(d,0.0));
                    }

                    vec3 tri(in vec3 x){return abs(fract(x)-.5);}
                    float surfFunc(in vec3 p){
                      return dot(tri(p*0.5 + tri(p*0.25).yzx), vec3(0.666));
                    }

                    float smin(float a, float b, float k) {
                      float h = clamp((b - a)/k *0.5 + 0.5, 0.0, 1.0);
                      return mix(b, a, h) - k * h * (1.0 - h);
                    }

                    float hash(vec2 p) {
                      return fract(sin(p.x * 15.57 + p.y * 37.89) * 43758.26);
                    }

                    float map(vec3 p) {

                      vec3 q = p;
                      q.x *= 1.0 + 0.5 * cos(q.y / 0.8 * 3.141592);
                      float d = sdCappedCylinder(q, vec2(0.4, 0.4));
                      d = max(d, -sdBox(q, vec3(5.0, 0.15, 0.15)));
                      d = min(d, sdBox(p - vec3(0.0, 0.0, -1.0), vec3(1.0, 1.0, 0.01)));
                      d = min(d, sdBox(p - vec3(0.0, -1.0, 0.0), vec3(1.0, 0.01, 1.0)));
                      d = min(d, sdBox(p - vec3(1.0, 0.0, 0.0), vec3(0.01, 1.0, 1.0)));
                      return d;
                    }

                    vec3 calcNormal(vec3 p) {
                      vec2 e = vec2(-1.0, 1.0) * 0.001;
                      return normalize(
                        e.xyy * map(p + e.xyy) +
                        e.yxy * map(p + e.yxy) +
                        e.yyx * map(p + e.yyx) +
                        e.xxx * map(p + e.xxx)
                      );
                    }

                    float calcAO(in vec3 ro, in vec3 rd) {
                      float t = 0.0;
                      float h = 0.0;
                      float occ = 0.0;
                      for(int i = 0; i < 5; i++) {
                        t = 0.01 + 0.12*float(i)/4.0;
                        h = map(ro + rd * t);
                        occ += (t-h)*(4.0-float(i));
                      }
                      return clamp(1.0 - 2.0*occ, 0.0, 1.0);
                    }

                    float softshadow(in vec3 ro, in vec3 rd, in float tmin, in float tmax) {
                      float t = tmin;
                      float h = 0.0;
                      float sh = 1.0;
                      for(int i = 0; i < 20; i++) {
                      if(t > tmax) continue;
                        h = map(ro + rd * t);
                        sh = min(sh, h/t*50.0);
                        t += h * 0.5;
                      }
                      return clamp(sh, 0.0, 1.0);
                    }

                    float trace(in vec3 ro, in vec3 rd){
                      float FAR = 50.0;
                      float t = 0.0, h;
                      for(int i = 0; i < 72; i++){
                      h = map(ro+rd*t);
                      if(abs(h)<0.002*(t*.125 + 1.) || t>FAR) break;       
                        t += step(h, 1.)*h*.2 + h*.35;
                      }
                      
                      return min(t, FAR);
                    }

                    void main() {
                      vec2 uv = (gl_FragCoord.xy - 0.5*resolution.xy) / resolution.y;
                      
                      vec3 ro = vec3(-6.0, 3.0, 6.0) + vec3(mouse.x * 2.0 - 1.0, 0.0, 0.0) * 3.0;
                      vec3 ta = vec3(0.0, 0.0, 0.0);
                      
                      vec3 cw = normalize(ta - ro);
                      vec3 cup = vec3(0.0, 1.0, 0.0);
                      vec3 cu = normalize(cross(cw, cup));
                      vec3 cv = normalize(cross(cu, cw));
                      
                      float pi = 3.141592;
                      float fovy = pi / 4.0;
                      float f = tan(fovy * 0.5);
                      vec3 rd = normalize(cu * uv.x + cv * uv.y + (1.0/f) * cw);
                      
                        //-----

                      float e = 0.001;
                      float h = 2.0 * e;
                      float t = trace(ro, rd);
                      
                      float ff = clamp((t - 1.0) / 30.0, 0.0, 1.0);
                      ff = exp(-3. * ff);
                      vec3 sky = vec3(0., .9, 2.8);
                      vec3 col = sky;
                      
                      vec3 lig_pos0 = vec3(0.0, 1.0, 0.0) * 10.0;
                      vec3 lig_pos1 = vec3(-1.0, 0.0, 0.0) * 10.0;
                      vec3 lig_pos2 = vec3(0.0, 0.0, 1.0) * 10.0;
                      
                      float dur = 10.0;
                      float tt = mod(time, dur) / dur;
                      
                      vec3 lig_pos = mix(lig_pos0, lig_pos1, smoothstep(0.0, 0.333, tt));
                      lig_pos = mix(lig_pos, lig_pos2, smoothstep(0.333, 0.666, tt));
                      lig_pos = mix(lig_pos, lig_pos0, smoothstep(0.666, 1.0, tt));
                      if(t < 50.0) {
                        vec3 pos = ro + rd * t;
                        vec3 nor = calcNormal(pos);
                        vec3 lig = normalize(lig_pos);
                        float dif = clamp(dot(nor, lig), 0.0, 1.0);
                        vec3 ref = reflect(rd, nor);
                        float spe = pow(clamp(dot(ref, lig), 0.0, 1.0), 64.0);
                        float sh = softshadow(pos, lig, 0.01, 10.0);
                        float fre = 1.0 - dot(nor, -rd);
                        
                        col = vec3(1.0) * (dif + spe + fre * 0.5) * sh;
                        col = mix(sky, col, ff);
                      }
                      
                      gl_FragColor = vec4(col, 1.0);
                    }


</script>

    <script id="cement flower" type="x-shader/x-fragment">



                    //水泥花朵
                    #ifdef GL_ES
                    precision mediump float;
                    #endif

                    #extension GL_OES_standard_derivatives : enable

                    uniform float time;
                    uniform vec2 mouse;
                    uniform vec2 resolution;


                    //----------------------------------------------------------------------
                    // FlowerTest.glsl
                    // original:   https://www.shadertoy.com/view/MltSRf
                    // RayMarcher Created by inigo quilez - iq/2013
                    // License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
                    //----------------------------------------------------------------------

                    float ballFlower (vec3 p)
                    { 
                      const float radius = 1.0;
                      float q = length(p);
                      p.y -= 0.4;
                    //  p.xz *= 5.4;
                      vec3 n = p; // normalize(p);
                      float rho   = atan(length(vec2(n.x,n.z)),n.y)*20.0 + q*15.0;
                      float theta = atan(n.x,n.z)*9.0 + p.y*5.0+rho;
                      float a = 0.1*(1.2-abs(dot(n,vec3(0,1,0)) ));
                      return q -radius + a*cos(theta) + a*sin(rho - time);
                    }
                    //----------------------------------------------------------------------

                    vec2 map( in vec3 pos )
                    {    
                        return vec2( ballFlower(pos),11) ;
                    }

                    vec2 castRay( in vec3 ro, in vec3 rd )
                    {
                        float tmin = 1.0;
                        float tmax = 20.0;
                        
                    #if 0
                        float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );
                        float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );
                                                                     else           tmax = min( tmax, tp2 ); }
                    #endif
                        
                        float precis = 0.002;
                        float t = tmin*0.1;
                        float m = -1.0;
                        for( int i=0; i<215; i++ )
                        {
                            vec2 res = map( ro+rd*t );
                            if( res.x<precis || t>tmax ) break;
                            t += res.x*0.3;
                            m = res.y;
                        }
                        if( t>tmax ) m=-1.0;
                        return vec2( t, m );
                    }

                    float softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
                    {
                        float res = 1.0;
                        float t = mint;
                        for( int i=0; i<16; i++ )
                        {
                            float h = map( ro + rd*t ).x;
                            res = min( res, 8.0*h/t );
                            t += clamp( h, 0.02, 0.10 );
                            if( h<0.001 || t>tmax ) break;
                        }
                        return clamp( res, 0.0, 1.0 );
                    }

                    vec3 calcNormal( in vec3 pos )
                    {
                        vec3 eps = vec3( 0.001, 0.0, 0.0 );
                        vec3 nor = vec3( map(pos+eps.xyy).x - map(pos-eps.xyy).x,
                                         map(pos+eps.yxy).x - map(pos-eps.yxy).x,
                                         map(pos+eps.yyx).x - map(pos-eps.yyx).x );
                        return normalize(nor);
                    }

                    float calcAO( in vec3 pos, in vec3 nor )
                    {
                        float occ = 0.0;
                        float sca = 1.0;
                        for( int i=0; i<5; i++ )
                        {
                            float hr = 0.01 + 0.12*float(i)/4.0;
                            vec3 aopos =  nor * hr + pos;
                            float dd = map( aopos ).x;
                            occ += -(dd-hr)*sca;
                            sca *= 0.95;
                        }
                        return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    
                    }

                    vec3 render( in vec3 ro, in vec3 rd )
                    { 
                        vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;
                        vec2 res = castRay(ro,rd);
                        float t = res.x;
                      float m = res.y;
                        if( m > -0.5 )
                        {
                            vec3 pos = ro + t*rd;
                            vec3 nor = calcNormal( pos );
                            vec3 ref = reflect( rd, nor );
                            
                            // material        
                            col = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );
                        
                            if( m<1.5 )
                            {
                                float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);
                                col = 0.4 + 0.1*f*vec3(1.0);
                            }

                            // lighting        
                            float occ = calcAO( pos, nor );
                            vec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );
                            float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );
                            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );
                            float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);
                            float dom = smoothstep( -0.1, 0.1, ref.y );
                            float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );
                            float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);
                            
                            dif *= softshadow( pos, lig, 0.02, 2.5 );
                            dom *= softshadow( pos, ref, 0.02, 2.5 );

                            vec3 lin = vec3(0.0);
                            lin += 1.20*dif*vec3(1.00,0.85,0.55);
                            lin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;
                            lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;
                            lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;
                            lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;
                            lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;
                            col = col*lin;

                          col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );
                        }
                        return vec3( clamp(col,0.0,1.0) );
                    }

                    mat3 setCamera( in vec3 ro, in vec3 ta, float cr )
                    {
                        vec3 cw = normalize(ta-ro);
                        vec3 cp = vec3(sin(cr), cos(cr),0.0);
                        vec3 cu = normalize( cross(cw,cp) );
                        vec3 cv = normalize( cross(cu,cw) );
                        return mat3( cu, cv, cw );
                    }

                    void main()
                    {
                        vec2 q = gl_FragCoord.xy / resolution.xy;
                        vec2 p = 2.0*q - 1.0;
                        p.x *= resolution.x / resolution.y;
                        vec2 mo =  mouse.xy;
                         
                        float time = 15.0 + time;

                        // camera 
                        vec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), -0.0 + 4.0*mo.y, 0.5 + 3.5*sin(0.1*time + 6.0*mo.x) );
                        vec3 ta = vec3( -0.5, -0.4, 0.5 );
                      
                        // camera-to-world transformation
                        mat3 ca = setCamera( ro, ta, 0.0 );
                        
                        // ray direction
                        vec3 rd = ca * normalize( vec3(p.xy,2.0) );

                        // render 
                        vec3 col = render( ro+vec3(1,0,0), rd );

                        col = pow( col, vec3(0.7) );

                        gl_FragColor=vec4( col, 1.0 );
                    }


</script>

    <script id="electricty country" type="x-shader/x-fragment">



                    //电子国度
                    #ifdef GL_ES
                    precision mediump float;
                    #endif
                     
                    uniform float time;
                    uniform vec2 mouse;
                    uniform vec2 resolution;
                     
                    // by srtuss, 2013
                    // was trying to find some sort of "mechanical" fractal for texture/heightmap
                    // generation, but then i ended up with this.
                     
                    // rotate position around axis
                    vec2 rotate(vec2 p, float a)
                    {
                      return vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));
                    }
                     
                    // 1D random numbers
                    float rand(float n)
                    {
                        return fract(sin(n) * 43758.5453123);
                    }
                     
                    // 2D random numbers
                    vec2 rand2(in vec2 p)
                    {
                      return fract(vec2(sin(p.x * 1.32 + p.y * 54.077), cos(p.x * 91.32 + p.y * 9.077)));
                    }
                     
                    // 1D noise
                    float noise1(float p)
                    {
                      float fl = floor(p);
                      float fc = fract(p);
                      return mix(rand(fl), rand(fl + 1.0), fc);
                    }
                     
                    // voronoi distance noise, based on iq's articles
                    float voronoi(in vec2 x)
                    {
                      vec2 p = floor(x);
                      vec2 f = fract(x);
                      
                      vec2 res = vec2(8.0);
                      for(int j = -1; j <= 1; j ++)
                      {
                        for(int i = -1; i <= 1; i ++)
                        {
                          vec2 b = vec2(i, j);
                          vec2 r = vec2(b) - f + rand2(p + b);
                          
                          // chebyshev distance, one of many ways to do this
                          float d = max(abs(r.x), abs(r.y));
                          
                          if(d < res.x)
                          {
                            res.y = res.x;
                            res.x = d;
                          }
                          else if(d < res.y)
                          {
                            res.y = d;
                          }
                        }
                      }
                      return res.y - res.x;
                    }
                     
                     
                    #define flicker (noise1(time * 2.0) * 0.9 + 0.5)
                     
                    void main(void)
                    {
                      vec2 uv = gl_FragCoord.xy / resolution.xy;
                      uv = (uv - 0.5) * 2.0;
                      vec2 suv = uv;
                      uv.x *= resolution.x / resolution.y;
                      
                      
                      float v = 0.0;
                      
                      // that looks highly interesting:
                      //v = 1.0 - length(uv) * 1.3;
                      
                      
                      // a bit of camera movement
                      uv *= 0.6 + sin(time * 0.1) * 0.1;
                      uv = rotate(uv, sin(time * 0.3) * 1.0);
                      uv += time * 0.4;
                      
                      
                      // add some noise octaves
                      float a = 0.6, f = 1.0;
                      
                      for(int i = 0; i < 3; i ++) // 4 octaves also look nice, its getting a bit slow though
                      { 
                        float v1 = voronoi(uv * f + 1.0);
                        float v2 = 0.0;
                        
                        // make the moving electrons-effect for higher octaves
                        if(i > 0)
                        {
                          // of course everything based on voronoi
                          v2 = voronoi(uv * f * 0.5 + 5.0 + time);
                          
                          float va = 0.0, vb = 0.0;
                          va = 1.0 - smoothstep(0.0, 0.1, v1);
                          vb = 1.0 - smoothstep(0.0, 0.08, v2);
                          v += a * pow(va * (0.5 + vb), 2.0);
                        }
                        
                        // make sharp edges
                        v1 = 1.0 - smoothstep(0.0, 0.3, v1);
                        
                        // noise is used as intensity map
                        v2 = a * (noise1(v1 * 5.5 + 0.1));
                        
                        // octave 0's intensity changes a bit
                        if(i == 0)
                          v += v2 * flicker;
                        else
                          v += v2;
                        
                        f *= 3.0;
                        a *= 0.7;
                      }
                     
                      // slight vignetting
                      v *= exp(-0.6 * length(suv)) * 1.2;
                      
                      // use texture channel0 for color? why not.
                      //vec3 cexp = texture2D(iChannel0, uv * 0.001).xyz * 3.0 + texture2D(iChannel0, uv * 0.01).xyz;//vec3(1.0, 2.0, 4.0);
                      
                      // old blueish color set
                      vec3 cexp = vec3(3.0, 1.0, 3.0);
                        cexp *= 1.3;
                     
                      vec3 col = vec3(pow(v, cexp.x), pow(v, cexp.y), pow(v, cexp.z)) * 2.0;
                      
                      gl_FragColor = vec4(col, 1.0);
                    }


</script>

    <script id="red stars" type="x-shader/x-fragment">



                    //红色星云
                    #ifdef GL_ES
                    precision mediump float;
                    #endif
                     
                     
                    uniform float time;
                    uniform vec2 mouse;
                    uniform vec2 resolution;


                    #define iterations 14
                    #define formuparam2 (0.3 + 0.7*(abs(2.0*(fract(time*0.002))-1.0)))
                     
                    #define volsteps 5
                    #define stepsize 0.290
                     
                    #define zoom 0.900
                    #define tile   0.850
                    #define speed2  0.80
                     
                    #define brightness 0.003
                    #define darkmatter 0.400
                    #define distfading 0.560
                    #define saturation 0.800


                    #define transverseSpeed zoom*2.0
                    #define cloud 0.11 

                     
                    float triangle(float x, float a) { 
                      float output2 = 2.0*abs(  2.0*  ( (x/a) - floor( (x/a) + 0.5) ) ) - 1.0;
                      return output2;
                    }
                     
                    float field(in vec3 p) {  
                      float strength = 7. + .03 * log(1.e-6 + fract(sin(time) * 4373.11));
                      float accum = 0.;
                      float prev = 0.;
                      float tw = 0.;  

                      for (int i = 0; i < 6; ++i) {
                        float mag = dot(p, p);
                        p = abs(p) / mag + vec3(-.5, -.8 + 0.1*sin(time*0.7 + 2.0), -1.1+0.3*cos(time*0.3));
                        float w = exp(-float(i) / 7.);
                        accum += w * exp(-strength * pow(abs(mag - prev), 2.3));
                        tw += w;
                        prev = mag;
                      }
                      return max(0., 5. * accum / tw - .7);
                    }



                    void main() {   
                          vec2 uv2 =  gl_FragCoord.xy / resolution.xy;
                      vec2 uvs =  uv2 * resolution.xy  / resolution.y;
                      
                      float time2 = time;               
                            float speed = speed2;
                            speed = .01 * cos(time2*0.02 + 3.1415926/4.0);          
                      //speed = 0.0;  
                          float formuparam = formuparam2;
                      
                          //get coords and direction  
                      vec2 uv = uvs;           
                      //mouse rotation
                      float a_xz = -0.9;
                      float a_yz = .6;
                      float a_xy = -0.9 + time*0.08;  
                      
                      mat2 rot_xz = mat2(cos(a_xz),sin(a_xz),-sin(a_xz),cos(a_xz)); 
                      mat2 rot_yz = mat2(cos(a_yz),sin(a_yz),-sin(a_yz),cos(a_yz));   
                      mat2 rot_xy = mat2(cos(a_xy),sin(a_xy),-sin(a_xy),cos(a_xy));
                      

                      float v2 =1.0;  
                      vec3 dir=vec3(uv*zoom,1.); 
                      vec3 from=vec3(0.0, 0.0,0.0);                               
                            from.x -= 5.0*(mouse.x-0.5);
                            from.y -= 5.0*(mouse.y-0.5);
                                   
                                   
                      vec3 forward = vec3(0.0,-0.0,1.);   
                      from.x += transverseSpeed*(1.0)*cos(0.01*time) + 0.001*time;
                      from.y += transverseSpeed*(1.0)*sin(0.01*time) +0.001*time;
                      from.z += 0.003*time; 
                      
                      dir.xy*=rot_xy;
                      forward.xy *= rot_xy;
                      dir.xz*=rot_xz;
                      forward.xz *= rot_xz; 
                      dir.yz*= rot_yz;
                      forward.yz *= rot_yz;
                      
                      from.xy*=-rot_xy;
                      from.xz*=rot_xz;
                      from.yz*= rot_yz;
                       
                      
                      //zoom
                      float zooom = (time2-3311.)*speed;
                      from += forward* zooom;
                      float sampleShift = mod( zooom, stepsize );
                       
                      float zoffset = -sampleShift;
                      sampleShift /= stepsize; // make from 0 to 1
                      
                      //volumetric rendering
                      float s=0.24;
                      float s3 = s + stepsize/2.0;
                      vec3 v=vec3(0.);
                      float t3 = 0.0; 
                      
                      vec3 backCol2 = vec3(0.);
                      for (int r=0; r<volsteps; r++) {
                        vec3 p2=from+(s+zoffset)*dir;// + vec3(0.,0.,zoffset);
                        vec3 p3=from+(s3+zoffset)*dir;// + vec3(0.,0.,zoffset);
                        
                        p2 = abs(vec3(tile)-mod(p2,vec3(tile*2.))); // tiling fold
                        p3 = abs(vec3(tile)-mod(p3,vec3(tile*2.))); // tiling fold    
                        #ifdef cloud
                        t3 = field(p3);
                        #endif
                        
                        float pa,a=pa=0.;
                        for (int i=0; i<iterations; i++) {
                          p2=abs(p2)/dot(p2,p2)-formuparam; // the magic formula
                          //p=abs(p)/max(dot(p,p),0.005)-formuparam; // another interesting way to reduce noise
                          float D = abs(length(p2)-pa); // absolute sum of average change
                          a += i > 7 ? min( 12., D) : D;
                          pa=length(p2);
                        }
                        
                        
                        //float dm=max(0.,darkmatter-a*a*.001); //dark matter
                        a*=a*a; // add contrast
                        //if (r>3) fade*=1.-dm; // dark matter, don't render near
                        // brightens stuff up a bit
                        float s1 = s+zoffset;
                        // need closed form expression for this, now that we shift samples
                        float fade = pow(distfading,max(0.,float(r)-sampleShift));    
                        //t3 += fade;   
                        v+=fade;
                              //backCol2 -= fade;

                        // fade out samples as they approach the camera
                        if( r == 0 )
                          fade *= (1. - (sampleShift));
                        // fade in samples as they approach from the distance
                        if( r == volsteps-1 )
                          fade *= sampleShift;
                        v+=vec3(s1,s1*s1,s1*s1*s1*s1)*a*brightness*fade; // coloring based on distance
                        
                        backCol2 += mix(.4, 1., v2) * vec3(1.8 * t3 * t3 * t3, 1.4 * t3 * t3, t3) * fade;

                        
                        s+=stepsize;
                        s3 += stepsize;   
                      }//фор
                               
                      v=mix(vec3(length(v)),v,saturation); //color adjust 

                      vec4 forCol2 = vec4(v*.01,1.);  
                      #ifdef cloud
                      backCol2 *= cloud;
                      #endif  
                      backCol2.b *= -3.8;
                      backCol2.r *= 0.05; 
                      
                      backCol2.b = 0.5*mix(backCol2.g, backCol2.b, 0.8);
                      backCol2.g = -0.;
                      backCol2.bg = mix(backCol2.gb, backCol2.bg, 0.5*(cos(time*0.01) + 1.0));  
                      gl_FragColor = forCol2 + vec4(backCol2, 1.0);
                    }



</script>

    <script id="beautiful wait" type="x-shader/x-fragment">

                    //高级等待 *****
                    #ifdef GL_ES
                    precision mediump float;
                    #endif
                    #extension GL_OES_standard_derivatives : enable
                    uniform float time;
                    uniform vec2 resolution;
                    const float INTERVAL = 2.;
                    const float PI = 3.14159265358979323844;
                    //
                    //  r*cos(a) = R + t*(R*cos(b) - R)
                    //  r*sin(a) = t*R*sin(b)
                    //
                    //  t = (r*sin(a))/(R*sin(b))
                    //
                    //  r*cos(a) = R + (r*sin(a))/(R*sin(b))*(R*cos(b) - R)
                    //  r*cos(a) = R + (r*sin(a)/sin(b))*(cos(b) - 1)
                    //  r*(cos(a) - (sin(a)/sin(b))*(cos(b) - 1)) = R
                    float inside_polygon(vec2 pos, vec2 center, float r, float n, float s)
                    {
                            float theta = 2.*PI/n;
                            vec2 d = pos - center;
                            float a = mod(mod(atan(d.y, d.x) + s, 2.*PI), theta);
                            float l = length(d);
                           float m = r*cos(.5*theta)/cos(a - .5*theta); // r/(cos(a) - (sin(a)/sin(theta))*(cos(theta) - 1.));
                           const float border = .001;
                           return smoothstep(m + border, m - border, l);
                    }
                    float wobble(vec2 pos)
                    {
                            vec2 d = pos;
                            float a = (atan(d.y, d.x) + PI/2.)/(2.*PI);
                            float l = .75;
                            float t = mod(time, INTERVAL)/INTERVAL;
                            float o = t*(1. + l);
                            return smoothstep(o, o - l, a);
                    }
                    float inside_triangle(vec2 pos, vec2 center, float r, float s)
                    {
                           return inside_polygon(pos, center, wobble(center)*r, 3., s);
                    }
                    float inside_triangles(vec2 pos, float r)
                    {
                            const float da = 2.*PI/6.;
                            float a = 0.;
                            float v = 0.;
                            for (int i = 0; i < 6; i++) {
                                    float c = cos(a);
                                    float s = sin(a);
                                    vec2 d = vec2(c, s);
                                    vec2 n = vec2(-s, c);
                                    vec2 o0 = (2./3.)*sqrt(3.)*d*r;
                                    vec2 o1 = (5./6.)*sqrt(3.)*d*r;
                                    float r_triangle = 1.*r/sqrt(3.);
                                    v += inside_triangle(pos, o0, r_triangle, a) +
                                          inside_triangle(pos, o1 - n*.5*r, r_triangle, a + PI) +
                                            inside_triangle(pos, o1 + n*.5*r, r_triangle, a + PI);
                                    a += da;
                            }
                            return v;
                    }
                    void main()
                    {
                            const float radius = 20.;
                            vec2 pos = (gl_FragCoord.xy*2. - resolution)/min(resolution.x, resolution.y);
                            float r0 = .25;
                            float r1 = 2.*r0;
                            float r = mix(r1, r0, mod(time, INTERVAL)/INTERVAL);
                            float v = (inside_triangles(pos, r) + inside_polygon(pos, vec2(0., 0.), r, 6., PI/6.));
                            vec4 bg = mix(vec4(1.,.0,1.,1.),vec4(.0,.8,1.,1.),gl_FragCoord.y/resolution.y);
                            vec4 tri = mix(vec4(1.3,.0,1.,1.),vec4(.0,1.3,1.3,1.),gl_FragCoord.y/resolution.y);
                            gl_FragColor = mix(bg, tri, v);
                            //mix(vec4(.5,.1.,1.,1.),vec4(.0,.25,.25,1.),gl_FragCoord.y/resolution.y)
                    }



</script>

    <script id="old wall" type="x-shader/x-fragment">

                    //旧旧的墙面 *****
                    // 00f404afdd835ac3af3602c8943738ea - please mark changes (and/or add docs), and retain this line.

                    #ifdef GL_ES
                    precision mediump float;
                    #endif
                     

                    uniform float time;
                    uniform vec2 mouse;
                    uniform vec2 resolution;

                    float _MinStep = 0.125;

                    //////////////////////////////////////////////////////////////
                    // http://www.gamedev.net/topic/502913-fast-computed-noise/
                    // replaced costly cos with z^2. fullreset
                    vec4 random4 (const vec4 x) {
                        vec4 z = mod(mod(x, vec4(5612.0)), vec4(3.1415927 * 2.0));
                        return fract ((z*z) * vec4(56812.5453));
                    }
                    const float A = 1.0;
                    const float B = 57.0;
                    const float C = 113.0;
                    const vec3 ABC = vec3(A, B, C);
                    const vec4 A3 = vec4(0, B, C, C+B);
                    const vec4 A4 = vec4(A, A+B, C+A, C+A+B);
                    float cnoise4 (const in vec3 xx) {
                        vec3 x = xx; // mod(xx + 32768.0, 65536.0); // ignore edge issue
                        vec3 fx = fract(x);
                        vec3 ix = x-fx;
                        vec3 wx = fx*fx*(3.0-2.0*fx);
                        float nn = dot(ix, ABC);

                        vec4 N1 = nn + A3;
                        vec4 N2 = nn + A4;
                        vec4 R1 = random4(N1);
                        vec4 R2 = random4(N2);
                        vec4 R = mix(R1, R2, wx.x);
                        float re = mix(mix(R.x, R.y, wx.y), mix(R.z, R.w, wx.y), wx.z);

                        return 1.0 - 2.0 * re;
                    }

                    //////////////////////////////////////////////////////////////
                    // distance functions
                    // http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm
                    float sdSphere( vec3 p, float s ) { return length(p)-s; }
                    float udBox( vec3 p, vec3 b ) {  return length(max(abs(p)-b,0.0)); }
                    float udRoundBox( vec3 p, vec3 b, float r ) { return length(max(abs(p)-b,0.0))-r; }
                    float sdTorus( vec3 p, vec2 t ) { vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }
                    vec3  opRep(vec3 p, vec3 r) { return mod(p,r)-0.5*r; }
                    vec3  opTx(vec3 p, mat4 m ) { return (m*vec4(p,1.0)).xyz; }

                    /////////////////////////////////////////////////////
                    // the rest

                    float fbm(vec3 p) {
                        float f;
                        f = 0.5000*cnoise4( p ); p = p*2.02;
                        f += 0.2500*cnoise4( p ); p = p*2.03;
                        f += 0.1250*cnoise4( p ); p = p*2.01;
                        f += 0.0625*cnoise4( p ); 
                      return f;
                    }

                    float scene(vec3 p) { 
                      vec3 pw = vec3(0.,0.,10.);
                      float pa = udRoundBox(p+pw,vec3(100.,5,5.),0.22);
                      float pb = udRoundBox(p-pw,vec3(100.,5,5.),0.22);
                      float d = min(pa,pb);
                      
                      pa = udRoundBox(p+pw*2.,vec3(100.,80.,.2),0.22);
                      pb = udRoundBox(p-pw*2.,vec3(100.,80.,.2),0.22);
                      d = min(d,min(pa,pb));

                      vec3 c = opRep(p,vec3(20.,4.5,14.))-vec3(0.,0.,7.);
                      d = min(d,udRoundBox(c+pw+vec3(0.,0.0,-3.),vec3(1.75,2.,0.75),0.22));

                      float e = udRoundBox(p-vec3(0.,30.,4.),vec3(100.,0.1,0.1),0.2);
                      e = min(e,udRoundBox(p-vec3(0.,31.,4.),vec3(100.,0.06,0.06),0.1));
                      e = min(e,udRoundBox(p-vec3(0.,5.,1.),vec3(100.,0.1,0.1),0.2));
                      e = min(e,udRoundBox(p-vec3(0.,4.,1.),vec3(100.,0.1,0.1),0.2)); 
                      e = min(e,udRoundBox(p-vec3(7.45,0.,-7.5),vec3(0.1,100.,0.1),0.1)); 

                      float n = fbm(p);   
                      return min(e,n*0.32+d); // 'texture'
                    }

                    vec4 color(float d) { 
                      return mix(vec4(1.,1.,1.,0.25),vec4(0.2,0.1,0.,0.05),smoothstep(0.,0.1,d)); 
                    }

                    vec4 ray(vec3 pos, vec3 step) {
                        vec4 sum = vec4(0.);
                        vec4 col;
                        float d = 9999.0;
                    #define RAY1  { d = scene(pos); col = color(d); col.rgb *= col.a; sum += col*(1.0 - sum.a); pos += step*max(d,_MinStep); }
                    #define RAY4  RAY1 RAY1 RAY1 RAY1
                        RAY4 RAY4 RAY4 RAY4
                        return sum;
                    }

                    void main( void ) {
                      vec3 e = vec3(sin(time*0.2)*20.,14.,-20.); 
                      vec3 p = vec3((gl_FragCoord.xy / resolution.xy) * 2. -1., 1.);
                      p.x *= resolution.x/resolution.y;
                      p += e;
                      gl_FragColor = ray(p, normalize(p-e));
                    }




</script>

    <script id="color lines" type="x-shader/x-fragment">






                    //淡彩色线条
                    #ifdef GL_ES
                    precision mediump float;
                    #endif

                    uniform vec2 resolution;
                    uniform float time;

                    float d2y(float d){ d*= 40.; return 1./(d*d);}

                    vec3 hsv2rgb(vec3 c)
                    {
                        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
                    }

                    float gauss(float s, float x){
                        return (0.85)*exp(-x*x/(2.*s*s));
                    }
                    #if 1
                    float blur(float dist, float width, float blur, float intens){
                        float w = width;
                        float e = 0.85*blur;
                        dist*=0.75;
                        float b = smoothstep(-w-e, -w+e, dist)-smoothstep(w-e, w+e, dist);
                        return 1.0*pow(b,1.9)*(1.+80.*blur)*intens;
                        //return 0.9*b*intens;
                    }
                    #else
                    float blur(float dist, float width, float blur, float intens){
                        float w = width;
                        dist = max(abs(dist)-width,0.);
                        float b = gauss(0.02+w*10.*blur,dist);
                        return b*intens;
                    }
                    #endif
                    float d2y2(float d, float i){
                        float b = 0.04*i+0.0001;
                        return blur(d , 0.03, b, 0.4);
                    }



                    float f(float x){
                        return blur(0.5*x, 0.03, 0.04+0.5, 1.);
                    }


                    #define N 8
                    // hauteur de la vague
                    float wave(float x, int i){
                        float i_f=float(i);
                        float fy = (3.3-0.5*i_f)*sin(x*2.+2.8*time+.6*i_f);
                        return fy * (0.4+0.3*cos(x));
                    }

                    void main(void)
                    {
                        vec2 uv = (gl_FragCoord.xy / resolution - vec2(0.5)) * vec2(resolution.x / resolution.y, 1.0) * 1.0;
                        uv.y *= 2.2;
                        uv.x *= 2.1;

                      
                        float yf = 0.*d2y(distance(uv.y*2., f(uv.x)));
                        vec3 col = vec3(0.0);
                        for(int i = 0; i<N; ++i){
                            float i_f = float(i)*0.8+1.;
                            float y = d2y2(distance(3.*uv.y, wave(uv.x, i)),i_f);
                            col += 0.8*y *hsv2rgb(vec3(0.00015*time+i_f*0.1-0.05, 0.6,1.0));
                            
                        }
                        
                        gl_FragColor = vec4(vec3(yf)+(233./255.)-col, 1.0);
                    }




</script>

    <script id="toon cloud" type="x-shader/x-fragment">





                    //卡通云 *****
                    // ----------------------------------------------------------------------------------------
                    //  "Toon Cloud" by Antoine Clappier - March 2015
                    //
                    //  Licensed under:
                    //  A Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
                    //  http://creativecommons.org/licenses/by-nc-sa/4.0/
                    // ----------------------------------------------------------------------------------------
                    // original from https://www.shadertoy.com/view/4t23RR
                    // ----------------------------------------------------------------------------------------

                    #ifdef GL_ES
                    precision mediump float;
                    #endif

                    uniform vec2 resolution;
                    uniform float time;

                    #define TAU 6.28318530718


                    const vec3 BackColor  = vec3(0.0, 0.4, 0.58);
                    const vec3 CloudColor = vec3(0.18,0.70,0.87);


                    float Func(float pX)
                    {
                      return 0.6*(0.5*sin(0.1*pX) + 0.5*sin(0.553*pX) + 0.7*sin(1.2*pX));
                    }


                    float FuncR(float pX)
                    {
                      return 0.5 + 0.25*(1.0 + sin(mod(40.0*pX, TAU)));
                    }


                    float Layer(vec2 pQ, float pT)
                    {
                      vec2 Qt = 3.5*pQ;
                      pT *= 0.5;
                      Qt.x += pT;

                      float Xi = floor(Qt.x);
                      float Xf = Qt.x - Xi -0.5;

                      vec2 C;
                      float Yi;
                      float D = 1.0 - step(Qt.y,  Func(Qt.x));

                      // Disk:
                      Yi = Func(Xi + 0.5);
                      C = vec2(Xf, Qt.y - Yi ); 
                      D =  min(D, length(C) - FuncR(Xi+ pT/80.0));

                      // Previous disk:
                      Yi = Func(Xi+1.0 + 0.5);
                      C = vec2(Xf-1.0, Qt.y - Yi ); 
                      D =  min(D, length(C) - FuncR(Xi+1.0+ pT/80.0));

                      // Next Disk:
                      Yi = Func(Xi-1.0 + 0.5);
                      C = vec2(Xf+1.0, Qt.y - Yi ); 
                      D =  min(D, length(C) - FuncR(Xi-1.0+ pT/80.0));

                      return min(1.0, D);
                    }

                    void main(void){
                      vec2 uv = 1.2*(2.0*gl_FragCoord.xy - resolution.xy) / resolution.y;
                      
                      // Render:
                      vec3 Color= BackColor;

                      for(float J=0.0; J<=1.0; J+=0.2)
                      {
                        // Cloud Layer: 
                        float Lt =  time*(0.5  + 2.0*J)*(1.0 + 0.1*sin(226.0*J)) + 17.0*J;
                        vec2 Lp = vec2(0.0, 0.3+1.5*( J - 0.5));
                        float L = Layer(uv + Lp, Lt);

                        // Blur and color:
                        float Blur = 4.0*(0.5*abs(2.0 - 5.0*J))/(11.0 - 5.0*J);

                        float V = mix( 0.0, 1.0, 1.0 - smoothstep( 0.0, 0.01 +0.2*Blur, L ) );
                        vec3 Lc=  mix( CloudColor, vec3(1.0), J);

                        Color =mix(Color, Lc,  V);
                      }
                      gl_FragColor = vec4(Color,1.);
                    }
</script>

    <script id="thinkering" type="x-shader/x-fragment">

// bpt.2017 thinkering

#ifdef GL_ES
precision highp float;
#endif

#extension GL_OES_standard_derivatives : enable

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;
varying vec2 surfacePosition;

// using as a starting point thx https://www.shadertoy.com/view/MtKSWt

vec4 BezierPoint(vec4 p0, vec4 p1, vec4 p2, float t){
    vec4 v1 = p1-p0;
    vec4 v2 = p2-p1;
    vec4 o0 = p0+v1*t;
    vec4 o1 = p1+v2*t;
    vec4 v3 = o1-o0;
    return v3*t+o0;
}

float dot2(vec4 v) {return dot(v,v);}

float BezierLine(vec4 p, vec4 a, vec4 b, vec4 c,float minDist)
{
    for( float i = 0.0; i <= 1.0; i+=0.001)
    {
        minDist = min( dot2(p-BezierPoint(a,b,c,i)), minDist);
    }
    return pow(minDist,0.125);
}

void main( void )
{
    vec2 uv = (surfacePosition*vec2(2.0,2.0));
    vec4 p3 = vec2(1.,0.).xyxy;
//    vec4 p2 = vec4(0.0,sin(time)*uv.x,0.0,sin(time)*uv.x)*cos(time*2.0);//
    vec4 p2 = mouse.xyxy*8.0-4.0;
    vec4 p1 = -p3;
    
    gl_FragColor = vec4( vec3(
         BezierLine(vec4(uv,uv),p1,p2,p3,1.0)
    ),1.0);
}
</script>

    <script id="Majestic Wireframe Cube" type="x-shader/x-fragment">
 // Majestic Wireframe Cube
// By: Brandon Fogerty
// bfogerty at gmail dot com
// xdpixel.com

#ifdef GL_ES
precision mediump float;
#endif

#extension GL_OES_standard_derivatives : enable

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

float line( vec2 a, vec2 b, vec2 p )
{
    vec2 aTob = b - a;
    vec2 aTop = p - a;

    float t = dot( aTop, aTob ) / dot( aTob, aTob);

    t = clamp( t, 0.0, 1.0);

    float d = length( p - (a + aTob * t) );
    d = 0.05 / d;

    d = pow(d, 7.0);
    return clamp( d, 0.0, 1.0 );
}

mat4 perspectiveMatrix(float fovYInRad, float aspectRatio)
{    
    float yScale = 1.0/tan(fovYInRad / 2.0);
    float xScale = yScale / aspectRatio;  
    float zf = 100.0;
    float zn = 0.3;
    
    float z1 = zf/(zf-zn);
    float z2 = -zn*zf/(zf-zn);

    mat4 result = mat4(xScale, 0.0, 0.0, 0.0,
              0.0, yScale, 0.0, 0.0,
              0.0, 0.0, z1, z2,
              0.0, 0.0, -1.0, 0.0);
    
    return result;
}

mat4 translationMatrix(vec3 pos)
{
    mat4 result = 
    mat4(1.0, 0.0, 0.0, 0.0, 
         0.0, 1.0, 0.0, 0.0,
         0.0, 0.0, 1.0, 0.0,
         pos.x, pos.y, pos.z, 1.0 );
    
    return result;
}

mat4 rotXMatrix(float theta)
{
    float cs = cos(theta);
    float ss = sin(theta);

    mat4 result = 
    mat4(1.0, 0.0, 0.0, 0.0, 
         0.0, cs, -ss, 0.0,
         0.0, ss, cs, 0.0,
         0.0, 0.0, 0.0, 1.0 );

    return result;
}

mat4 rotYMatrix(float theta)
{
    float cs = cos(theta);
    float ss = sin(theta);

    mat4 result = 
    mat4(cs, 0.0, -ss, 0.0, 
         0.0, 1.0, 0.0, 0.0,
         ss, 0.0, cs, 0.0,
         0.0, 0.0, 0.0, 1.0 );

    return result;
}

float particle(vec2 uv, vec4 vert, mat4 mvp, vec2 sizeRange, float sizeOffset, vec2 moveSpeed)
{
    vec4 v = mvp * vert;
    vec2 vp = (v.xy / v.w);

    float size = mix(sizeRange.x, sizeRange.y, sin(time + sizeOffset) * 0.5 + 0.5);
    float t = 1.0 / abs(length(uv.xy - (vp.xy + vec2(cos(time * moveSpeed.x), sin(time * moveSpeed.y)))) * size);

    t = pow( t, 1.5);
    
    return t;
}

void main( void )
{
    vec2 uv = ( gl_FragCoord.xy / resolution.xy ) * 2.0 - 1.0;

    uv *= 10.0;

    const float fovYInRad = (45.0/180.0) * 3.14159;
    float aspectRatio = resolution.x / resolution.y;

    const float vs = 10.0;
    #define maxVerts 16
    vec4 verts [maxVerts];
    verts[0] = vec4( -vs, -vs, vs, 1.0 );
    verts[1] = vec4( -vs,  vs, vs, 1.0 );
    verts[2] = vec4(  vs,  vs, vs, 1.0 );
    verts[3] = vec4(  vs, -vs, vs, 1.0 );

    verts[4] = vec4( -vs, -vs, vs, 1.0 );
    verts[5] = vec4( -vs,  vs, vs, 1.0 );
    verts[6] = vec4( -vs,  vs, -vs, 1.0 );
    verts[7] = vec4( -vs, -vs, -vs, 1.0 );

    verts[8] = vec4( -vs, -vs, -vs, 1.0 );
    verts[9] = vec4( -vs,  vs, -vs, 1.0 );
    verts[10] = vec4( vs,  vs, -vs, 1.0 );
    verts[11] = vec4( vs, -vs, -vs, 1.0 );

    verts[12] = vec4( vs, -vs, vs, 1.0 );
    verts[13] = vec4( vs,  vs, vs, 1.0 );
    verts[14] = vec4( vs,  vs, -vs, 1.0 );
    verts[15] = vec4( vs, -vs, -vs, 1.0 );

    float moveX = mix(10.0, -10.0, sin(time * 0.4) * 0.5 + 0.5);
    float moveY = mix(10.0, -10.0, sin(time * 0.2) * 0.5 + 0.5);
    float moveZ = mix(40.0, 60.0, sin(time * 0.2) * 0.5 + 0.5);

    vec3 pos = vec3( moveX, moveY, moveZ);
    mat4 rotY = rotYMatrix(time) * rotXMatrix(time * 0.5);

    mat4 worldMat = translationMatrix(pos) * rotY;
    mat4 perspective = perspectiveMatrix(fovYInRad, aspectRatio);

    mat4 mvp = perspective * worldMat;

  
  
  
    float t = 0.0;
    for(int i = 0; i < maxVerts; ++i)
    {
        vec4 startWorldVert = mvp * verts[i];
        vec4 endWorldVert;
        if( i+1 < maxVerts)
        {
            endWorldVert = mvp * verts[i + 1];
        }
        else
        {
            endWorldVert = mvp * verts[i - 3];
        }

        if(i != 0 && mod(float(i+1), 4.0) == 0.0)
        {
            endWorldVert = mvp * verts[i - 3];
        }

        vec2 sp = startWorldVert.xy / startWorldVert.w;
        vec2 ep = endWorldVert.xy / endWorldVert.w;

        t += line( sp, ep, uv);
    }

    vec3 fc = vec3( 0.00 );
    fc += vec3(pow(abs(uv.y / 10.0), 2.5));

    fc += vec3( 2.0, 4.0, 8.0 ) * pow(t, 0.2);

  
    t = particle(uv, verts[0], mvp, vec2(20.0, 40.0), 1.0, vec2( 3.0, 1.0));
    fc += vec3(8.0, 4.0, 2.0) * t;

    t = particle(uv, verts[1], mvp, vec2(20.0, 40.0), 14.0, vec2( 1.0, 3.0));
    fc += vec3(4.0, 8.0, 2.0) * t;

    t = particle(uv, verts[10], mvp, vec2(10.0, 40.0), 25.0, vec2( 2.0, 1.0));
    fc += vec3(3.0, 2.0, 7.0) * t;

    t = particle(uv, verts[12], mvp, vec2(10.0, 40.0), 78.0, vec2( 5.0, 3.0));
    fc += vec3(4.0, 3.0, 8.0) * t;

    t = particle(uv, verts[6], mvp, vec2(10.0, 40.0), 100.0, vec2( 5.0, 3.0));
    fc += vec3(8.0, 1.0, 1.0) * t;

    gl_FragColor = vec4( fc, 1.0 );

}      






</script>

    <script id="shui long tou" type="x-shader/x-fragment">


#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

// Spout - @P_Malin

// Port of textured version from - www.shadertoy.com/view/lsXGzH

//#define LOW_QUALITY

#ifdef LOW_QUALITY
    #define kRaymarchMaxIter 16
#else
    #define kRaymarchMaxIter 32
    
    #define ENABLE_AMBIENT_OCCLUSION
    #define DOUBLE_SIDED_TRANSPARENCY
#endif

#define ENABLE_SPECULAR
#define ENABLE_REFLECTIONS
#define ENABLE_TRANSPARENCY
#define ENABLE_SHADOWS
#define ENABLE_FOG

#define ENABLE_DIRECTIONAL_LIGHT
#define ENABLE_DIRECTIONAL_LIGHT_FLARE

//#define ENABLE_POINT_LIGHT
//#define ENABLE_POINT_LIGHT_FLARE

const float kPipeRadius = 0.4;
const float kPipeThickness = 0.15;
const float kPipeHeight = 2.0;
//float kPipeHeight = 2.0 + sin(iGlobalTime);

const float kWaterNoiseScale = 0.025;

const float kWaterVelocity = 1.0;

const float kWaterAccel = -1.0;

const float kWaterAnimSpeed = 80.0;
const float kTrenchWaterAnimSpeed = 20.0;

const float watRef = 1.0 / 1.3330;

float kRipplePos = sqrt(abs(2.0 * kPipeHeight / kWaterAccel)) * kWaterVelocity;

const float kPI = 3.141592654;
const float kTwoPI = kPI * 2.0;

const float kNoTransparency = -1.0;
const float kTransparency = 1.0;
const float kInverseTransparency = 0.0;

struct C_Ray
{
    vec3 vOrigin;
    vec3 vDir;
    float fStartDistance;
    float fLength;
};

struct C_HitInfo
{
    vec3 vPos;
    float fDistance;
    vec3 vObjectId;
};
    
struct C_Surface
{
    vec3 vNormal;
    vec3 cReflection;
    vec3 cTransmission;    
};

struct C_Material
{
    vec3 cAlbedo;
    float fR0;
    float fSmoothness;
    vec2 vParam;

    float fTransparency;
    float fRefractiveIndex;
};

struct C_Shading
{
    vec3 cDiffuse;
    vec3 cSpecular;
};

struct C_PointLight
{
    vec3 vPos;
    vec3 cColour;
};

struct C_DirectionalLight
{
    vec3 vDir;
    vec3 cColour;
};

vec3 RotateX( const in vec3 vPos, const in float fAngle )
{
    float s = sin(fAngle);
    float c = cos(fAngle);
    
    vec3 vResult = vec3( vPos.x, c * vPos.y + s * vPos.z, -s * vPos.y + c * vPos.z);
    
    return vResult;
}

vec3 RotateY( const in vec3 vPos, const in float fAngle )
{
    float s = sin(fAngle);
    float c = cos(fAngle);
    
    vec3 vResult = vec3( c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);
    
    return vResult;
}

vec3 RotateZ( const in vec3 vPos, const in float fAngle )
{
    float s = sin(fAngle);
    float c = cos(fAngle);
    
    vec3 vResult = vec3( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y, vPos.z);
    
    return vResult;
}

/////////////////////////////////////
// Distance Field CSG
// These carry with them the material parameters in yzw

vec4 DistCombineUnion( const in vec4 v1, const in vec4 v2 )
{
    //if(v1.x < v2.x) return v1; else return v2;
    return mix(v1, v2, step(v2.x, v1.x));
}

vec4 DistCombineUnionConditional( const in vec4 v1, const in vec4 v2, const in float fCondition )
{    
  //if( fCondition < 0.0 )
  //            return v1;
                
    return mix(v1, v2, step(v2.x, v1.x) * step(0.0, fCondition));
}

vec4 DistCombineIntersect( const in vec4 v1, const in vec4 v2 )
{
    return mix(v2, v1, step(v2.x,v1.x));
}

vec4 DistCombineSubtract( const in vec4 v1, const in vec4 v2 )
{
    return DistCombineIntersect(v1, vec4(-v2.x, v2.yzw));
}

/////////////////////////////////////
// Scene Description 

const float kMaterialIdWall = 1.0;
const float kMaterialIdPipe = 2.0;
const float kMaterialIdWater = 3.0;

float Noise(vec2 p)
{
    vec2 s = sin(p * 0.6345) + sin(p * 1.62423);
    return dot(s, vec2(0.125)) + 0.5;
}

// result is x=scene distance y=material or object id; zw are material specific parameters (maybe uv co-ordinates)
vec4 GetDistanceScene( const in vec3 vPos, const in float fTransparentScale )
{          
    vec4 vResult = vec4(10000.0, -1.0, 0.0, 0.0);
            
  float fDistFloor = vPos.y;
  float fDistBrick = fDistFloor;
  
  float fDistTrench = length(vPos.yz + vec2(-0.4, 0.0)) - 1.0;
  fDistBrick = max(fDistBrick, -(fDistTrench));
  
  float fDistWall = vPos.x + 1.0;
  fDistBrick = min(fDistBrick, fDistWall);
  
    vec4 vDistFloor = vec4(fDistBrick, kMaterialIdWall, vPos.xz + vec2(vPos.y, 0.0));
    vResult = DistCombineUnion(vResult, vDistFloor);    

    vec3 vWaterDomain = vPos - vec3(0.0, kPipeHeight, 0.0);

    float t= max(vWaterDomain.x / kWaterVelocity, 0.0);
  
  // Equations of motion
  float s = 0.5 * kWaterAccel * t * t;
  float v = -kWaterAccel * t;
  
  vWaterDomain.y -= s;    
                
    float fDistWater = (length(vWaterDomain.yz) - kPipeRadius);
                
    float fDistPipe = max(fDistWater - kPipeThickness, vWaterDomain.x);
    fDistPipe = max(fDistPipe, -fDistWater); // subtract the water from the pipe to make the hole
    vec4 vDistPipe = vec4(fDistPipe, kMaterialIdPipe, vPos.xy);        
        
    vResult = DistCombineUnion(vResult, vDistPipe);    
  
  // compensate for domain distortion of water, otherwise ray sometimes misses
  fDistWater /= (1.0 + v * 0.5);
  
    vec2 vNoiseDomain = vPos.xz;
                
  // modify noise for water in trench
  float fInTrench = step(vPos.y, (-0.1 + 0.05));        
  vec2 vRippleCentre1 = vPos.xz - vec2(kRipplePos, 0.0);
  vNoiseDomain.x = mix(vNoiseDomain.x, length(vRippleCentre1), fInTrench);
  float fNoiseScale = mix(t * t, 1.0 / (1.0 + vNoiseDomain.x), fInTrench) * kWaterNoiseScale;
  float fWaterSpeed = mix(kWaterAnimSpeed * kWaterVelocity, kTrenchWaterAnimSpeed, fInTrench);
  
  vNoiseDomain *= 30.0; 
  vNoiseDomain.x += -time * fWaterSpeed;
  
  float fTrenchWaterDist = vPos.y + 0.1;
  fDistWater = min(fDistWater, fTrenchWaterDist);
  
  fDistWater += Noise(vNoiseDomain) * fNoiseScale;
  
  // Negate the distance to the water if transparent scale is 0.0     
  // This allows us to ratrace "out" of water
  fDistWater *= (fTransparentScale * 2.0) - 1.0;
  
  vec4 vDistWater = vec4(fDistWater, kMaterialIdWater, vPos.xy);        
  // The condition allows us to ignore water for secondary rays
  vResult = DistCombineUnionConditional(vResult, vDistWater, fTransparentScale);
              
    return vResult;
}

float GetRayFirstStep( const in C_Ray ray )
{
    return ray.fStartDistance;  
}

C_Material GetObjectMaterial( const in C_HitInfo hitInfo )
{
    C_Material mat;
              
    if(hitInfo.vObjectId.x == kMaterialIdWall)
    {
        // floor
        mat.fR0 = 0.02;
  vec2 vTile = step(vec2(0.15), fract(hitInfo.vObjectId.yz));
  float fTile = vTile.x * vTile.y;
        mat.cAlbedo = vec3(1.0) * (fTile * 0.8 + 0.2);
        mat.fSmoothness = 1.0;
        
        mat.fSmoothness = mat.cAlbedo.r;
        mat.fTransparency = 0.0;
    }
    else
    if(hitInfo.vObjectId.x == kMaterialIdPipe)
    {
        // pipe
        mat.fR0 = 0.8;
        mat.fSmoothness = 1.0;
        mat.cAlbedo = vec3(0.5);
        mat.fTransparency = 0.0;
    }
    else
    {
  // water
        mat.fR0 = 0.01;
        mat.fSmoothness = 1.0;
        mat.fTransparency = 1.0;
        mat.fRefractiveIndex = watRef; //1.0 / 1.3330;
        const float fExtinctionScale = 2.0;
    const vec3 vExtinction = vec3(0.3, 0.7, 0.9);
        mat.cAlbedo = (vec3(1.0) - vExtinction) * fExtinctionScale; // becomes extinction for transparency
    }
    
    return mat;
}

vec3 GetSkyGradient( const in vec3 vDir )
{
    const vec3 cColourTop = vec3(0.7, 0.8, 1.0);
    const vec3 cColourHorizon = cColourTop * 0.5;

    float fBlend = clamp(vDir.y, 0.0, 1.0);
    return mix(cColourHorizon, cColourTop, fBlend);
}

C_PointLight GetPointLight()
{
    C_PointLight result;

    result.vPos = vec3(0.5, 1.0, -2.0);
    result.cColour = vec3(32.0, 6.0, 1.0) * 10.0;

    return result;
}

C_DirectionalLight GetDirectionalLight()
{
    C_DirectionalLight result;

    result.vDir = normalize(vec3(-0.2, -0.3, 0.5));
    result.cColour = vec3(8.0, 7.5, 7.0);

    return result;
}

vec3 GetAmbientLight(const in vec3 vNormal)
{
    return GetSkyGradient(vNormal);
}

/////////////////////////////////////
// Raymarching 

vec3 GetSceneNormal( const in vec3 vPos, const in float fTransparentScale )
{
    // tetrahedron normal
    const float fDelta = 0.025;

    vec3 vOffset1 = vec3( fDelta, -fDelta, -fDelta);
    vec3 vOffset2 = vec3(-fDelta, -fDelta,  fDelta);
    vec3 vOffset3 = vec3(-fDelta,  fDelta, -fDelta);
    vec3 vOffset4 = vec3( fDelta,  fDelta,  fDelta);

    float f1 = GetDistanceScene( vPos + vOffset1, fTransparentScale ).x;
    float f2 = GetDistanceScene( vPos + vOffset2, fTransparentScale ).x;
    float f3 = GetDistanceScene( vPos + vOffset3, fTransparentScale ).x;
    float f4 = GetDistanceScene( vPos + vOffset4, fTransparentScale ).x;

    vec3 vNormal = vOffset1 * f1 + vOffset2 * f2 + vOffset3 * f3 + vOffset4 * f4;

    return normalize( vNormal );
}

#define kRaymarchEpsilon 0.01
// This is an excellent resource on ray marching -> http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm
void Raymarch( const in C_Ray ray, out C_HitInfo result, const int maxIter, const float fTransparentScale )
{        
    result.fDistance = GetRayFirstStep( ray );
    result.vObjectId.x = 0.0;
        
    for(int i=0;i<=kRaymarchMaxIter;i++)              
    {
        result.vPos = ray.vOrigin + ray.vDir * result.fDistance;
        vec4 vSceneDist = GetDistanceScene( result.vPos, fTransparentScale );
        result.vObjectId = vSceneDist.yzw;
        
        // abs allows backward stepping - should only be necessary for non uniform distance functions
        if((abs(vSceneDist.x) <= kRaymarchEpsilon) || (result.fDistance >= ray.fLength) || (i > maxIter))
        {
            break;
        }                        

        result.fDistance = result.fDistance + vSceneDist.x; 
    }


    if(result.fDistance >= ray.fLength)
    {
        result.fDistance = 1000.0;
        result.vPos = ray.vOrigin + ray.vDir * result.fDistance;
        result.vObjectId.x = 0.0;
    }
}

float GetShadow( const in vec3 vPos, const in vec3 vNormal, const in vec3 vLightDir, const in float fLightDistance )
{
    #ifdef ENABLE_SHADOWS
    C_Ray shadowRay;
    shadowRay.vDir = vLightDir;
    shadowRay.vOrigin = vPos;
    const float fShadowBias = 0.05;
    shadowRay.fStartDistance = fShadowBias / abs(dot(vLightDir, vNormal));
    shadowRay.fLength = fLightDistance - shadowRay.fStartDistance;
  
    C_HitInfo shadowIntersect;
    Raymarch(shadowRay, shadowIntersect, 32, kNoTransparency);
    
    float fShadow = step(0.0, shadowIntersect.fDistance) * step(fLightDistance, shadowIntersect.fDistance );
    
    return fShadow;          
    #else
      return 1.0;
    #endif
}

// use distance field to evaluate ambient occlusion
float GetAmbientOcclusion(const in C_HitInfo intersection, const in C_Surface surface)
{
    #ifdef ENABLE_AMBIENT_OCCLUSION    
    vec3 vPos = intersection.vPos;
    vec3 vNormal = surface.vNormal;
  
    float fAmbientOcclusion = 1.0;
  
    float fDist = 0.0;
    for(int i=0; i<=5; i++)
    {
      fDist += 0.1;
  
      vec4 vSceneDist = GetDistanceScene(vPos + vNormal * fDist, kNoTransparency);
  
      fAmbientOcclusion *= 1.0 - max(0.0, (fDist - vSceneDist.x) * 0.2 / fDist );                                 
    }
  
    return fAmbientOcclusion;
    #else
      return 1.0;
    #endif    
}

/////////////////////////////////////
// Lighting and Shading

#define kFogDensity 0.05

void ApplyAtmosphere(inout vec3 col, const in C_Ray ray, const in C_HitInfo hitInfo)
{
    #ifdef ENABLE_FOG
    // fog
    float fFogAmount = exp(hitInfo.fDistance * -kFogDensity);
    vec3 cFog = GetSkyGradient(ray.vDir);

    #ifdef ENABLE_DIRECTIONAL_LIGHT_FLARE
    C_DirectionalLight directionalLight = GetDirectionalLight();
    float fDirDot = clamp(dot(-directionalLight.vDir, ray.vDir), 0.0, 1.0);
    cFog += directionalLight.cColour * pow(fDirDot, 10.0);
    #endif 

    col = mix(cFog, col, fFogAmount);
    #endif

    // glare from light (a bit hacky - use length of closest approach from ray to light)
    #ifdef ENABLE_POINT_LIGHT_FLARE
    C_PointLight pointLight = GetPointLight();

    vec3 vToLight = pointLight.vPos - ray.vOrigin;
    float fPointDot = dot(vToLight, ray.vDir);
    fPointDot = clamp(fPointDot, 0.0, hitInfo.fDistance);

    vec3 vClosestPoint = ray.vOrigin + ray.vDir * fPointDot;
    float fDist = length(vClosestPoint - pointLight.vPos);
    col += pointLight.cColour * 0.01/ (fDist * fDist);
    #endif    
}

// http://en.wikipedia.org/wiki/Schlick's_approximation
float Schlick( const in vec3 vNormal, const in vec3 vView, const in float fR0, const in float fSmoothFactor)
{
    float fDot = dot(vNormal, -vView);
    fDot = clamp((1.0 - fDot), 0.0, 1.0);
    float fDotPow = pow(fDot, 5.0);
    return fR0 + (1.0 - fR0) * fDotPow * fSmoothFactor;
}

vec3 ApplyFresnel(const in vec3 vDiffuse, const in vec3 vSpecular, const in vec3 vNormal, const in vec3 vView, const in C_Material material)
{
    float fFresnel = Schlick(vNormal, vView, material.fR0, material.fSmoothness * 0.9 + 0.1);
    return mix(vDiffuse, vSpecular, fFresnel);    
}

float GetBlinnPhongIntensity(const in vec3 vIncidentDir, const in vec3 vLightDir, const in vec3 vNormal, const in float fSmoothness)
{          
    vec3 vHalf = normalize(vLightDir - vIncidentDir);
    float fNdotH = max(0.0, dot(vHalf, vNormal));

    float fSpecPower = exp2(4.0 + 6.0 * fSmoothness);
    float fSpecIntensity = (fSpecPower + 2.0) * 0.125;

    return pow(fNdotH, fSpecPower) * fSpecIntensity;
}

C_Shading ApplyPointLight( const in C_PointLight light, const in vec3 vSurfacePos, const in vec3 vIncidentDir, const in vec3 vNormal, const in C_Material material )
{
    C_Shading shading;
    
    vec3 vToLight = light.vPos - vSurfacePos;
    vec3 vLightDir = normalize(vToLight);
    float fLightDistance = length(vToLight);
    
    float fAttenuation = 1.0 / (fLightDistance * fLightDistance);
    
    float fShadowFactor = GetShadow( vSurfacePos, vNormal, vLightDir, fLightDistance );
    vec3 vIncidentLight = light.cColour * fShadowFactor * fAttenuation * max(0.0, dot(vLightDir, vNormal));
    
    shading.cDiffuse = vIncidentLight;                                  
    shading.cSpecular = GetBlinnPhongIntensity( vIncidentDir, vLightDir, vNormal, material.fSmoothness ) * vIncidentLight;
    
    return shading;
}  

C_Shading ApplyDirectionalLight( const in C_DirectionalLight light, const in vec3 vSurfacePos, const in vec3 vIncidentDir, const in vec3 vNormal, const in C_Material material )
{
    C_Shading shading;

    const float kShadowRayLength = 10.0;      
    vec3 vLightDir = -light.vDir;
    float fShadowFactor = GetShadow( vSurfacePos, vNormal, vLightDir, kShadowRayLength );
    vec3 vIncidentLight = light.cColour * fShadowFactor * max(0.0, dot(vLightDir, vNormal));
    
    shading.cDiffuse = vIncidentLight;                                  
    shading.cSpecular = GetBlinnPhongIntensity( vIncidentDir, vLightDir, vNormal, material.fSmoothness ) * vIncidentLight;
    
    return shading;
}  


vec3 ShadeSurface(const in C_Ray ray, const in C_HitInfo hitInfo, const in C_Surface surface, const in C_Material material)
{
    vec3 cScene;
    
    C_Shading shading;

    shading.cDiffuse = vec3(0.0);
    shading.cSpecular = vec3(0.0);
    
    float fAmbientOcclusion = GetAmbientOcclusion(hitInfo, surface);
    vec3 vAmbientLight = GetAmbientLight(surface.vNormal) * fAmbientOcclusion;
    
    shading.cDiffuse += vAmbientLight;
    shading.cSpecular += surface.cReflection;
              
    #ifdef ENABLE_POINT_LIGHT
    C_PointLight pointLight = GetPointLight();
    C_Shading pointLighting = ApplyPointLight(pointLight, hitInfo.vPos,ray.vDir, surface.vNormal, material);
    shading.cDiffuse += pointLighting.cDiffuse;
    shading.cSpecular += pointLighting.cSpecular;
    #endif

    #ifdef ENABLE_DIRECTIONAL_LIGHT
  C_DirectionalLight directionalLight = GetDirectionalLight();
    C_Shading directionLighting = ApplyDirectionalLight(directionalLight, hitInfo.vPos, ray.vDir, surface.vNormal, material);
    shading.cDiffuse += directionLighting.cDiffuse;
    shading.cSpecular += directionLighting.cSpecular;
    #endif

    vec3 vDiffuseReflection = shading.cDiffuse * material.cAlbedo;          

    // swap diffuse for transmission
    vDiffuseReflection = mix(vDiffuseReflection, surface.cTransmission, material.fTransparency);    

    #ifdef ENABLE_SPECULAR
    cScene = ApplyFresnel(vDiffuseReflection , shading.cSpecular, surface.vNormal, ray.vDir, material);
    #else
    cScene = vDiffuseReflection;
    #endif
    
    return cScene;
}

vec3 GetSceneColourSecondary( const in C_Ray ray );

vec3 GetReflection( const in C_Ray ray, const in C_HitInfo hitInfo, const in C_Surface surface )
{
    #ifdef ENABLE_REFLECTIONS    
    {
        // get colour from reflected ray
        const float fSeparation    = 0.1;

        C_Ray reflectRay;
        reflectRay.vDir = reflect(ray.vDir, surface.vNormal);
        reflectRay.vOrigin = hitInfo.vPos;
        reflectRay.fLength = 16.0;
        reflectRay.fStartDistance = fSeparation / abs(dot(reflectRay.vDir, surface.vNormal));
        
        return GetSceneColourSecondary(reflectRay);      
    }
    #else
        return GetSkyGradient(reflect(ray.vDir, surface.vNormal));                              
    #endif
}

vec3 GetTransmission( const in C_Ray ray, const in C_HitInfo hitInfo, const in C_Surface surface, const in C_Material material )
{
    #ifdef ENABLE_TRANSPARENCY  
    {
        const float fSeparation = 0.05;

        // Trace until outside transparent object
        C_Ray refractRay;
        // we dont handle total internal reflection (in that case refract returns a zero length vector)
        refractRay.vDir = refract(ray.vDir, surface.vNormal, material.fRefractiveIndex);
        refractRay.vOrigin = hitInfo.vPos;
        refractRay.fLength = 16.0;
        refractRay.fStartDistance = fSeparation / abs(dot(refractRay.vDir, surface.vNormal));

    #ifdef DOUBLE_SIDED_TRANSPARENCY
    
      C_HitInfo hitInfo2;
      Raymarch(refractRay, hitInfo2, 32, kInverseTransparency);
      vec3 vNormal = GetSceneNormal(hitInfo2.vPos, kInverseTransparency);
      
      // get colour from rest of scene
      C_Ray refractRay2;
      refractRay2.vDir = refract(refractRay.vDir, vNormal, 1.0 / material.fRefractiveIndex);
      refractRay2.vOrigin = hitInfo2.vPos;
      refractRay2.fLength = 16.0;
      refractRay2.fStartDistance = 0.0;//fSeparation / abs(dot(refractRay2.vDir, vNormal));
      
      float fExtinctionDist = hitInfo2.fDistance;
      vec3 vSceneColour = GetSceneColourSecondary(refractRay2);
    
    #else
    
      vec3 vSceneColour = GetSceneColourSecondary(refractRay);                                                                        
      float fExtinctionDist = 0.5;
    
    #endif
                                
        vec3 cMaterialExtinction = material.cAlbedo;
        // extinction should really be exp(-) but this is a nice hack to get RGB
        vec3 cExtinction = (1.0 / (1.0 + (cMaterialExtinction * fExtinctionDist)));
                                
                                return vSceneColour * cExtinction;
    }
    #else
        return GetSkyGradient(reflect(ray.vDir, surface.vNormal));                              
    #endif
}

// no reflections, no transparency, used for secondary rays
vec3 GetSceneColourSecondary( const in C_Ray ray )
{
    C_HitInfo hitInfo;
    Raymarch(ray, hitInfo, 32, kNoTransparency);
                        
    vec3 cScene;

    if(hitInfo.vObjectId.x < 0.5)
    {
        cScene = GetSkyGradient(ray.vDir);
    }
    else
    {
        C_Surface surface;        
        surface.vNormal = GetSceneNormal(hitInfo.vPos, kNoTransparency);

        C_Material material = GetObjectMaterial(hitInfo);

        // use sky gradient instead of reflection
        surface.cReflection = GetSkyGradient(reflect(ray.vDir, surface.vNormal));
        
        material.fTransparency = 0.0;

        // apply lighting
        cScene = ShadeSurface(ray, hitInfo, surface, material);
    }

    ApplyAtmosphere(cScene, ray, hitInfo);

    return cScene;
}

vec3 GetSceneColourPrimary( const in C_Ray ray )
{                                                          
    C_HitInfo intersection;
    Raymarch(ray, intersection, 256, kTransparency);
                
    vec3 cScene;

    if(intersection.vObjectId.x < 0.5)
    {
        cScene = GetSkyGradient(ray.vDir);
    }
    else
    {
        C_Surface surface;
        
        surface.vNormal = GetSceneNormal(intersection.vPos, kTransparency);

        C_Material material = GetObjectMaterial(intersection);

        surface.cReflection = GetReflection(ray, intersection, surface);

        if(material.fTransparency > 0.0)
        {    
            surface.cTransmission = GetTransmission(ray, intersection, surface, material);
        }

        // apply lighting
        cScene = ShadeSurface(ray, intersection, surface, material);
    }

    ApplyAtmosphere(cScene, ray, intersection);

    return cScene;
}

float kFarClip = 30.0;

void GetCameraRay( const in vec3 vPos, const in vec3 vForwards, const in vec3 vWorldUp, out C_Ray ray)
{
    vec2 vUV = ( gl_FragCoord.xy / resolution.xy );
    vec2 vViewCoord = vUV * 2.0 - 1.0;

    float fRatio = resolution.x / resolution.y;
    vViewCoord.y /= fRatio;                          

    ray.vOrigin = vPos;

    vec3 vRight = normalize(cross(vForwards, vWorldUp));
    vec3 vUp = cross(vRight, vForwards);
        
    ray.vDir = normalize( vRight * vViewCoord.x + vUp * vViewCoord.y + vForwards); 
    ray.fStartDistance = 0.0;
    ray.fLength = kFarClip;      
}

void GetCameraRayLookat( const in vec3 vPos, const in vec3 vInterest, out C_Ray ray)
{
    vec3 vForwards = normalize(vInterest - vPos);
    vec3 vUp = vec3(0.0, 0.1, 0.0);

    GetCameraRay(vPos, vForwards, vUp, ray);
}

vec3 OrbitPoint( const in float fHeading, const in float fElevation )
{
    return vec3(sin(fHeading) * cos(fElevation), sin(fElevation), cos(fHeading) * cos(fElevation));
}

vec3 Gamma( const in vec3 cCol )
{
    return cCol * cCol;
}

vec3 Tonemap( const in vec3 cCol )
{
    // simple Reinhard tonemapping operator    
    vec3 vResult = cCol / (0.2 + cCol);

    return Gamma(vResult);
}

void main( void )
{
    C_Ray ray;
    
    float fHeading = mix(-0.7, kPI + 0.5, mouse.x);
    float fElevation = mix(1.5, -0.25, mouse.y);
    float fCameraDist = mix(4.0, 2.5, mouse.y);
    
    vec3 vCameraPos = OrbitPoint(fHeading, fElevation) * fCameraDist;
    vec3 vCameraIntrest = vec3(1.0, 0.9, 0.0);

    GetCameraRayLookat( vCameraIntrest + vCameraPos, vCameraIntrest, ray);

    vec3 cScene = GetSceneColourPrimary( ray );  

    const float fExposure = 3.0;    
    gl_FragColor = vec4( Tonemap(cScene), 1.0 );
}
</script>

    <script id="rubiks cube" type="x-shader/x-fragment">
// GLSL rubik's cube by Kabuto

#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

// Traces a single big cube (= here: layer of 3x3 small cubes)
void cubetrace(vec3 pos, vec3 dir, vec3 scale, vec3 ofs, inout vec4 hit) {
  pos *= scale;
  pos += ofs;
  dir *= scale;
  vec3 h1 = (-pos-sign(dir))/dir;
  vec3 h2 = (-pos+sign(dir))/dir;
  float h1f = max(max(h1.x,h1.y),h1.z);
  float h2f = min(min(h2.x,h2.y),h2.z);
  if (h1f < h2f && h1f < hit.w) {
    hit = vec4((pos+dir*h1f-ofs)/scale,h1f);
  }
}

// What layer to rotate in what frame
// x: rotation axis (0 to 2), y: rotation layer (0 to 2), z: rotation direction (-1 or 1)
// Math has to be that way (rounding redundantly) due to numerical precision issues
vec3 rotframe(float time) {
  time = floor(time)+.5;
  return floor(vec3(mod(time,3.),mod(floor(time/3.+.1)+.5,3.),floor(mod(time,2.))*2.-1.));
}


const int FRAMES = 32;

void main( void ) {
  vec3 pos = vec3(0.,-.21,-7.);
  vec2 uv = (gl_FragCoord.xy - resolution*.5)/resolution.y*.5;
  vec3 dir = normalize(vec3(uv,1.));

  float tf = mod(time,float(FRAMES))+1e-5;
  vec3 r = rotframe(tf);
  
  float t2 = time*.3;
  mat3 globalrot = mat3(cos(t2),0,-sin(t2),0,1,0,sin(t2),0,cos(t2));
  
  float t = -fract(tf)*3.141592653589*.5*r.z;
  mat3 rot = r.x < .5 ?
    mat3(1,0,0,0,cos(t),sin(t),0,-sin(t),cos(t))
  : r.x < 1.5 ?
    mat3(cos(t),0,-sin(t),0,1,0,sin(t),0,cos(t)) :
    mat3(cos(t),sin(t),0,-sin(t),cos(t),0,0,0,1);

  mat3 rot2 = mat3(1,0,0,0,1,0,0,0,1);

  float a = -.4;
  mat3 prot = mat3(1,0,0,0,cos(a),sin(a),0,-sin(a),cos(a))*globalrot;
  pos *= prot;
  dir *= prot;

  vec4 vhit = vec4(0,0,0,1e9);
  vec3 s = r.x < .5 ? vec3(1,0,0) : r.x < 1.5 ? vec3(0,1,0) : vec3(0,0,1);
  cubetrace(pos*(r.y==0.?rot:rot2),dir*(r.y==0.?rot:rot2),vec3(1,1,1)+s*2.,s*2.,vhit);
  cubetrace(pos*(r.y==1.?rot:rot2),dir*(r.y==1.?rot:rot2),vec3(1,1,1)+s*2.,vec3(0, 0,0),vhit);
  cubetrace(pos*(r.y==2.?rot:rot2),dir*(r.y==2.?rot:rot2),vec3(1,1,1)+s*2.,-s*2.,vhit);
  
    
    
  vec3 hit = vhit.xyz;
  
  for (int i = FRAMES-1; i >= 0; i--) {
    if (float(i)+1. < tf) {
      vec3 r = rotframe(float(i));
      hit = r.x < .5 ? hit : r.x < 1.5 ? hit.yzx : hit.zxy;
      if (abs(floor(hit.x*1.49+1.5)- r.y) < .5) hit.yz *= mat2(0,-r.z,r.z,0);
      hit = r.x < .5 ? hit : r.x < 1.5 ? hit.zxy : hit.yzx;
    }
  }
  
  
  vec3 ahit = abs(hit.xyz);
  vec3 side = sign(hit.xyz)*step(vec3(.99),ahit);
  float m = max(max(ahit.x,ahit.y),ahit.z);
  
  hit.xyz *= 3.;
  hit.xyz = abs(fract(hit.xyz*.5+.5)-.5)*2.;
  float b = max(max(hit.x,hit.y),hit.z);
  float d = min(min(hit.x,hit.y),hit.z);
  float c = hit.x+hit.y+hit.z-b-d;
  c = max(c-.7,0.);
  d = max(d-.7,0.);
  
  
  
  vec3 facecolour = max(side,vec3(0)) + (1.+min(side,vec3(0)))*dot(-min(side,vec3(0)),vec3(1));
  vec3 colour = vec3(step(sqrt(c*c+d*d),.17)*step(.99,m))*facecolour+step(m,.1);
  colour += 1.-min(1.,float(FRAMES)-tf);
  
  gl_FragColor = vec4( colour, 1.0 );

}
</script>

    <script id="cloud" type="x-shader/x-fragment">
#ifdef GL_ES
precision mediump float;
#endif

#extension GL_OES_standard_derivatives : enable

uniform float time;
//uniform vec2 mouse;
uniform vec2 resolution;

const float cloudscale = 1.1;
const float speed = 0.01;
const float clouddark = 0.5;
const float cloudlight = 0.3;
const float cloudcover = 0.2;
const float cloudalpha = 8.0;
const float skytint = 0.5;
const vec3 skycolour1 = vec3(0.2, 0.4, 0.6);
const vec3 skycolour2 = vec3(0.4, 0.7, 1.0);

const mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );


vec2 hash( vec2 p ) {
  p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));
  return -1.0 + 2.0*fract(sin(p)*43758.5453123);
}

float noise( in vec2 p ) {
    const float K1 = 0.366025404; // (sqrt(3)-1)/2;
    const float K2 = 0.211324865; // (3-sqrt(3))/6;
    
    vec2 i = floor(p + (p.x+p.y)*K1);
    vec2 a = p - i + (i.x+i.y)*K2;
    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));
    vec2 b = a - o + K2;
    vec2 c = a - 1.0 + 2.0*K2;
    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );
    vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));
    
    return dot(n, vec3(70.0));
}

float fbm(vec2 n) {
  float total = 0.0, amplitude = 0.1;
  for (int i = 0; i < 7; i++) {
    total += noise(n) * amplitude;
    n = m * n;
    amplitude *= 0.4;
  }
  return total;
}

// -----------------------------------------------

void main() {

    vec2 p = gl_FragCoord.xy / (resolution.xy);
    vec2 uv = p*vec2(resolution.x / resolution.y, 0.9);
    float localTime = time * speed;
    float q = fbm(uv * cloudscale * 0.1);

    //ridged noise shape
  float r = 0.0;
  uv *= cloudscale;
    uv -= q - localTime;
    float weight = 0.8;
    for (int i=0; i<8; i++){
    r += abs(weight*noise( uv ));
        uv = m*uv + localTime;
    weight *= 0.7;
    }

    //noise shape
  float f = 0.0;
    uv = p*vec2(resolution.x/resolution.y,1.0);
  uv *= cloudscale;
    uv -= q - localTime;
    weight = 0.7;
    for (int i=0; i<8; i++){
    f += weight*noise( uv );
        uv = m*uv + localTime;
    weight *= 0.6;
    }

    f *= r + f;

    //noise colour
    float c = 0.0;
   localTime = time * speed * 2.0;
    uv = p*vec2(resolution.x/resolution.y,1.0);
  uv *= cloudscale*2.0;
    uv -= q - localTime;
    weight = 0.4;
    for (int i=0; i<7; i++){
    c += weight*noise( uv );
        uv = m*uv + localTime;
    weight *= 0.6;
    }

    //noise ridge colour
    float c1 = 0.0;
   localTime = time * speed * 3.0;
    uv = p*vec2(resolution.x/resolution.y,1.0);
  uv *= cloudscale*3.0;
    uv -= q - localTime;
    weight = 0.4;
    for (int i=0; i<7; i++){
    c1 += abs(weight*noise( uv ));
        uv = m*uv + localTime;
    weight *= 0.6;
    }

    c += c1;

    vec3 skycolour = mix(skycolour2, skycolour1, p.y);
    vec3 cloudcolour = vec3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight*c), 0.0, 1.0);

    f = cloudcover + cloudalpha*f*r;

    vec3 result = mix(skycolour, clamp(skytint * skycolour + cloudcolour, 0.0, 1.0), clamp(f + c, 0.0, 1.0));

  gl_FragColor = vec4( result, 1.0 );
}
</script>

    <script id="big tree" type="x-shader/x-fragment">

#ifdef GL_ES
precision mediump float;
#endif

#extension GL_OES_standard_derivatives : enable

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;
varying vec2 surfacePosition;

const float tri_a = tan(3.14/3.);
bool tri(vec2 p, float k){
  return p.y < p.x * tri_a + k && p.y < p.x * -tri_a + k && p.y > -k;
}

void main( void ) {
  vec2 p = surfacePosition;
  float z = 1.0;
  vec3 color = vec3(.4+.2*float(mod(floor(p.x*32.), 2.)==mod(floor(p.y*32.), 2.)));
  
  #define R2(T) mat2(cos(T), -sin(T), sin(T), cos(T))
  
  p = surfacePosition+vec2(0,.5);
  for(int i = 0; i <= 15; i += 1){
    if(tri(p, 0.04)){
      color = vec3(0.4,0.3,0.0);
      z += 0.125;
    }
    p.y -= 0.03;
    p *= R2((mouse.x-.5)*0.1*cos(time+float(i))*cos(time+float(i)));
  }
  p.y += 0.1;
  for(int i = 0; i <= 4; i += 1){
    p *= R2(-.93*2.*3.14159*sign(p.x));
    p.y += -0.09;
    if(tri(p*vec2(1.5,1), 0.06)){
      color = vec3(0.4,0.3,0.0);
      z += 0.25;
    }
    p *= 1.1*R2((mouse.x-.5)*0.4*cos(time+float(i))*cos(time+float(i)));
  }
  //p *= R2(atan(p.x, p.y)*12.);
  for(int i = 0; i <= 7; i += 1){
    if(tri(p, 0.125*abs(length(p*5.)-.5))){
      color = vec3(0.1+z*0.1,0.3,0.1);
      z += 0.1;
      z *= 1.2;
    }
    p.y -= 0.033;
    p *= 0.9*R2(-.95*2.*3.14159*sign(p.x));
    p *= R2((mouse.x-.5)*0.3*cos(time+float(i))*cos(time+float(i)));
  }
  
  gl_FragColor = vec4( color*z, 1.0 );
}           
</script>

    <script id="colorful voronoi" type="x-shader/x-fragment">


                    // Colorful Voronoi
                    // By: Brandon Fogerty
                    // bfogerty at gmail dot com
                    // xdpixel.com

                    #ifdef GL_ES
                    precision mediump float;
                    #endif

                    uniform float time;
                    uniform vec2 mouse;
                    uniform vec2 resolution;

                    vec2 hash(vec2 p)
                    {
                        mat2 m = mat2(  13.85, 47.77,
                                        99.41, 88.48
                                    );

                        return fract(sin(m*p) * 46738.29);
                    }

                    float voronoi(vec2 p)
                    {
                        vec2 g = floor(p);
                        vec2 f = fract(p);

                        float distanceToClosestFeaturePoint = 1.0;
                        for(int y = -1; y <= 1; y++)
                        {
                            for(int x = -1; x <= 1; x++)
                            {
                                vec2 latticePoint = vec2(x, y);
                                float currentDistance = distance(latticePoint + hash(g+latticePoint), f);
                                distanceToClosestFeaturePoint = min(distanceToClosestFeaturePoint, currentDistance);
                            }
                        }

                        return distanceToClosestFeaturePoint;
                    }

                    void main( void )
                    {
                        vec2 uv = ( gl_FragCoord.xy / resolution.xy ) * 2.0 - 1.0;
                        uv.x *= resolution.x / resolution.y;

                        float offset = voronoi(uv*10.0 + vec2(time));
                        float t = 1.0/abs(((uv.x + sin(uv.y + time)) + offset) * 30.0);

                        float r = voronoi( uv * 1.0 ) * 10.0;
                        vec3 finalColor = vec3(10.0 * uv.y, 2.0, 1.0 * r) * t;
                        
                        gl_FragColor = vec4(finalColor, 1.0 );
                    }

</script>

    <script id="small flower" type="x-shader/x-fragment">
                    #ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

#define pi 3.1415926535897932384626433832795
#define flyCount 30.


float testFuncFloor(float v){

    const float amplitude=1.;
    const float t=pi*2.;
    float k=4.*amplitude/t;
    float r=mod( v  ,t);
    float d=floor(v /(.5* t) );
    
  return mix(k* r-amplitude ,  amplitude*3.-k* r ,mod(d,2.)  );
}

float getRad(vec2 q){
   return atan(q.y,q.x); 
}

vec2 noise(vec2 tc){
    //return (2.*texture2D(iChannel0, tc).xy-1.).xy;
    return vec2(fract(sin(tc.x) ),fract(sin(tc.y) ) );
}

float firefly(vec2 p,float size){
    
  //return smoothstep(0.,size,dot(p,p)*200. );
  return smoothstep(0.,size,length(p) );

}

const float pow=1.;
const float flySpeed=0.1;


vec3 RetroCrtEffect(vec3 rgb, vec2 texCoord, vec2 resolution)
{
    const float blendFactor = 0.1; // range (0.0, 1.0]
    float artifact = cos(texCoord.y * resolution.y * 2.0) * 0.5 + 0.5;
    return max(rgb - vec3(artifact * blendFactor), vec3(0.0));
}

void main( void ) {

    float pow=1.;
    const float duration=1.;
    float t=duration*(1.+sin(3.* time ) );
  vec2 p= gl_FragCoord.xy / resolution.xy;
   
  float ratio= resolution.y/resolution.x;
    
     vec2 uv=p;
    uv.y*=ratio;
    
    
    vec2 flowerP=vec2(.618,0.518);
    vec2 q=p-flowerP-vec2( pow*.008*cos(3.*time) ,pow*.008*sin(3.*time) ) ;
    vec2 rootP=p-+flowerP-vec2( pow*.02*cos(3.*time)*p.y ,-0.48+pow*.008*sin(3.*time) );
   
  q.y*=ratio;
  
    //sky
    vec3 col=mix( vec3(0.1,0.6,0.5), vec3(0.2,0.1,0.2), sqrt(p.y)*.6 );
    

    //draw stem 
    float width=0.01;
    float h=.5;
    float w=.0005;
    col=mix(vec3(.5,.7,.4),col, 1.- (1.- smoothstep(h,h+width, abs(rootP.y ) )  ) * (1.- smoothstep(w,w+width, abs(rootP.x-0.1*sin(4.*rootP.y+pi*.35) ) )  ) );
    
    //draw flower 
    vec3 flowerCol=mix(vec3(.7,.7,.2),vec3(.7,.9,.7), smoothstep( .0,1.,length(q)*10. ) ) ;

    const float edge=.02;
    float r= .1+0.05*( testFuncFloor( getRad( q ) *7.  + 2.*q.x*(t-duration)  )  );

  col=mix(flowerCol,col, smoothstep(r,r+edge,  length( q )  ) );
    
  //draw buds
    float r1=0.;
    r1=.04;
    vec3 budCol=mix (vec3(.3,.4,0.),vec3(.9,.8,0.), length(q)*10. );
  col=mix(budCol,col, smoothstep(r1,r1+0.01,  length( q )  ) );
    
    //draw firefly
  //vec3 flyCol=mix (vec3(.1,.4,0.1),vec3(.1,1.,1.), length(q)*10. );
  
    for (float i=0.;i<flyCount;i++){
    
        float seed=i/flyCount;
  float seed2=fract(i/flyCount*5.);
        float t1=1.*(1.+sin(noise(vec2(seed) ).x* time ) );
      vec2 fireflyP=uv- 
        vec2(noise(vec2(seed2) ).x+noise(vec2(seed2) ).x*t1*flySpeed,
       noise(vec2(seed) ).y+noise(vec2(seed) ).y*t1*flySpeed);
      
    float fly= firefly( fireflyP,.002+.008*seed );
      vec3 flyCol=mix(vec3(0.1,0.9,0.1)*t1,vec3(0.), fly );
      col+=flyCol;
    }

    //vec3 color = RetroCrtEffect(col, uv, resolution.xy);
    vec3 color = col;

  
    gl_FragColor= vec4(color, 1.0);
  /*
  vec2 position = ( gl_FragCoord.xy / resolution.xy ) + mouse / 4.0;

  float color = 0.0;
  color += sin( position.x * cos( time / 15.0 ) * 80.0 ) + cos( position.y * cos( time / 15.0 ) * 10.0 );
  color += sin( position.y * sin( time / 10.0 ) * 40.0 ) + cos( position.x * sin( time / 25.0 ) * 40.0 );
  color += sin( position.x * sin( time / 5.0 ) * 10.0 ) + sin( position.y * sin( time / 35.0 ) * 80.0 );
  color *= sin( time / 10.0 ) * 0.5;

  gl_FragColor = vec4( vec3( color, color * 0.5, sin( color + time / 3.0 ) * 0.75 ), 1.0 );
  */
}

    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">

      #ifdef GL_ES
      precision mediump float;
      #endif

      uniform vec2 resolution;
      uniform sampler2D texture;

      void main() {

        vec2 uv = gl_FragCoord.xy / resolution.xy;
        gl_FragColor = texture2D( texture, uv );

      }

    </script>

    <script id="vertexShader" type="x-shader/x-vertex">

      attribute vec3 position;

      void main() {

        gl_Position = vec4( position, 1.0 );

      }

    </script>

    <script id="surfaceVertexShader" type="x-shader/x-vertex">

      attribute vec3 position;
      attribute vec2 surfacePosAttrib;
      varying vec2 surfacePosition;

      void main() {

        surfacePosition = surfacePosAttrib;
        gl_Position = vec4( position, 1.0 );

      }

    </script>

    <script>

      initialize_helper();

      var compressor=initialize_compressor();

      if ( !window.requestAnimationFrame ) {

        window.requestAnimationFrame = ( function() {

          return window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            window.oRequestAnimationFrame ||
            window.msRequestAnimationFrame ||
            function ( callback, element ) {

              window.setTimeout( callback, 1000 / 60 );

            };

        } )();

      }

      // Get older browsers safely through init code, so users can read the
      // message about how to download newer browsers.
      if (!Date.now) {
        Date.now = function() {
          return +new Date();
        };
      }

      // Greetings to Iq/RGBA! ;)

      var quality = 2, quality_levels = [ 0.5, 1, 2, 4, 8 ];
      var toolbar, compileButton, fullscreenButton, compileTimer, errorLines = [];
      var code, canvas, gl, buffer, currentProgram, vertexPosition, screenVertexPosition, panButton,
      parameters = { startTime: Date.now(), time: 0, mouseX: 0.5, mouseY: 0.5, screenWidth: 0, screenHeight: 0 },
      surface = { centerX: 0, centerY: 0, width: 1, height: 1, isPanning: false, isZooming: false, lastX: 0, lastY: 0 },
      frontTarget, backTarget, screenProgram, getWebGL, resizer = {}, compileOnChangeCode = true;

      init();
      if (gl) { animate(); }

      function init() {

        if (!document.addEventListener) {
          document.location = 'http://get.webgl.org/';
          return;
        }

        canvas = document.createElement( 'canvas' );
        canvas.style.display = 'block';
        document.body.appendChild( canvas );

        compileButton = document.createElement( 'button' );
        compileButton.textContent = 'compile';
        compileButton.addEventListener( 'click', function ( event ) {

          compile();

        }, false );
        // toolbar.appendChild( compileButton );

        // from helper.js
        add_server_buttons();

        // Initialise WebGL

        try {

          gl = canvas.getContext( 'experimental-webgl', { preserveDrawingBuffer: true } );

        } catch( error ) { }

        if ( !gl ) {

          alert("WebGL not supported, but code will be shown.");

        } else {
          
          // enable dFdx, dFdy, fwidth
          gl.getExtension('OES_standard_derivatives');

          // Create vertex buffer (2 triangles)

          buffer = gl.createBuffer();
          gl.bindBuffer( gl.ARRAY_BUFFER, buffer );
          gl.bufferData( gl.ARRAY_BUFFER, new Float32Array( [ - 1.0, - 1.0, 1.0, - 1.0, - 1.0, 1.0, 1.0, - 1.0, 1.0, 1.0, - 1.0, 1.0 ] ), gl.STATIC_DRAW );

          // Create surface buffer (coordinates at screen corners)

          surface.buffer = gl.createBuffer();
        }

        // initialize code editor
        code = CodeMirror(document.body, {
          lineNumbers: true,
          matchBrackets: true,
          indentWithTabs: true,
          tabSize: 8,
          indentUnit: 8,
          mode: "text/x-glsl",
          onChange: function () {
            if (compileOnChangeCode) {
              clearTimeout(compileTimer);
              compileTimer = setTimeout(compile, 500);
            }
          }
        });
        code.getWrapperElement().style.display = '';

        resizer.offsetMouseX = 0;
        resizer.offsetMouseY = 0;
        resizer.isResizing = false;
        resizer.currentWidth = 100;
        resizer.currentHeight = 100;
        resizer.minWidth = 100;
        resizer.minHeight = 100;
        resizer.maxWidth = 100;
        resizer.maxHeight = 100;
        resizer.element = document.createElement( 'div' );
        resizer.element.className = 'resizer';
        code.getWrapperElement().appendChild(resizer.element);

        resizer.element.addEventListener( 'mousedown', function ( event ) {
          if (event.button !== 2) {
            resizer.offsetMouseX = event.clientX - resizer.currentWidth;
            resizer.offsetMouseY = event.clientY - resizer.currentHeight;
            resizer.isResizing = true;
            event.preventDefault();
          }
        }, false );
        
        if (gl) {

          var surfaceMouseDown = function ( event ) {

            if (event.shiftKey) {
              resetSurface();
            }

            if (event.button === 0) {
              surface.isPanning = true;
              document.body.style.cursor = 'move';
            } else {
              surface.isZooming = true;
              document.body.style.cursor = 'se-resize';
              // panButton.style.cursor = 'se-resize';
            }

            surface.lastX = event.clientX;
            surface.lastY = event.clientY;
            event.preventDefault();

          };

          var noContextMenu = function ( event ) {

            event.preventDefault();

          };

          canvas.addEventListener( 'mousedown', surfaceMouseDown, false );
          // panButton.addEventListener( 'mousedown', surfaceMouseDown, false );

          canvas.addEventListener( 'contextmenu', noContextMenu, false);
          // panButton.addEventListener( 'contextmenu', noContextMenu, false);
        }
        
        var clientXLast, clientYLast;

        document.addEventListener( 'mousemove', function ( event ) {

          var clientX = event.clientX;
          var clientY = event.clientY;

          if (clientXLast == clientX && clientYLast == clientY)
            return;

          clientXLast = clientX;
          clientYLast = clientY;

          // stopHideUI();

          var codeElement, dx, dy;
          
          parameters.mouseX = clientX / window.innerWidth;
          parameters.mouseY = 1 - clientY / window.innerHeight;
            
          if (resizer.isResizing) {

            resizer.currentWidth = Math.max(Math.min(clientX - resizer.offsetMouseX, resizer.maxWidth), resizer.minWidth);
            resizer.currentHeight = Math.max(Math.min(clientY - resizer.offsetMouseY, resizer.maxHeight), resizer.minWidth);
            codeElement = code.getWrapperElement();
            codeElement.style.width = resizer.currentWidth + 'px';
            codeElement.style.height = resizer.currentHeight + 'px';
            code.refresh();
            event.preventDefault();

          } else if (surface.isPanning) {

            dx = clientX - surface.lastX;
            dy = clientY - surface.lastY;
            surface.centerX -= dx * surface.width / window.innerWidth;
            surface.centerY += dy * surface.height / window.innerHeight;
            surface.lastX = clientX;
            surface.lastY = clientY;
            computeSurfaceCorners();
            event.preventDefault();

          } else if (surface.isZooming) {

            dx = clientX - surface.lastX;
            dy = clientY - surface.lastY;
            surface.height *= Math.pow(0.997, dx + dy);
            surface.lastX = clientX;
            surface.lastY = clientY;
            computeSurfaceCorners();
            event.preventDefault();

          }
        }, false );

        function settleDown ( event ) {
          resizer.isResizing = surface.isPanning = surface.isZooming = false;
          document.body.style.cursor = 'default';
          // panButton.style.cursor = 'move';
        }

        function mouseLeave(event) {
          settleDown(event);

          if (!isCodeVisible())
            startHideUITimer();
        }

        document.addEventListener( 'mouseup', settleDown, false );
        document.addEventListener( 'mouseleave', mouseLeave, false );

        onWindowResize();
        window.addEventListener( 'resize', onWindowResize, false );
        load_url_code();

        compileScreenProgram();

      }

      function isCodeVisible() {
        return code && code.getWrapperElement().style.display !== 'none';
      }

      var hideUITimer;
      var isUIHidden = false;

      function startHideUITimer () {

        stopHideUITimer();
        if (!isUIHidden && !isCodeVisible())
          hideUITimer = window.setTimeout(onHideUITimer, 1000 * 5 );

        function onHideUITimer() {

          stopHideUITimer();
          if (!isUIHidden && !isCodeVisible()) {

            isUIHidden = true;
            // toolbar.style.display = 'none';
            document.body.style.cursor = 'none';
          }
        }

        function stopHideUITimer () {

          if (hideUITimer) {

            window.clearTimeout(hideUITimer);
            hideUITimer = 0;
          }
        }
      }

      function stopHideUI () {

        if (isUIHidden) {

          isUIHidden = false;
          // toolbar.style.display = '';
          document.body.style.cursor = '';
        }
        startHideUITimer();
      }


      function computeSurfaceCorners() {

        if (gl) {

          surface.width = surface.height * parameters.screenWidth / parameters.screenHeight;
          
          var halfWidth = surface.width * 0.5, halfHeight = surface.height * 0.5;
          
          gl.bindBuffer( gl.ARRAY_BUFFER, surface.buffer );
          gl.bufferData( gl.ARRAY_BUFFER, new Float32Array( [
            surface.centerX - halfWidth, surface.centerY - halfHeight,
            surface.centerX + halfWidth, surface.centerY - halfHeight,
            surface.centerX - halfWidth, surface.centerY + halfHeight,
            surface.centerX + halfWidth, surface.centerY - halfHeight,
            surface.centerX + halfWidth, surface.centerY + halfHeight,
            surface.centerX - halfWidth, surface.centerY + halfHeight ] ), gl.STATIC_DRAW );

        }

      }

      function resetSurface() {

        surface.centerX = surface.centerY = 0;
        surface.height = 1;
        computeSurfaceCorners();

      }

      function compile() {
      
        if (!gl) {
        
          if (!getWebGL) {
          
            getWebGL = true;
            compileButton.addEventListener( 'click', function ( event ) {

              document.location = 'http://get.webgl.org/';

            }, false );
            compileButton.title = 'http://get.webgl.org/';
            compileButton.style.color = '#ff0000';
            compileButton.textContent = 'WebGL not supported!';
            set_save_button('hidden');
            
          }
          return;
          
        }

        var program = gl.createProgram();
        var fragment = code.getValue();
        var vertex = document.getElementById( 'surfaceVertexShader' ).textContent;

        var vs = createShader( vertex, gl.VERTEX_SHADER );
        var fs = createShader( fragment, gl.FRAGMENT_SHADER );

        if ( vs == null || fs == null ) return null;

        gl.attachShader( program, vs );
        gl.attachShader( program, fs );

        gl.deleteShader( vs );
        gl.deleteShader( fs );

        gl.linkProgram( program );

        if ( !gl.getProgramParameter( program, gl.LINK_STATUS ) ) {

          var error = gl.getProgramInfoLog( program );

          compileButton.title = error;
          console.error( error );

          console.error( 'VALIDATE_STATUS: ' + gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'ERROR: ' + gl.getError() );
          compileButton.style.color = '#ff0000';
          compileButton.textContent = 'compiled with errors';

          set_save_button('hidden');

          return;

        }

        if ( currentProgram ) {

          gl.deleteProgram( currentProgram );
          setURL( fragment );

        }

        currentProgram = program;

        compileButton.style.color = '#00ff00';
        compileButton.textContent = 'compiled successfully';

        set_save_button('visible');

        // panButton.style.display = (fragment.indexOf('varying vec2 surfacePosition;') >= 0) ? 'inline' : 'none';

        // Cache uniforms

        cacheUniformLocation( program, 'time' );
        cacheUniformLocation( program, 'mouse' );
        cacheUniformLocation( program, 'resolution' );
        cacheUniformLocation( program, 'backbuffer' );
        cacheUniformLocation( program, 'surfaceSize' );

        // Load program into GPU

        gl.useProgram( currentProgram );

        // Set up buffers

        surface.positionAttribute = gl.getAttribLocation(currentProgram, "surfacePosAttrib");
        gl.enableVertexAttribArray(surface.positionAttribute);

        vertexPosition = gl.getAttribLocation(currentProgram, "position");
        gl.enableVertexAttribArray( vertexPosition );

      }

      function compileScreenProgram() {
      
        if (!gl) { return; }

        var program = gl.createProgram();
        var fragment = document.getElementById( 'fragmentShader' ).textContent;
        var vertex = document.getElementById( 'vertexShader' ).textContent;

        var vs = createShader( vertex, gl.VERTEX_SHADER );
        var fs = createShader( fragment, gl.FRAGMENT_SHADER );

        gl.attachShader( program, vs );
        gl.attachShader( program, fs );

        gl.deleteShader( vs );
        gl.deleteShader( fs );

        gl.linkProgram( program );

        if ( !gl.getProgramParameter( program, gl.LINK_STATUS ) ) {

          console.error( 'VALIDATE_STATUS: ' + gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'ERROR: ' + gl.getError() );

          return;

        }

        screenProgram = program;

        gl.useProgram( screenProgram );

        cacheUniformLocation( program, 'resolution' );
        cacheUniformLocation( program, 'texture' );

        screenVertexPosition = gl.getAttribLocation(screenProgram, "position");
        gl.enableVertexAttribArray( screenVertexPosition );

      }

      function cacheUniformLocation( program, label ) {

        if ( program.uniformsCache === undefined ) {

          program.uniformsCache = {};

        }

        program.uniformsCache[ label ] = gl.getUniformLocation( program, label );

      }

      //

      function createTarget( width, height ) {

        var target = {};

        target.framebuffer = gl.createFramebuffer();
        target.renderbuffer = gl.createRenderbuffer();
        target.texture = gl.createTexture();

        // set up framebuffer

        gl.bindTexture( gl.TEXTURE_2D, target.texture );
        gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );

        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );

        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

        gl.bindFramebuffer( gl.FRAMEBUFFER, target.framebuffer );
        gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0 );

        // set up renderbuffer

        gl.bindRenderbuffer( gl.RENDERBUFFER, target.renderbuffer );

        gl.renderbufferStorage( gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height );
        gl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, target.renderbuffer );

        // clean up

        gl.bindTexture( gl.TEXTURE_2D, null );
        gl.bindRenderbuffer( gl.RENDERBUFFER, null );
        gl.bindFramebuffer( gl.FRAMEBUFFER, null);

        return target;

      }

      function createRenderTargets() {

        frontTarget = createTarget( parameters.screenWidth, parameters.screenHeight );
        backTarget = createTarget( parameters.screenWidth, parameters.screenHeight );

      }

      //

      var dummyFunction = function() {};


      //
      
      function htmlEncode(str){

        return String(str)
          .replace(/&/g, '&amp;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;');

      }

      //

      function createShader( src, type ) {
      
        var shader = gl.createShader( type );
        var line, lineNum, lineError, index = 0, indexEnd;

        while (errorLines.length > 0) {
          line = errorLines.pop();
          code.setLineClass(line, null);
          code.clearMarker(line);
        }

        gl.shaderSource( shader, src );
        gl.compileShader( shader );

        compileButton.title = '';

        if ( !gl.getShaderParameter( shader, gl.COMPILE_STATUS ) ) {

          var error = gl.getShaderInfoLog( shader );
          
          // Remove trailing linefeed, for FireFox's benefit.
          while ((error.length > 1) && (error.charCodeAt(error.length - 1) < 32)) {
            error = error.substring(0, error.length - 1);
          }

          compileButton.title = error;
          console.error( error );

          compileButton.style.color = '#ff0000';
          compileButton.textContent = 'compiled with errors';

          set_save_button('hidden');

          while (index >= 0) {
            index = error.indexOf("ERROR: 0:", index);
            if (index < 0) { break; }
            index += 9;
            indexEnd = error.indexOf(':', index);
            if (indexEnd > index) {
              lineNum = parseInt(error.substring(index, indexEnd));
              if ((!isNaN(lineNum)) && (lineNum > 0)) {
                index = indexEnd + 1;
                indexEnd = error.indexOf("ERROR: 0:", index);
                lineError = htmlEncode((indexEnd > index) ? error.substring(index, indexEnd) : error.substring(index));
                line = code.setMarker(lineNum - 1, '<abbr title="' + lineError + '">' + lineNum + '</abbr>', "errorMarker");
                code.setLineClass(line, "errorLine");
                errorLines.push(line);
              }
            }
          }

          return null;

        }

        return shader;

      }

      //

      function onWindowResize( event ) {

        var isMaxWidth = ((resizer.currentWidth === resizer.maxWidth) || (resizer.currentWidth === resizer.minWidth)),
          isMaxHeight = ((resizer.currentHeight === resizer.maxHeight) || (resizer.currentHeight === resizer.minHeight));

        // toolbar.style.width = window.innerWidth - 47 + 'px';

        resizer.isResizing = false;
        resizer.maxWidth = window.innerWidth - 75;
        resizer.maxHeight = window.innerHeight - 125;
        if (isMaxWidth || (resizer.currentWidth > resizer.maxWidth)) {
          resizer.currentWidth = resizer.maxWidth;
        }
        if (isMaxHeight || (resizer.currentHeight > resizer.maxHeight)) {
          resizer.currentHeight = resizer.maxHeight;
        }
        if (resizer.currentWidth < resizer.minWidth) { resizer.currentWidth = resizer.minWidth; }
        if (resizer.currentHeight < resizer.minHeight) { resizer.currentHeight = resizer.minHeight; }

        code.getWrapperElement().style.top = '75px';
        code.getWrapperElement().style.left = '25px';
        code.getWrapperElement().style.width = resizer.currentWidth + 'px';
        code.getWrapperElement().style.height = resizer.currentHeight + 'px';

        canvas.width = window.innerWidth / quality;
        canvas.height = window.innerHeight / quality;

        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';

        parameters.screenWidth = canvas.width;
        parameters.screenHeight = canvas.height;

        computeSurfaceCorners();

        if (gl) {
        
          gl.viewport( 0, 0, canvas.width, canvas.height );

          createRenderTargets();
          
        }
      }

      //

      function animate() {

        requestAnimationFrame( animate );
        render();

      }

      function render() {

        if ( !currentProgram ) return;

        parameters.time = Date.now() - parameters.startTime;

        // Set uniforms for custom shader

        gl.useProgram( currentProgram );

        gl.uniform1f( currentProgram.uniformsCache[ 'time' ], parameters.time / 1000 );
        gl.uniform2f( currentProgram.uniformsCache[ 'mouse' ], parameters.mouseX, parameters.mouseY );
        gl.uniform2f( currentProgram.uniformsCache[ 'resolution' ], parameters.screenWidth, parameters.screenHeight );
        gl.uniform1i( currentProgram.uniformsCache[ 'backbuffer' ], 0 );
        gl.uniform2f( currentProgram.uniformsCache[ 'surfaceSize' ], surface.width, surface.height );

        gl.bindBuffer( gl.ARRAY_BUFFER, surface.buffer );
        gl.vertexAttribPointer( surface.positionAttribute, 2, gl.FLOAT, false, 0, 0 );
        
        gl.bindBuffer( gl.ARRAY_BUFFER, buffer );
        gl.vertexAttribPointer( vertexPosition, 2, gl.FLOAT, false, 0, 0 );

        gl.activeTexture( gl.TEXTURE0 );
        gl.bindTexture( gl.TEXTURE_2D, backTarget.texture );

        // Render custom shader to front buffer

        gl.bindFramebuffer( gl.FRAMEBUFFER, frontTarget.framebuffer );

        gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );
        gl.drawArrays( gl.TRIANGLES, 0, 6 );

        // Set uniforms for screen shader

        gl.useProgram( screenProgram );

        gl.uniform2f( screenProgram.uniformsCache[ 'resolution' ], parameters.screenWidth, parameters.screenHeight );
        gl.uniform1i( screenProgram.uniformsCache[ 'texture' ], 1 );

        gl.bindBuffer( gl.ARRAY_BUFFER, buffer );
        gl.vertexAttribPointer( screenVertexPosition, 2, gl.FLOAT, false, 0, 0 );
        
        gl.activeTexture( gl.TEXTURE1 );
        gl.bindTexture( gl.TEXTURE_2D, frontTarget.texture );

        // Render front buffer to screen

        gl.bindFramebuffer( gl.FRAMEBUFFER, null );

        gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );
        gl.drawArrays( gl.TRIANGLES, 0, 6 );

        // Swap buffers

        var tmp = frontTarget;
        frontTarget = backTarget;
        backTarget = tmp;



      }
      code.getWrapperElement().style.display = 'none';
    </script><canvas style="display: block; width: 583px; height: 682px;" width="291" height="341"></canvas><div style="position: absolute; top: -125px; left: 25px; width: 536px;"><div style="float: right;"><button title="Pan: left-drag, Zoom: right-drag. Use &#39;hide code&#39; for a large pan/zoom area." style="cursor: move; display: inline;">pan/zoom</button><button title="Press F11 to enter or leave fullscreen mode">fullscreen</button><a href="http://www.glslsandbox.com/">gallery</a></div>

<div style="position: fixed;top :0px;left:80px;right:0px;bottom:0px;font:20px 宋体;word-spacing:direction:rtl;overflow:auto;rgba(255,255,255,0.15);text-align:left;">
<!--changeTag-->
<body>
<section id="吴-晓" class="level1">
<h1>吴 晓</h1>
<div align="left" margin-left="9">
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAAEtCAYAAABNpi8bAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAuIwAALiMBeKU/dgAAEV5pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDUuNC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWZFWD0iaHR0cDovL2NpcGEuanAvZXhpZi8xLjAvIgogICAgICAgICAgICB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmF1eD0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC9hdXgvIgogICAgICAgICAgICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgICAgICAgICAgIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIj4KICAgICAgICAgPGV4aWY6U2NlbmVUeXBlPjE8L2V4aWY6U2NlbmVUeXBlPgogICAgICAgICA8ZXhpZjpTdWJzZWNUaW1lRGlnaXRpemVkPjAwPC9leGlmOlN1YnNlY1RpbWVEaWdpdGl6ZWQ+CiAgICAgICAgIDxleGlmOklTT1NwZWVkUmF0aW5ncz4KICAgICAgICAgICAgPHJkZjpTZXE+CiAgICAgICAgICAgICAgIDxyZGY6bGk+MjAwPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC9leGlmOklTT1NwZWVkUmF0aW5ncz4KICAgICAgICAgPGV4aWY6Rmxhc2ggcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8ZXhpZjpGdW5jdGlvbj5GYWxzZTwvZXhpZjpGdW5jdGlvbj4KICAgICAgICAgICAgPGV4aWY6RmlyZWQ+RmFsc2U8L2V4aWY6RmlyZWQ+CiAgICAgICAgICAgIDxleGlmOlJldHVybj4wPC9leGlmOlJldHVybj4KICAgICAgICAgICAgPGV4aWY6TW9kZT4wPC9leGlmOk1vZGU+CiAgICAgICAgICAgIDxleGlmOlJlZEV5ZU1vZGU+RmFsc2U8L2V4aWY6UmVkRXllTW9kZT4KICAgICAgICAgPC9leGlmOkZsYXNoPgogICAgICAgICA8ZXhpZjpVc2VyQ29tbWVudD4KICAgICAgICAgICAgPHJkZjpBbHQ+CiAgICAgICAgICAgICAgIDxyZGY6bGkgeG1sOmxhbmc9IngtZGVmYXVsdCI+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOkFsdD4KICAgICAgICAgPC9leGlmOlVzZXJDb21tZW50PgogICAgICAgICA8ZXhpZjpDb250cmFzdD4wPC9leGlmOkNvbnRyYXN0PgogICAgICAgICA8ZXhpZjpDb21wcmVzc2VkQml0c1BlclBpeGVsPjQvMTwvZXhpZjpDb21wcmVzc2VkQml0c1BlclBpeGVsPgogICAgICAgICA8ZXhpZjpHYWluQ29udHJvbD4wPC9leGlmOkdhaW5Db250cm9sPgogICAgICAgICA8ZXhpZjpTdWJzZWNUaW1lT3JpZ2luYWw+MDA8L2V4aWY6U3Vic2VjVGltZU9yaWdpbmFsPgogICAgICAgICA8ZXhpZjpEaWdpdGFsWm9vbVJhdGlvPjEvMTwvZXhpZjpEaWdpdGFsWm9vbVJhdGlvPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+MzAxPC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6Q3VzdG9tUmVuZGVyZWQ+MDwvZXhpZjpDdXN0b21SZW5kZXJlZD4KICAgICAgICAgPGV4aWY6TWV0ZXJpbmdNb2RlPjU8L2V4aWY6TWV0ZXJpbmdNb2RlPgogICAgICAgICA8ZXhpZjpQaXhlbFhEaW1lbnNpb24+MjAwPC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6U3Vic2VjVGltZT4wMDwvZXhpZjpTdWJzZWNUaW1lPgogICAgICAgICA8ZXhpZjpTY2VuZUNhcHR1cmVUeXBlPjA8L2V4aWY6U2NlbmVDYXB0dXJlVHlwZT4KICAgICAgICAgPGV4aWY6Rm9jYWxMZW5JbjM1bW1GaWxtPjc4PC9leGlmOkZvY2FsTGVuSW4zNW1tRmlsbT4KICAgICAgICAgPGV4aWY6Q29tcG9uZW50c0NvbmZpZ3VyYXRpb24+CiAgICAgICAgICAgIDxyZGY6U2VxPgogICAgICAgICAgICAgICA8cmRmOmxpPjE8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaT4yPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGk+MzwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPjA8L3JkZjpsaT4KICAgICAgICAgICAgPC9yZGY6U2VxPgogICAgICAgICA8L2V4aWY6Q29tcG9uZW50c0NvbmZpZ3VyYXRpb24+CiAgICAgICAgIDxleGlmOkV4cG9zdXJlTW9kZT4xPC9leGlmOkV4cG9zdXJlTW9kZT4KICAgICAgICAgPGV4aWY6U2F0dXJhdGlvbj4wPC9leGlmOlNhdHVyYXRpb24+CiAgICAgICAgIDxleGlmOkV4cG9zdXJlVGltZT4xMC8xNjAwPC9leGlmOkV4cG9zdXJlVGltZT4KICAgICAgICAgPGV4aWY6U2hhcnBuZXNzPjE8L2V4aWY6U2hhcnBuZXNzPgogICAgICAgICA8ZXhpZjpFeGlmVmVyc2lvbj4wMjIxPC9leGlmOkV4aWZWZXJzaW9uPgogICAgICAgICA8ZXhpZjpGaWxlU291cmNlPjM8L2V4aWY6RmlsZVNvdXJjZT4KICAgICAgICAgPGV4aWY6Rmxhc2hQaXhWZXJzaW9uPjAxMDA8L2V4aWY6Rmxhc2hQaXhWZXJzaW9uPgogICAgICAgICA8ZXhpZjpXaGl0ZUJhbGFuY2U+MDwvZXhpZjpXaGl0ZUJhbGFuY2U+CiAgICAgICAgIDxleGlmOkNvbG9yU3BhY2U+MTwvZXhpZjpDb2xvclNwYWNlPgogICAgICAgICA8ZXhpZjpTdWJqZWN0RGlzdFJhbmdlPjA8L2V4aWY6U3ViamVjdERpc3RSYW5nZT4KICAgICAgICAgPGV4aWY6Rm9jYWxMZW5ndGg+NTIwLzEwPC9leGlmOkZvY2FsTGVuZ3RoPgogICAgICAgICA8ZXhpZjpFeHBvc3VyZVByb2dyYW0+MTwvZXhpZjpFeHBvc3VyZVByb2dyYW0+CiAgICAgICAgIDxleGlmOlNlbnNpbmdNZXRob2Q+MjwvZXhpZjpTZW5zaW5nTWV0aG9kPgogICAgICAgICA8ZXhpZjpGTnVtYmVyPjkwLzEwPC9leGlmOkZOdW1iZXI+CiAgICAgICAgIDxleGlmOk1heEFwZXJ0dXJlVmFsdWU+NTAvMTA8L2V4aWY6TWF4QXBlcnR1cmVWYWx1ZT4KICAgICAgICAgPGV4aWY6TGlnaHRTb3VyY2U+MDwvZXhpZjpMaWdodFNvdXJjZT4KICAgICAgICAgPGV4aWY6RXhwb3N1cmVCaWFzVmFsdWU+MzAvNjwvZXhpZjpFeHBvc3VyZUJpYXNWYWx1ZT4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5QaXhlbG1hdG9yIDMuNC4yPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDEwLTA3LTE1VDAxOjMwOjA0LjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTc6MDI6MjUgMTI6MDI6Mjg8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8dGlmZjpDb21wcmVzc2lvbj41PC90aWZmOkNvbXByZXNzaW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICAgICA8dGlmZjpYUmVzb2x1dGlvbj4zMDA8L3RpZmY6WFJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOllSZXNvbHV0aW9uPjMwMDwvdGlmZjpZUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6TW9kZWw+TklLT04gRDQwPC90aWZmOk1vZGVsPgogICAgICAgICA8dGlmZjpNYWtlPk5JS09OIENPUlBPUkFUSU9OPC90aWZmOk1ha2U+CiAgICAgICAgIDxleGlmRVg6UGhvdG9ncmFwaGljU2Vuc2l0aXZpdHk+MjAwPC9leGlmRVg6UGhvdG9ncmFwaGljU2Vuc2l0aXZpdHk+CiAgICAgICAgIDxwaG90b3Nob3A6RGF0ZUNyZWF0ZWQ+MjAxMC0wNy0xNVQwMTozMDowNC4wMDwvcGhvdG9zaG9wOkRhdGVDcmVhdGVkPgogICAgICAgICA8YXV4OkxlbnM+QUYtUyBEWCBab29tLU5pa2tvciAxOC01NW1tIGYvMy41LTUuNkcgRUQ8L2F1eDpMZW5zPgogICAgICAgICA8YXV4OkxlbnNJbmZvPjE4LzEgNTUvMSA3LzIgMjgvNTwvYXV4OkxlbnNJbmZvPgogICAgICAgICA8YXV4OlNlcmlhbE51bWJlcj45MDg3MzY5PC9hdXg6U2VyaWFsTnVtYmVyPgogICAgICAgICA8YXV4OkltYWdlTnVtYmVyPjI2MTc1PC9hdXg6SW1hZ2VOdW1iZXI+CiAgICAgICAgIDxhdXg6Rmxhc2hDb21wZW5zYXRpb24+MC8xPC9hdXg6Rmxhc2hDb21wZW5zYXRpb24+CiAgICAgICAgIDxhdXg6TGVuc0lEPi04MzQwNjE2Njc0NjQyNDU3MDgyPC9hdXg6TGVuc0lEPgogICAgICAgICA8ZGM6c3ViamVjdD4KICAgICAgICAgICAgPHJkZjpCYWcvPgogICAgICAgICA8L2RjOnN1YmplY3Q+CiAgICAgICAgIDx4bXBNTTpJbnN0YW5jZUlEPnV1aWQ6ZmFmNWJkZDUtYmEzZC0xMWRhLWFkMzEtZDMzZDc1MTgyZjFiPC94bXBNTTpJbnN0YW5jZUlEPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAg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" width="130" height="190/"></p>
</div>
<section id="图形工程师" class="level2">
<h2>图形工程师</h2>
<ul>
<li>电话: <a href="tel://86-15861657693">86-15861657693</a></li>
<li>邮件: <a href="mailto:tinysilk@hotmail.com">tinysilk@hotmail.com</a></li>
<li>博客（墙外）: <a href="http://tinyslik.github.io">tinyslik.github.io</a></li>
<li>博客（墙内）: <a href="http://tinyslik.coding.me">tinyslik.coding.me</a></li>
<li>Github: <a href="http://github.com/TinySlik">TinySlik</a></li>
</ul>
</section>
<section id="简介" class="level2">
<h2>简介</h2>
<p>一个有四年开发经验的小司机。 开发过很多款上线手游项目，上架了appStroe，googlePlay以及国内大量的杂鱼渠道；</p>
</section>
<section id="特长" class="level2">
<h2>特长</h2>
<p>能胜任android（java），ios（OC）单平台或者跨平台C++的开发工作，对css，html5，js均有良好的掌握度，能够进行前端开发；<br />
对openGL有良好的掌握度，对shader优化编写使用熟练。对图形数学有良好的认识和基础。 长期使用cocos2d-x,uinity3d游戏引擎，对游戏引擎的工具编写也有良好的习惯。</p>
</section>
<section id="工作经验" class="level2">
<h2>工作经验</h2>
<section id="cocos2d-x-开发工程师-在-mochang有限公司" class="level3">
<h3><strong>cocos2d-x 开发工程师</strong> 在 <a href="https://www.mochang.net/">MoChang有限公司</a></h3>
<p><em>2014.1 - 2015.6</em></p>
<p>1.在公司主要从事cocos2d-x游戏的制作和维护工作，使用C++重构代码，配置更多的功能模块. 2.作为从事生物科技工作的我来说，这是一次挑战，我学习到了很多C++基本的语法及表驱动，插件架构等常用的语言设计模式。补习了很多程序及系统的基础原理，对linux系统的学习了一段时间，能独立编写小型的c++服务器。 3.在公司我工作了一年半，上架了一些比较简单的欧美儿童游戏，有大量的功能模块重用和维护。 4.期间也独立完成很多 ios 及安卓端的 sdk包括广告的和功能的接入。 5.制作小型游戏制定文档并按照需求文档在较短的时间内提交上线。 6.由于团队小，所以大量的与美术的协调工作都由我独立完成，团队的策划担任高层领导角色，团队具有比较高的自由度。</p>
</section>
<section id="cc-开发工程师-在-南京光辉互动网络科技有限公司熊大叔儿童教育" class="level3">
<h3><strong>C/C++ 开发工程师</strong> 在 <a href="https://bie-plc.com/">南京光辉互动网络科技有限公司</a>/<a href="https://www.biemore.com/zh-cn/index.html">熊大叔儿童教育</a></h3>
<p><em>2015.6 - 2016.2</em></p>
<p>1.一线开发游戏项目，对多个产品线不同语言的项目代码进行检查和修改重构，使用代码包括包括js,Lua,C++。 2.实现shader技术优化和难点。 3.负责一些产品最后阶段的代码调试和检查工作，接入一些商业代码,sdk。</p>
</section>
<section id="前端工程师兼培训师-在-南京触控科技办事处" class="level3">
<h3><strong>前端工程师兼培训师</strong> 在 <a href="http://www.chukong-inc.com/">南京触控科技办事处</a></h3>
<p><em>2016.3 - 2016.10</em></p>
<p>1.参与3.x的cocos2d-x引擎代码的修改和维护，上架一些以前的成品代码游戏。 2.培训新员工，培训git，lua,quick-cocos部分内容。 3.修改和上线u3d项目.</p>
</section>
<section id="主要语言技能" class="level3">
<h3>主要语言技能</h3>
<p>注：<br />
+：使用过，了解语法，能够上手修改现有的浅层代码逻辑<br />
++：全盘学习过，理解语言全盘的语法，对语言的相关设计理念有认识，对相关特性够熟练运用 +++：相关语言的基本设计模式能够完全应用于实践，能够胜任框架的搭建</p>
<ul>
<li><a href="http://www.cplusplus.com/">C++</a>+++</li>
<li>C++</li>
<li><a href="http://www.lua.org/">Lua</a>+++</li>
<li><a href="https://www.java.com/zh_CN/">java</a>+</li>
<li><a href="https://developer.apple.com/">objective-C</a>+</li>
<li><a href="https://www.microsoft.com/net/">C#</a>++</li>
<li><a href="https://www.glslsandbox.com/">shader</a>+++</li>
<li><a href="https://www.javascript.com/">javaScript</a>++</li>
<li><a href="http://developers.whatwg.org">HTML</a>++</li>
<li><a href="http://www.w3.org/Style/CSS/Overview.en.html">CSS</a>+</li>
<li><a href="https://www.python.org/">python</a>+</li>
<li><a href="http://www.ruby-lang.org/zh_cn/">Ruby (Rake)</a>++</li>
<li><a href="http://www.uml.org/">UML</a>+</li>
</ul>
</section>
<section id="格式类型使用" class="level3">
<h3>格式类型使用</h3>
<p>注：<br />
+：了解并修改过小于5次。 ++：全盘学习过，熟练使用语法书写内容或修改配置。 +++：查看过底层格式实现原理，并修改使用过自己的衍生格式。</p>
<ul>
<li><a href="http://daringfireball.net/projects/markdown">Markdown</a>++</li>
<li><a href="https://www.xml.com/">XML</a>+</li>
<li><a href="http://www.json.org.cn/">Jason</a>++</li>
<li><a href="https://github.com/Winnerhust/inifile2">ini</a>++</li>
</ul>
</section>
<section id="框架" class="level3">
<h3>框架</h3>
<p>注*：<br />
+：使用过，了接口用法，能够快速使用。 ++：模块化地学习过，理解框架下原理，能够熟练进行相关优化。 +++：查看学习过框架源码，修改框架内部实现并商用化过相关的代码。</p>
<ul>
<li><a href="https://www.opengl.org/">OpenGL （web,ES,glut,glew,glsl…）</a>++</li>
<li><a href="http://opencv.org/">openCV</a>+</li>
<li><a href="http://www.boost.org/">Boost (shared_ptr,λ,tuple,thread…)</a>++</li>
<li><a href="http://www.cocos2d-x.org/">Cocos2d-x</a>+++</li>
<li><a href="https://unity3d.com/cn/">Uinity3d</a>++</li>
<li><a href="https://hexo.io/">hexo</a>++</li>
<li>http,tcp/ip,udp+</li>
</ul>
</section>
<section id="软件" class="level3">
<h3>软件</h3>
<p>注*：<br />
+：使用过，能够完成常规的工具功能 ++：熟练使用，包括快捷键和高度自定义的功能 +++：查看过软件源码，修改衍生过相关的商用版本</p>
<ul>
<li><p>IDE:<a href="http://developer.apple.com">Apple Xcode</a>++/<a href="https://www.visualstudio.com/">VisualStudio</a>++/<a href="http://www.android-studio.org/">AndroidStudio</a>+</p></li>
<li><a href="http://git-scm.com">Git</a>++</li>
<li><a href="http://svn.apache.org">Subversion</a>+</li>
<li><a href="https://www.sourcetreeapp.com/">SourceTree(win)</a>/<a href="https://www.git-tower.com/">Tower(mac)</a>++</li>
<li><p><a href="http://atlassian.com/software/jira">JIRA</a>+</p></li>
<li><a href="http://www.gnu.org/software/grub/">grub/grub2</a>++</li>
<li><p><a href="http://apple.com/macosx">Mac OS X</a>++/<a href="http://ubuntu.com">Ubuntu Linux</a>++</p></li>
<li><a href="http://www.sublimetext.com">Sublime Text</a>++</li>
<li><a href="http://www.vim.org">Vim</a>++</li>
<li><a href="http://www.zsh.org">zsh</a>++</li>
<li><a href="http://www.gnu.org/software/bash/">bash</a>++</li>
<li><p><a href="http://jetbrains.com/webstorm">WebStorm</a>+</p></li>
<li><a href="http://johnmacfarlane.net/pandoc">Pandoc</a>+</li>
<li><a href="https://github.com/doxygen/doxygen">Doxygen</a>+</li>
<li><p><a href="http://www.latex-project.org/">Latex</a>+</p></li>
<li><a href="http://wiki.nginx.org">Nginx</a>+</li>
<li><p><a href="http://mysql.com">MySQL</a>+</p></li>
</ul>
</section>
</section>
<section id="教育" class="level2">
<h2>教育</h2>
<p><a href>扬州大学 动物医学</a>, 2008 - 2012</p>
</section>
<section id="兴趣" class="level2">
<h2>兴趣</h2>
<ul>
<li>玩卡牌游戏（炉石）,至今未上传说…</li>
<li>听音乐,玩一些器材,中西内外新旧都听</li>
<li>养猫,叫毛毛,一只英短蓝色的小母猫</li>
<li>弹吉他,准备周末去卖艺</li>
<li>逛github,知乎,Bilibili 找基佬玩耍</li>
<li>另外已婚未育</li>
</ul>
</section>
<section id="下载" class="level2">
<h2>下载</h2>
<p>以下是我的多种格式下的简历，如有需要请自行下载：</p>
<p><a href="https://github.com/TinySlik/resume/raw/master/resume_cn.docx">doc</a></p>
<p><a href="https://github.com/TinySlik/resume/raw/master/resume_cn.epub">ePub</a></p>
<p>谢谢对我的关注.</p>
<p>©2016 <a href="http://tinyslik.coding.me/resume">Tiny Oh</a>. All rights reserved.</p>
</section>
</section>
</body>
</html>
